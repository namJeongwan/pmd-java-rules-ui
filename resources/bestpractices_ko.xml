<?xml version="1.0" encoding="UTF-8"?>

<ruleset name="모범 사례"
    xmlns="http://pmd.sourceforge.net/ruleset/2.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd">

    <description>
일반적으로 인정되는 모범 사례를 적용하는 규칙입니다.
    </description>

    <rule name="AbstractClassWithoutAbstractMethod"
          language="java"
          since="3.0"
          message="이 추상 클래스에는 추상 메서드가 없습니다"
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.AbstractClassWithoutAbstractMethodRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#abstractclasswithoutabstractmethod">
        <description>
추상 클래스에 추상 메서드가 포함되어 있지 않습니다. 추상 클래스는 불완전한 구현을 나타내며,
하위 클래스에서 추상 메서드를 구현하여 완성해야 합니다. 클래스가 기본 클래스로만 사용되도록
의도된 경우(직접 인스턴스화하지 않음), protected 생성자를 제공하여 직접 인스턴스화를 방지할 수 있습니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public abstract class Foo {
  void int method1() { ... }
  void int method2() { ... }
  // consider using abstract methods or removing
  // the abstract modifier and adding protected constructors
}
]]>
        </example>
    </rule>

    <rule name="AccessorClassGeneration"
          language="java"
          since="1.04"
          maximumLanguageVersion="10"
          message="생성자의 클래스 외부에서 private 생성자를 통한 인스턴스화를 피하십시오."
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.AccessorClassGenerationRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#accessorclassgeneration">
        <description>
생성자의 클래스 외부에서 private 생성자를 통해 인스턴스화하면 접근자(accessor)가 생성되는 경우가 많습니다.
팩토리 메서드를 사용하거나 생성자를 non-private로 변경하면 이 상황을 제거할 수 있습니다.
생성된 클래스 파일은 실제로 인터페이스입니다. 이는 접근하는 클래스에게 인터페이스를 보조 매개변수로
받는 새로운 숨겨진 패키지 범위 생성자를 호출할 수 있는 능력을 부여합니다.
이로 인해 private 생성자가 사실상 패키지 범위를 가진 것처럼 되어 식별하기 어렵습니다.

_참고:_ 이 규칙은 Java 10 이하에서만 실행됩니다.
Java 11부터 [JEP 181: Nest-Based Access Control](https://openjdk.org/jeps/181)이 구현되었습니다.
즉, Java 11 이상에서는 접근자 클래스가 더 이상 생성되지 않습니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public class Outer {
 void method(){
  Inner ic = new Inner();//Causes generation of accessor class
 }
 public class Inner {
  private Inner(){}
 }
}
]]>
        </example>
    </rule>

    <rule name="AccessorMethodGeneration"
          language="java"
          since="5.5.4"
          maximumLanguageVersion="10"
          message="합성 접근자 메서드 없이 {0}에서 접근하려면 이 멤버에 패키지 가시성을 부여하는 것을 고려하십시오"
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.AccessorMethodGenerationRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#accessormethodgeneration">
        <description>
다른 클래스에서 private 필드/메서드에 접근할 때, Java 컴파일러는 패키지-private 가시성을 가진 접근자 메서드를
생성합니다. 이는 오버헤드를 추가하고 Android에서는 dex 메서드 수에 영향을 줍니다.
필드/메서드의 가시성을 private에서 패키지-private로 변경하면 이 상황을 피할 수 있습니다.


_참고:_ 이 규칙은 Java 10 이하에서만 실행됩니다.
Java 11부터 [JEP 181: Nest-Based Access Control](https://openjdk.org/jeps/181)이 구현되었습니다.
즉, Java 11 이상에서는 접근자 클래스가 더 이상 생성되지 않습니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public class OuterClass {
    private int counter;
    /* package */ int id;

    public class InnerClass {
        InnerClass() {
            OuterClass.this.counter++; // wrong accessor method will be generated
        }

        public int getOuterClassId() {
            return OuterClass.this.id; // id is package-private, no accessor method needed
        }
    }
}
]]>
        </example>
    </rule>

    <rule name="ArrayIsStoredDirectly"
          language="java"
          since="2.2"
          message="사용자가 제공한 배열 ''{0}''이(가) 직접 저장되었습니다."
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.ArrayIsStoredDirectlyRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#arrayisstoreddirectly">
        <description>
배열을 받는 생성자와 메서드는 객체를 복제하여 복사본을 저장해야 합니다.
이렇게 하면 사용자의 향후 변경이 원본 배열에 영향을 미치는 것을 방지할 수 있습니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public class Foo {
    private String [] x;
        public void foo (String [] param) {
        // Don't do this, make a copy of the array at least
        this.x=param;
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidMessageDigestField"
          language="java"
          since="6.18.0"
          message="MessageDigest 타입의 필드를 선언하지 마십시오. 동기화되지 않은 접근은 문제를 일으킬 수 있습니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#avoidmessagedigestfield">
        <description>
            MessageDigest 인스턴스를 필드로 선언하면 이 인스턴스가 여러 스레드에서 직접 사용 가능하게 됩니다.
            이러한 MessageDigest 인스턴스의 공유는 접근이 올바르게 동기화되지 않으면 잘못된 결과를 초래하므로
            가능하면 피해야 합니다.
            필요한 곳에서 새 인스턴스를 생성하여 로컬로 사용하십시오.
            새 인스턴스를 생성하는 것이 공유 인스턴스에 대한 접근을 동기화하는 것보다 쉽습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//FieldDeclaration/ClassType[pmd-java:typeIs('java.security.MessageDigest')]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
import java.security.MessageDigest;
public class AvoidMessageDigestFieldExample {
    private final MessageDigest sharedMd;
    public AvoidMessageDigestFieldExample() throws Exception {
        sharedMd = MessageDigest.getInstance("SHA-256");
    }
    public byte[] calculateHashShared(byte[] data) {
        // sharing a MessageDigest like this without synchronizing access
        // might lead to wrong results
        sharedMd.reset();
        sharedMd.update(data);
        return sharedMd.digest();
    }

    // better
    public byte[] calculateHash(byte[] data) throws Exception {
        MessageDigest md = MessageDigest.getInstance("SHA-256");
        md.update(data);
        return md.digest();
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidPrintStackTrace"
          language="java"
          since="3.2"
          message="printStackTrace() 사용을 피하고 대신 로거 호출을 사용하십시오."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#avoidprintstacktrace">
        <description>
printStackTrace() 사용을 피하고 대신 로거 호출을 사용하십시오.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//MethodCall[ pmd-java:matchesSig("java.lang.Throwable#printStackTrace()") ]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
class Foo {
    void bar() {
        try {
            // do something
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidReassigningCatchVariables"
          language="java"
          since="6.27.0"
          message="catch된 예외 ''{0}''의 재할당을 피하십시오"
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.AvoidReassigningCatchVariablesRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#avoidreassigningcatchvariables">
        <description>
catch 문에서 잡은 예외 변수의 재할당은 다음과 같은 이유로 피해야 합니다:

1) 필요한 경우, 멀티 catch를 쉽게 추가할 수 있으며 코드는 여전히 컴파일됩니다.

2) 최소 놀람 원칙에 따라, catch 문에서 잡은 변수가 항상 try 블록에서 던져진 것과 동일하도록 보장하고자 합니다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
public class Foo {
    public void foo() {
        try {
            // do something
        } catch (Exception e) {
            e = new NullPointerException(); // not recommended
        }

        try {
            // do something
        } catch (MyException | ServerException e) {
            e = new RuntimeException(); // won't compile
        }
    }
}
        ]]></example>
    </rule>

    <rule name="AvoidReassigningLoopVariables"
          language="java"
          since="6.11.0"
          message="루프 제어 변수 ''{0}''의 재할당을 피하십시오"
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.AvoidReassigningLoopVariablesRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#avoidreassigningloopvariables">
        <description>
루프 변수의 재할당은 찾기 어려운 버그를 유발할 수 있습니다. 이러한 변수가 변경될 수 있는 방식을 방지하거나 제한하십시오.

foreach 루프에서, `foreachReassign` 속성으로 설정:
- `deny`: 루프 본문에서 루프 변수의 모든 재할당을 보고합니다. _이것이 기본값입니다._
- `allow`: 루프 변수를 검사하지 않습니다.
- `firstOnly`: 루프 본문의 첫 번째 문을 제외한 루프 변수의 모든 재할당을 보고합니다.
            _사용 전 값의 정규화나 정리가 허용되지만 변수의 다른 변경은 허용되지 않는 경우에 유용합니다._

for 루프에서, `forReassign` 속성으로 설정:
- `deny`: 루프 본문에서 제어 변수의 모든 재할당을 보고합니다. _이것이 기본값입니다._
- `allow`: 제어 변수를 검사하지 않습니다.
- `skip`: 조건부 증감(`++`, `--`, `+=`, `-=`)을 제외한 제어 변수의 모든 재할당을 보고합니다.
            _제어 변수의 우발적 재할당이나 무조건적 증가를 방지합니다._
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public class Foo {
  private void foo() {
    for (String s : listOfStrings()) {
      s = s.trim(); // OK, when foreachReassign is "firstOnly" or "allow"
      doSomethingWith(s);

      s = s.toUpper(); // OK, when foreachReassign is "allow"
      doSomethingElseWith(s);
    }

    for (int i=0; i < 10; i++) {
      if (check(i)) {
        i++; // OK, when forReassign is "skip" or "allow"
      }

      i = 5;  // OK, when forReassign is "allow"

      doSomethingWith(i);
    }
  }
}
]]>
        </example>
    </rule>

    <rule name="AvoidReassigningParameters"
          language="java"
          since="1.0"
          message="''{0}''과(와) 같은 매개변수의 재할당을 피하십시오"
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.AvoidReassigningParametersRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#avoidreassigningparameters">
        <description>
메서드나 생성자의 입력 매개변수에 값을 재할당하는 것은 권장되지 않습니다. 이는 코드를 이해하기
더 어렵게 만들 수 있기 때문입니다. 코드는 대개 매개변수 값이 변경되지 않는다는 가정 하에 읽히며,
할당은 최소 놀람 원칙을 위반합니다. 이는 특히 매개변수가 메서드의 javadoc 등에 문서화되어 있고
새 내용이 원래 문서화된 내용과 다른 경우에 문제가 됩니다.

대신 임시 지역 변수를 사용하십시오. 이를 통해 새 이름을 할당할 수 있어 코드를 더 잘 이해할 수 있습니다.

이 규칙은 메서드와 생성자를 모두 고려합니다. 형식 매개변수에 대한 할당이 여러 개인 경우,
첫 번째 할당만 보고됩니다.
        </description>
        <priority>2</priority>
        <example>
<![CDATA[
public class Hello {
  private void greet(String name) {
    name = name.trim();
    System.out.println("Hello " + name);

    // preferred
    String trimmedName = name.trim();
    System.out.println("Hello " + trimmedName);
  }
}
]]>
        </example>
    </rule>

    <rule name="AvoidStringBufferField"
          language="java"
          since="4.2"
          message="StringBuffer는 상당히 커질 수 있으므로 소유 클래스의 수명이 긴 경우 메모리 누수의 원인이 될 수 있습니다."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#avoidstringbufferfield">
        <description>
StringBuffer/StringBuilder는 상당히 커질 수 있으므로 수명이 긴 객체 내에 보관될 경우
메모리 누수의 원인이 될 수 있습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//FieldDeclaration/ClassType[pmd-java:typeIs('java.lang.StringBuffer') or pmd-java:typeIs('java.lang.StringBuilder')]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Foo {
    private StringBuffer buffer;    // potential memory leak as an instance variable;
}
]]>
        </example>
    </rule>

    <rule name="AvoidUsingHardCodedIP"
          language="java"
          since="4.1"
          message="IP 주소 ''{0}''을(를) 하드코딩하지 마십시오"
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.AvoidUsingHardCodedIPRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#avoidusinghardcodedip">
        <description>
하드코딩된 IP 주소가 있는 애플리케이션은 경우에 따라 배포가 불가능해질 수 있습니다.
IP 주소를 외부화하는 것이 바람직합니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public class Foo {
    private String ip = "127.0.0.1";     // not recommended
}
]]>
        </example>
    </rule>

    <rule name="CheckResultSet"
          language="java"
          since="4.1"
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.CheckResultSetRule"
          message="ResultSet의 탐색 메서드(next, previous, first, last)의 반환값을 항상 확인하십시오."
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#checkresultset">
        <description>
ResultSet의 탐색 메서드(next, previous, first, last)의 반환값을 항상 확인하십시오.
반환값이 'false'인 경우 적절하게 처리해야 합니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
Statement stat = conn.createStatement();
ResultSet rst = stat.executeQuery("SELECT name FROM person");
rst.next();     // what if it returns false? bad form
String firstName = rst.getString(1);

Statement stat = conn.createStatement();
ResultSet rst = stat.executeQuery("SELECT name FROM person");
if (rst.next()) {    // result is properly examined and used
    String firstName = rst.getString(1);
    } else  {
        // handle missing data
}
]]>
        </example>
    </rule>

    <rule name="ConstantsInInterface"
          language="java"
          since="5.5"
          message="인터페이스에서 상수를 사용하는 것은 나쁜 관행입니다."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#constantsininterface">
        <description>
인터페이스에서 상수를 사용하는 것은 나쁜 관행입니다. 인터페이스는 타입을 정의하며, 상수는 클래스나 열거형에 배치하는 것이 더 나은 구현 세부사항입니다. 상수가 열거 타입의 멤버로 가장 잘 볼 수 있다면 enum 타입으로 내보내야 합니다.
다른 시나리오에서는 유틸리티 클래스 사용을 고려하십시오. Effective Java의 '인터페이스는 타입 정의용으로만 사용하라'를 참조하십시오.
        </description>
        <priority>3</priority>
        <properties>
        <property name="ignoreIfHasMethods" type="Boolean" description="인터페이스가 메서드를 정의하는 경우 인터페이스의 상수를 무시할지 여부" value="true"/>
            <property name="xpath">
                <value>
<![CDATA[
//ClassDeclaration[@Interface = true()][$ignoreIfHasMethods= false() or not(ClassBody/MethodDeclaration)]/ClassBody/FieldDeclaration
 ]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public interface ConstantInterface {
    public static final int CONST1 = 1; // violation, no fields allowed in interface!
    static final int CONST2 = 1;        // violation, no fields allowed in interface!
    final int CONST3 = 1;               // violation, no fields allowed in interface!
    int CONST4 = 1;                     // violation, no fields allowed in interface!
}

// with ignoreIfHasMethods = false
public interface AnotherConstantInterface {
    public static final int CONST1 = 1; // violation, no fields allowed in interface!

    int anyMethod();
}

// with ignoreIfHasMethods = true
public interface YetAnotherConstantInterface {
    public static final int CONST1 = 1; // no violation

    int anyMethod();
}
 ]]>
        </example>
    </rule>

    <rule name="DefaultLabelNotLastInSwitchStmt" deprecated="true" ref="DefaultLabelNotLastInSwitch" />

    <rule name="DefaultLabelNotLastInSwitch"
          language="java"
          since="1.5"
          message="default 레이블은 switch 문이나 표현식에서 마지막 레이블이어야 합니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#defaultlabelnotlastinswitch">
        <description>
관례상 default 레이블은 switch 문이나 switch 표현식에서 마지막 레이블이어야 합니다.

참고: 이 규칙은 PMD 7.7.0에서 "DefaultLabelNotLastInSwitchStmt"에서 이름이 변경되었습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//SwitchLabel[@Default = true() and not(.. is ../../*[last()])]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Foo {
  void bar(int a) {
   switch (a) {
    case 1:  // do something
       break;
    default:  // the default case should be last, by convention
       break;
    case 2:
       break;
   }
  }
}
]]>
        </example>
    </rule>

    <rule name="DoubleBraceInitialization"
          language="java"
          since="6.16.0"
          message="이중 중괄호 초기화는 피해야 합니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#doublebraceinitialization">
        <description>
            이중 중괄호 초기화는 컬렉션 등을 간결하게 초기화하는 패턴입니다. 그러나 이는 암묵적으로
            새로운 .class 파일을 생성하며, 객체는 둘러싸는 객체에 대한 강한 참조를 보유합니다.
            이러한 이유로 비록 장황하더라도 객체를 정상적으로 초기화하는 것이 바람직합니다.

            이 규칙은 단일 초기화 블록만 있는 익명 클래스를 이중 중괄호 초기화의 인스턴스로 간주합니다.
            현재 초기화 블록에서 호출된 메서드가 익명 클래스 외부에서 접근 가능한지 여부를 판단할 방법이 없으며,
            그러한 합법적인 경우는 당분간 억제해야 합니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//ConstructorCall/AnonymousClassDeclaration/ClassBody[count(*)=1]/Initializer[@Static=false()]
]]>
                </value>
            </property>
        </properties>
        <example><![CDATA[
// this is double-brace initialization
return new ArrayList<String>(){{
    add("a");
    add("b");
    add("c");
}};

// the better way is to not create an anonymous class:
List<String> a = new ArrayList<>();
a.add("a");
a.add("b");
a.add("c");
return a;
]]>
        </example>
    </rule>

    <rule name="EnumComparison"
          language="java"
          since="7.19.0"
          message="열거형은 ==를 사용하여 비교해야 합니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#enumcomparison">
        <description>
열거형을 비교할 때 `equals()`는 피하고 `==`를 사용하는 것이 좋습니다.

`==` 사용의 장점:
* `equals()`와 동일한 의미
* 잠재적인 null 포인터 예외에 대한 문제가 적음
* 정적 타입 검사 지원: 호환되지 않는 두 열거형 타입을 비교하면 컴파일러가 알려줍니다.
  equals를 사용하면 런타임에서만 알 수 있거나 전혀 알 수 없습니다.

이 규칙은 SonarSource 규칙 [S4551](https://sonarsource.github.io/rspec/#/rspec/S4551)을 구현합니다.

참고로, 원시 타입과 열거형만 `==`를 사용하여 비교해야 합니다. 다른 객체를 비교하려면
`equals()`가 올바른 방법입니다. {%rule java/errorprone/CompareObjectsWithEquals %}
및 {%rule java/errorprone/UseEqualsToCompareStrings %}을 참조하십시오.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//MethodCall[pmd-java:matchesSig("_#equals(java.lang.Object)")]
  [*[pmd-java:typeIs("java.lang.Enum")] or
   ArgumentList[*[pmd-java:typeIs("java.lang.Enum")]]]
]]></value>
            </property>
        </properties>
        <example><![CDATA[
enum Color { RED, GREEN, BLUE }
class ColorTester {
  boolean isRed(Color color) {
    return color.equals(Color.RED); // violation
  }

  boolean isGreen(Color color) {
    return color == Color.GREEN; // preferred
  }
}
]]></example>
    </rule>

    <rule name="ExhaustiveSwitchHasDefault"
          language="java"
          since="7.10.0"
          message="switch 블록은 default 케이스 없이도 모든 경우를 포괄합니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#exhaustiveswitchhasdefault">
        <description>
열거형이나 봉인된 클래스에 대해 switch를 사용할 때, 컴파일러는 모든 가능한 케이스가 처리되는지 확인합니다.
케이스가 누락되면 컴파일 오류가 발생합니다. 그러나 default 케이스가 추가되면 이 컴파일러 검사가
더 이상 수행되지 않아 런타임에서 버그를 발견하기 어려워집니다.

default 케이스를 사용하지 않으면 새로운 열거형 상수나 봉인된 클래스 계층에 새 하위 클래스가
추가될 때마다 컴파일 오류가 발생합니다. 런타임이 아닌 컴파일 타임에 이 문제를 발견할 수 있습니다.

참고: 수정 방법이 단순히 default 케이스를 제거하는 것만은 아닙니다. 구현해야 할 누락된 케이스가 있을 수 있습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
                    //(SwitchStatement | SwitchExpression)
                      [@Exhaustive = true()]
                      [@DefaultCase = true()]
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
class Foo {
    enum MyEnum { A, B };

    void doSomething(MyEnum e) {
        switch(e) {
            case A -> System.out.println("a");
            case B -> System.out.println("b");
            default -> System.out.println("unnecessary default");
        };
    }
}
]]>
        </example>
    </rule>

    <rule name="ForLoopCanBeForeach"
          language="java"
          since="6.0.0"
          message="이 'for' 루프는 'foreach' 루프로 대체할 수 있습니다"
          minimumLanguageVersion="1.5"
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.ForLoopCanBeForeachRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#forloopcanbeforeach">
        <description>
안전하게 foreach 구문으로 대체할 수 있는 루프를 보고합니다. 이 규칙은 리스트, 배열 및 반복자에 대한
루프를 고려합니다. 루프가 인덱스 변수를 리스트나 배열의 요소에 접근하는 데만 사용하고,
업데이트 문이 하나만 있으며, 리스트나 배열의 *모든* 요소를 왼쪽에서 오른쪽으로 순회하는 경우에만
안전하게 대체할 수 있습니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public class MyClass {
  void loop(List<String> l) {
    for (int i = 0; i < l.size(); i++) { // pre Java 1.5
      System.out.println(l.get(i));
    }

    for (String s : l) {        // post Java 1.5
      System.out.println(s);
    }
  }
}
]]>
        </example>
    </rule>

    <rule name="ForLoopVariableCount"
          language="java"
          since="6.11.0"
          message="'for' 문에 제어 변수가 너무 많습니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#forloopvariablecount">
        <description>
'for' 루프에 제어 변수가 많으면 루프가 어떤 값 범위를 순회하는지 파악하기 어려워집니다.
기본적으로 이 규칙은 변수가 하나만 있는 일반 'for' 루프를 허용합니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="maximumVariables" type="Integer"
                      description="일반 for 문의 제어 변수 수" min="0" max="100" value="1"/>
            <property name="xpath">
                <value>//ForInit/LocalVariableDeclaration[count(VariableDeclarator) > $maximumVariables]</value>
            </property>
        </properties>
        <example>
<![CDATA[
// this will be reported with the default setting of at most one control variable in a for loop
for (int i = 0, j = 0; i < 10; i++, j += 2) {
   foo();
]]>
        </example>
    </rule>

    <rule name="GuardLogStatement"
          language="java"
          since="5.1.0"
          message="로거 호출은 로그 레벨 가드로 감싸야 합니다."
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.GuardLogStatementRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#guardlogstatement">
        <description>
로그 레벨을 사용할 때마다 실제로 활성화되어 있는지 확인하거나, 그렇지 않으면 관련 문자열 생성 및
조작과 메서드 호출을 건너뛰어야 합니다.

로그 레벨 확인의 대안으로 매개변수 치환, 포맷터 또는 람다를 사용한 지연 로깅이 있습니다.
사용 가능한 대안은 실제 로깅 프레임워크에 따라 다릅니다.
        </description>
        <priority>2</priority>
        <example>
<![CDATA[
// Add this for performance - avoid manipulating strings if the logger may drop it
if (log.isDebugEnabled()) {
    log.debug("log something" + param1 + " and " + param2 + "concat strings");
}

// Avoid the guarding if statement with substituting parameters
log.debug("log something {} and {}", param1, param2);

// Avoid the guarding if statement with formatters
log.debug("log something %s and %s", param1, param2);

// This is still an issue, method invocations may be expensive / have side-effects
log.debug("log something expensive: {}", calculateExpensiveLoggingText());

// Avoid the guarding if statement with lazy logging and lambdas
log.debug("log something expensive: {}", () -> calculateExpensiveLoggingText());

// … alternatively use method references
log.debug("log something expensive: {}", this::calculateExpensiveLoggingText);
]]>
        </example>
    </rule>

    <rule name="ImplicitFunctionalInterface"
          language="java"
          since="7.12.0"
          message="의도를 명확히 하기 위해 이 인터페이스에 @FunctionalInterface 또는 @SuppressWarnings(&quot;PMD.ImplicitFunctionalInterface&quot;)를 추가하십시오."
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.ImplicitFunctionalInterfaceRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#implicitfunctionalinterface">
        <description>
            `@FunctionalInterface` 어노테이션으로 명시적으로 선언되지 않은 함수형 인터페이스를 보고합니다.
            인터페이스가 우연히 함수형 인터페이스인 경우, 이를 명확히 하기 위해
            `@SuppressWarnings(&quot;PMD.ImplicitFunctionalInterface&quot;)` 어노테이션을 추가해야 합니다.
        </description>
        <priority>2</priority>
        <example>
            <![CDATA[
            // The intent on this declaration is unclear, and the rule will report it.
            public interface MyInterface {
                void doSomething();
            }

            // This is clearly intended as a functional interface.
            @FunctionalInterface
            public interface MyInterface {
                void doSomething();
            }

            // This is clearly NOT intended as a functional interface.
            @SuppressWarnings("PMD.ImplicitFunctionalInterface")
            public interface MyInterface {
                void doSomething();
            }
            ]]>
        </example>
    </rule>


    <rule name="JUnit4SuitesShouldUseSuiteAnnotation"
          language="java"
          since="4.0"
          message="JUnit 4에서는 suite 메서드가 아닌 어노테이션으로 테스트 스위트를 나타냅니다."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#junit4suitesshouldusesuiteannotation">
        <description>
JUnit 3에서는 suite() 메서드로 테스트 스위트를 나타냅니다. JUnit 4에서는
@RunWith(Suite.class) 어노테이션으로 스위트를 나타냅니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//MethodDeclaration[@Name='suite' and ClassType[pmd-java:typeIs('junit.framework.Test')]]
                   [not(.//ReturnStatement/*[pmd-java:typeIs('junit.framework.JUnit4TestAdapter')])]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class BadExample extends TestCase{

    public static Test suite(){
        return new Suite();
    }
}

@RunWith(Suite.class)
@SuiteClasses( { TestOne.class, TestTwo.class })
public class GoodTest {
}
]]>
        </example>
    </rule>

    <rule name="JUnit4TestShouldUseAfterAnnotation" deprecated="true" ref="UnitTestShouldUseAfterAnnotation" />

    <rule name="JUnit4TestShouldUseBeforeAnnotation" deprecated="true" ref="UnitTestShouldUseBeforeAnnotation"/>

    <rule name="JUnit4TestShouldUseTestAnnotation" deprecated="true" ref="UnitTestShouldUseTestAnnotation" />

    <rule name="JUnit5TestShouldBePackagePrivate"
          language="java"
          since="6.35.0"
          message="JUnit 5 테스트는 패키지-private이어야 합니다."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#junit5testshouldbepackageprivate">
        <description><![CDATA[
패키지-private가 아닌 JUnit 5 테스트 클래스와 메서드를 보고합니다.
엔진에 의해 실행되려면 public 가시성이 필요했던 JUnit 4 테스트와 달리,
JUnit 5 테스트는 패키지-private이어도 실행할 수 있습니다. 이렇게 표시하는 것은
가시성을 제한하는 좋은 관행입니다.

테스트 메서드는 `@Test`, `@RepeatedTest`, `@TestFactory`, `@TestTemplate` 또는
`@ParameterizedTest`를 사용하는 것으로 식별됩니다.
            ]]></description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//ClassDeclaration[
    (: a Junit 5 test class, ie, it has methods with the annotation :)
    @Interface = false() and
    ClassBody/MethodDeclaration
    [ModifierList/Annotation[
               pmd-java:typeIs('org.junit.jupiter.api.Test')
            or pmd-java:typeIs('org.junit.jupiter.api.RepeatedTest')
            or pmd-java:typeIs('org.junit.jupiter.api.TestFactory')
            or pmd-java:typeIs('org.junit.jupiter.api.TestTemplate')
            or pmd-java:typeIs('org.junit.jupiter.params.ParameterizedTest')
    ]]
]/(
       self::*[@Abstract = false() and @Visibility = ("public", "protected")]
|      ClassBody/MethodDeclaration
       [@Visibility = ("public", "protected")]
       [ModifierList/Annotation[
               pmd-java:typeIs('org.junit.jupiter.api.Test')
            or pmd-java:typeIs('org.junit.jupiter.api.RepeatedTest')
            or pmd-java:typeIs('org.junit.jupiter.api.TestFactory')
            or pmd-java:typeIs('org.junit.jupiter.api.TestTemplate')
            or pmd-java:typeIs('org.junit.jupiter.params.ParameterizedTest')
       ]]
)
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
class MyTest { // not public, that's fine
    @Test
    public void testBad() { } // should not have a public modifier

    @Test
    protected void testAlsoBad() { } // should not have a protected modifier

    @Test
    private void testNoRun() { } // should not have a private modifier

    @Test
    void testGood() { } // package private as expected
}
]]>
        </example>
    </rule>

    <rule name="JUnitAssertionsShouldIncludeMessage" deprecated="true" ref="UnitTestAssertionsShouldIncludeMessage" />

    <rule name="JUnitTestContainsTooManyAsserts" deprecated="true" ref="UnitTestContainsTooManyAsserts"/>

    <rule name="JUnitTestsShouldIncludeAssert" deprecated="true" ref="UnitTestShouldIncludeAssert" />

    <rule name="JUnitUseExpected"
          language="java"
          since="4.0"
          message="JUnit4에서는 예외를 던져야 하는 테스트를 나타내기 위해 @Test(expected) 어노테이션을 사용하십시오"
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.JUnitUseExpectedRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#junituseexpected">
        <description>
JUnit4에서는 예외를 던져야 하는 테스트를 나타내기 위해 @Test(expected) 어노테이션을 사용하십시오.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public class MyTest {
    @Test
    public void testBad() {
        try {
            doSomething();
            fail("should have thrown an exception");
        } catch (Exception e) {
        }
    }

    @Test(expected=Exception.class)
    public void testGood() {
        doSomething();
    }
}
]]>
        </example>
    </rule>

    <rule name="LabeledStatement"
          language="java"
          since="7.18.0"
          message="''{0}''과(와) 같은 레이블이 지정된 문의 사용을 피하십시오."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#labeledstatement">
        <description>
이 규칙은 레이블이 지정된 문의 사용을 감지합니다. 기본적으로 레이블이 있는 루프는 허용하여
레이블과 함께 `break` / `continue`를 사용할 수 있습니다. 이는 `allowLoops` 속성을 통해
모든 레이블을 감지하도록 변경할 수 있습니다.

레이블은 제어 흐름을 이해하기 어렵게 만들며 피해야 합니다. goto 문과 혼동될 수 있으며
코드를 읽고 유지보수하기 어렵게 만듭니다.

내부 루프에서 빠져나와야 하는 경우, 여러 루프를 함수로 리팩토링하는 것을 고려하십시오.
그러면 break를 return으로 대체할 수 있습니다.

이 규칙은 SonarSource 규칙 [S1119](https://sonarsource.github.io/rspec/#/rspec/S1119)를 구현합니다.

사용되지 않는 레이블을 감지하려면 {% rule UnusedLabel %} 규칙을 사용하십시오.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
if ($allowLoops) then
    //LabeledStatement[not(DoStatement|WhileStatement|ForStatement|ForeachStatement)][let $label := @Label return
          (.//BreakStatement | .//ContinueStatement)[@Label = $label]
    ]
else
    //LabeledStatement[let $label := @Label return
          (.//BreakStatement | .//ContinueStatement)[@Label = $label]
    ]
]]>
                </value>
            </property>
            <property name="allowLoops" type="Boolean"
                      description="루프 문(do, while, for) 앞의 레이블을 허용할지 여부"
                      value="true" />
        </properties>
        <example>
<![CDATA[
class Scratch {
    public static void main(String[] args) {
        int x = 1;
        lbl1: while (true) {          // violation: labeled statement on loop (when property allowLoops=false)
            lbl2: if (x == 3) {       // violation: labeled statement
                x++;
                break lbl2;
            }
            lbl3: if (x == 4) {
                break lbl1;
            }
            System.out.println(x);
            x++;
        }
    }
}
]]>
        </example>
        <example>
            <![CDATA[
// Bad
outer:
for (int i = 0; i < 10; i++) {
    for (int j = 0; j < 10; j++) {
        break outer; // violation - labeled break (when allowLoops=false)
        continue outer; // violation - labeled continue (when allowLoops=false)
    }
}
]]>
        </example>
    </rule>

    <rule name="LiteralsFirstInComparisons"
          language="java"
          since="6.24.0"
          message="문자열 비교에서 리터럴을 먼저 배치하십시오"
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.LiteralsFirstInComparisonsRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#literalsfirstincomparisons">
        <description>
            모든 문자열 비교에서 리터럴을 먼저 배치하십시오. 두 번째 인수가 null이면 NullPointerException을
            피할 수 있으며, 단순히 false를 반환합니다. compareTo 및 compareToIgnoreCase에서
            리터럴 위치를 바꾸면 결과가 변경될 수 있으니 예제를 참조하십시오.

            컴파일 타임 상수 문자열은 리터럴과 동일하게 취급됩니다. 이는 클래스 파일에 인라인되어
            반드시 null이 아니므로 런타임에 NPE를 발생시킬 수 없기 때문입니다.
        </description>
        <priority>3</priority>
        <example>
            <![CDATA[
class Foo {
    boolean bar(String x) {
        return x.equals("2"); // should be "2".equals(x)
    }
    boolean bar(String x) {
        return x.equalsIgnoreCase("2"); // should be "2".equalsIgnoreCase(x)
    }
    boolean bar(String x) {
        return (x.compareTo("bar") > 0); // should be: "bar".compareTo(x) < 0
    }
    boolean bar(String x) {
        return (x.compareToIgnoreCase("bar") > 0); // should be: "bar".compareToIgnoreCase(x) < 0
    }
    boolean bar(String x) {
        return x.contentEquals("bar"); // should be "bar".contentEquals(x)
    }

    static final String CONSTANT = "const";
    {
        CONSTANT.equals("literal"); // not reported, this is effectively the same as writing "const".equals("foo")
    }
}
]]>
        </example>
    </rule>

    <rule name="LooseCoupling"
          language="java"
          since="0.7"
          message="''{0}''과(와) 같은 구현 타입 사용을 피하고 대신 인터페이스를 사용하십시오"
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.LooseCouplingRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#loosecoupling">
        <description>
구현 타입(예: `HashSet`)에 대한 과도한 결합은 요구사항이 변경될 때 대체 구현을 사용하는 능력을
제한합니다. 가능한 경우, 보다 일반적인 타입(예: `Set`)을 사용하여 변수와 매개변수를 선언하십시오.

이 규칙은 구체적인 컬렉션 타입의 사용을 보고합니다. 인터페이스와 동일하게 취급해야 하는
사용자 정의 타입은 `allowedTypes` 속성으로 구성할 수 있습니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
import java.util.ArrayList;
import java.util.HashSet;

public class Bar {
    // sub-optimal approach
    private ArrayList<SomeType> list = new ArrayList<>();

    public HashSet<SomeType> getFoo() {
        return new HashSet<SomeType>();
    }

    // preferred approach
    private List<SomeType> list = new ArrayList<>();

    public Set<SomeType> getFoo() {
        return new HashSet<SomeType>();
    }
}
]]>
        </example>
    </rule>

    <rule name="MethodReturnsInternalArray"
          language="java"
          since="2.2"
          message="''{0}''을(를) 반환하면 내부 배열이 노출될 수 있습니다."
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.MethodReturnsInternalArrayRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#methodreturnsinternalarray">
        <description>
내부 배열을 호출자에게 노출하면 객체 캡슐화를 위반합니다. 요소를 소유하지 않는 외부에서
제거하거나 교체할 수 있기 때문입니다. 배열의 복사본을 반환하는 것이 더 안전합니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public class SecureSystem {
    UserData [] ud;
    public UserData [] getUserData() {
        // Don't return directly the internal array, return a copy
        return ud;
    }
}
]]>
        </example>
    </rule>


    <rule name="MissingOverride"
          language="java"
          since="6.2.0"
          minimumLanguageVersion="1.5"
          message="메서드 ''{0}''에 @Override 어노테이션이 누락되었습니다."
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.MissingOverrideRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#missingoverride">
        <description>
            오버라이드된 메서드에 @Override를 추가하면 컴파일 타임에 해당 메서드가 실제로 오버라이드하는지
            확인할 수 있어 리팩토링에 도움이 되고 의도를 명확히 합니다.
        </description>
        <priority>3</priority>
        <example>
            <![CDATA[
            public class Foo implements Runnable {
                // This method is overridden, and should have an @Override annotation
                public void run() {

                }
            }
            ]]>
        </example>
    </rule>

    <rule name="NonExhaustiveSwitch"
          language="java"
          since="1.0"
          message="switch 문이나 표현식은 모든 경우를 포괄해야 합니다. default 케이스(또는 누락된 열거형 분기)를 추가하십시오"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#nonexhaustiveswitch">
        <description>
            switch 문은 제어 흐름을 따라가기 쉽도록 모든 경우를 포괄해야 합니다.
            이는 `default` 케이스를 추가하거나, switch가 열거형 타입인 경우 각 열거형 상수에 대한
            switch 분기를 보장하여 달성할 수 있습니다.

            패턴 매칭을 사용하는 Switch 문은 컴파일러가 이미 모든 케이스가 처리되는지 확인하므로
            이 규칙에서 고려하지 않습니다. Switch 표현식도 마찬가지로 이 규칙에서 고려하지 않습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                //SwitchStatement
                    (: exclude empty switches :)
                    [count(*) > 1]
                    [@DefaultCase = false()]
                    [@ExhaustiveEnumSwitch = false()]
                    (: exclude pattern tests - for these, the compiler will ensure exhaustiveness :)
                    [not(*/SwitchLabel[@PatternLabel = true()])]
            ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
class Foo {{
    int x = 2;
    switch (x) {
      case 1: int j = 6;
      case 2: int j = 8;
      // missing default: here
    }
}}
]]>
        </example>
    </rule>

    <rule name="OneDeclarationPerLine"
          language="java"
          since="5.0"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          message="각 선언에 한 줄을 사용하면 코드 가독성이 향상됩니다."
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#onedeclarationperline">
        <description>
Java에서는 같은 타입의 여러 변수 선언을 한 줄에 할 수 있습니다.
그러나 이는 상당히 지저분한 코드를 초래할 수 있습니다. 이 규칙은 같은 줄에 여러 선언이 있는지 검사합니다.
        </description>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//LocalVariableDeclaration
   [not(parent::ForInit)]
   [count(VariableDeclarator) > 1]
   [$strictMode or count(distinct-values(VariableDeclarator/@BeginLine)) != count(VariableDeclarator)]
|
//FieldDeclaration
   [count(VariableDeclarator) > 1]
   [$strictMode or count(distinct-values(VariableDeclarator/@BeginLine)) != count(VariableDeclarator)]
]]>
                </value>
            </property>
            <property name="strictMode" type="Boolean" value="false"
                      description="true이면 선언이 별도의 줄에 있더라도 결합된 선언을 표시합니다."/>
        </properties>
        <example>
<![CDATA[
String name;            // separate declarations
String lastname;

String name, lastname;  // combined declaration, a violation

String name,
       lastname;        // combined declaration on multiple lines, no violation by default.
                        // Set property strictMode to true to mark this as violation.
]]>
        </example>
    </rule>

    <rule name="PreserveStackTrace"
          language="java"
          since="3.7"
          message="던져진 예외가 모든 코드 경로에서 예외 ''{0}''의 스택 트레이스를 보존하지 않습니다"
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.PreserveStackTraceRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#preservestacktrace">
        <description>
catch 블록 내에서 던져지지만 해당 catch 블록이 선언한 예외 매개변수를 참조하지 않는 예외를 보고합니다.
원래 예외의 스택 트레이스가 손실되어 던져진 예외의 정보가 줄어들 수 있습니다.

스택 트레이스를 보존하려면 원래 예외를 `Throwable#initCause`를 사용하여 새 예외의 원인으로 사용하거나,
생성자 인수로 새 예외에 전달할 수 있습니다. `Throwable#addSuppressed`를 사용하여 보존할 수도 있습니다.
이 규칙은 실제로 원래 예외를 인수로 받는 모든 메서드나 생성자가 원래 스택 트레이스를 보존한다고 가정합니다.

이 규칙은 `InvocationTargetException`과 `PrivilegedActionException`이 원인 예외로 대체되는 것을 허용합니다.
폐기된 스택 트레이스 부분은 이러한 경우 JDK 내부 코드뿐이므로 그다지 유용하지 않습니다.
또한 이름이 `ignored`로 시작하는 예외도 무시합니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public class Foo {
    void good() {
        try{
            Integer.parseInt("a");
        } catch (Exception e) {
            throw new Exception(e); // Ok, this initializes the cause of the new exception
        }
        try {
            Integer.parseInt("a");
        } catch (Exception e) {
            throw (IllegalStateException)new IllegalStateException().initCause(e); // second possibility to create exception chain.
        }
    }
    void wrong() {
        try{
            Integer.parseInt("a");
        } catch (Exception e) {
            // Violation: this only preserves the message and not the stack trace
            throw new Exception(e.getMessage());
        }
    }
}
]]>
        </example>
    </rule>

    <rule name="PrimitiveWrapperInstantiation"
          language="java"
          since="6.37.0"
          message="`new {0}(...)`을 사용하지 말고 `{0}.valueOf(...)`를 사용하십시오"
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.PrimitiveWrapperInstantiationRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#primitivewrapperinstantiation">
        <description>
            원시 래퍼 생성자의 사용을 보고합니다. Java 9부터 더 이상 사용되지 않으며 사용하지 말아야 합니다.
            Java 9 이전에도 해당하는 정적 `valueOf` 팩토리 메서드(Java 1.5부터 컴파일러에 의해
            자동으로 삽입될 수 있음)로 대체할 수 있습니다.
            이는 매번 새 인스턴스를 생성하는 대신 공통 인스턴스를 재사용할 수 있는 장점이 있습니다.

            `Boolean`의 경우, `Boolean.valueOf` 대신 명명된 상수 `Boolean.TRUE`와 `Boolean.FALSE`가
            선호됩니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
            public class Foo {
                private Integer ZERO = new Integer(0);      // violation
                private Integer ZERO1 = Integer.valueOf(0); // better
                private Integer ZERO1 = 0;                  // even better
            }
            ]]>
        </example>
    </rule>

    <rule name="RelianceOnDefaultCharset"
          language="java"
          since="7.17.0"
          message="기본 문자셋에 의존하지 말고 문자셋을 지정하십시오"
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.RelianceOnDefaultCharsetRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#relianceondefaultcharset">
        <description>
JVM의 기본 문자셋을 사용하는 API에 대해 문자셋을 반드시 지정하여 서로 다른 JVM, 프로그램 및
서버 간에 안정적인 인코딩 동작을 보장하십시오. 플랫폼의 기본 문자셋을 사용하면 코드의 이식성이
떨어지고 다른 시스템에서 실행할 때 예기치 않은 동작이 발생할 수 있습니다.

또한 Java 18부터 이러한 API의 기본 문자셋은 일관되게 UTF-8입니다
([JEP 400](https://openjdk.org/jeps/400) 참조). 이로 인해 다른 시스템에서의 예기치 않은 동작은
줄어들지만, 특히 UTF-8이 원하는 문자셋이 아닌 경우 문자셋을 명시적으로 지정하는 것이 여전히 권장됩니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public class Foo {
    void bad() throws IOException {
        new InputStreamReader(inputStream);  // violation
        new OutputStreamWriter(outputStream);  // violation
        URLEncoder.encode("test string");  // violation (deprecated)
        new PrintStream(outputStream);  // violation
        new PrintWriter("output.txt");  // violation
        new Scanner(inputStream);  // violation
        new Formatter();  // violation
        "test".getBytes();  // violation
        new ByteArrayOutputStream().toString();  // violation
        new FileReader("input.txt");  // violation
        new FileWriter("output.txt");  // violation
    }

    void good() throws IOException {
        new InputStreamReader(inputStream, StandardCharsets.UTF_8);  // ok
        new OutputStreamWriter(outputStream, StandardCharsets.UTF_8);  // ok
        URLEncoder.encode("test string", StandardCharsets.UTF_8);  // ok
        new PrintStream(outputStream, true, StandardCharsets.UTF_8);  // ok
        new PrintWriter("output.txt", StandardCharsets.UTF_8);  // ok
        new Scanner(inputStream, StandardCharsets.UTF_8);  // ok
        new Formatter(Locale.US);  // ok
        "test".getBytes(StandardCharsets.UTF_8);  // ok
        new ByteArrayOutputStream().toString(StandardCharsets.UTF_8);  // ok
        new FileReader("input.txt", StandardCharsets.UTF_8);  // ok
        new FileWriter("output.txt", StandardCharsets.UTF_8);  // ok
    }
}
]]>
        </example>
    </rule>

    <rule name="ReplaceEnumerationWithIterator"
          language="java"
          since="3.4"
          message="이 Enumeration을 더 새로운 java.util.Iterator로 대체하는 것을 고려하십시오"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#replaceenumerationwithiterator">
        <description>
Enumeration 사용을 더 새로운 java.util.Iterator로 대체하는 것을 고려하십시오.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//ImplementsList/ClassType[pmd-java:typeIsExactly('java.util.Enumeration')]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Foo implements Enumeration {
    private int x = 42;
    public boolean hasMoreElements() {
        return true;
    }
    public Object nextElement() {
        return String.valueOf(i++);
    }
}
]]>
        </example>
    </rule>

    <rule name="ReplaceHashtableWithMap"
          language="java"
          since="3.4"
          message="이 Hashtable을 더 새로운 java.util.Map으로 대체하는 것을 고려하십시오"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#replacehashtablewithmap">
        <description>
스레드 안전성이 필요하지 않은 경우 Hashtable 사용을 더 새로운 java.util.Map으로 대체하는 것을 고려하십시오.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                //ClassType[pmd-java:typeIsExactly('java.util.Hashtable')]
                ]]></value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Foo {
    void bar() {
        Hashtable h = new Hashtable();
    }
}
]]>
        </example>
    </rule>

    <rule name="ReplaceVectorWithList"
          language="java"
          since="3.4"
          message="이 Vector를 더 새로운 java.util.List로 대체하는 것을 고려하십시오"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#replacevectorwithlist">
        <description>
비용이 많이 드는 스레드 안전 작업이 필요하지 않은 경우 Vector 사용을 더 새로운 java.util.ArrayList로 대체하는 것을 고려하십시오.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                //ClassType[pmd-java:typeIsExactly('java.util.Vector')]
                ]]></value>
            </property>
        </properties>
        <example>
<![CDATA[
import java.util.Vector;
public class Foo {
    void bar() {
        Vector v = new Vector();
    }
}
]]>
        </example>
    </rule>

    <rule name="SimplifiableTestAssertion"
          language="java"
          since="6.37.0"
          message="어설션은 {0}을(를) 사용하여 단순화할 수 있습니다"
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.SimplifiableTestAssertionRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#simplifiabletestassertion">
        <description>
            보다 구체적인 어설션 메서드를 사용하여 단순화할 수 있는 테스트 어설션을 보고합니다.
            이를 통해 더 나은 오류 메시지를 제공하고 어설션의 가독성을 높일 수 있습니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
import org.junit.Test;
import static org.junit.Assert.*;

class SomeTestClass {
    Object a,b;
    @Test
    void testMethod() {
        assertTrue(a.equals(b)); // could be assertEquals(a, b);
        assertTrue(!a.equals(b)); // could be assertNotEquals(a, b);

        assertTrue(!something); // could be assertFalse(something);
        assertFalse(!something); // could be assertTrue(something);

        assertTrue(a == b); // could be assertSame(a, b);
        assertTrue(a != b); // could be assertNotSame(a, b);

        assertTrue(a == null); // could be assertNull(a);
        assertTrue(a != null); // could be assertNotNull(a);
    }
}
            ]]>
        </example>
    </rule>

    <rule name="SwitchStmtsShouldHaveDefault" deprecated="true" ref="NonExhaustiveSwitch"/>

    <rule name="SystemPrintln"
          language="java"
          since="2.1"
          message="System.out/err 사용"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#systemprintln">
        <description>
System.(out|err).print에 대한 참조는 일반적으로 디버깅 목적으로 사용되며 프로덕션 코드에서도
코드베이스에 남아 있을 수 있습니다. 로거를 사용하면 이 동작을 우선순위에 따라 활성화/비활성화할 수 있으며
표준 출력 로그가 막히는 것을 방지할 수 있습니다.
        </description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//MethodCall[ starts-with(@MethodName, 'print') ]
  /FieldAccess[ @Name = ('err', 'out') ]
  /TypeExpression[ pmd-java:typeIsExactly('java.lang.System') ]
]]>
                </value>
            </property>
        </properties>
        <example>
 <![CDATA[
class Foo{
    Logger log = Logger.getLogger(Foo.class.getName());
    public void testA () {
        System.out.println("Entering test");
        // Better use this
        log.fine("Entering test");
    }
}
]]>
        </example>
    </rule>

    <rule name="UnitTestAssertionsShouldIncludeMessage"
          language="java"
          since="1.04"
          message="단위 테스트 어설션에는 메시지가 포함되어야 합니다"
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.UnitTestAssertionsShouldIncludeMessageRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#unittestassertionsshouldincludemessage">
        <description>
단위 어설션에는 설명 메시지가 포함되어야 합니다. 즉, `assertEquals()`의 인수가 2개인 버전이 아닌
인수가 3개인 버전을 사용하십시오.

이 규칙은 JUnit(3, 4 및 5)과 TestNG를 사용하는 테스트를 지원합니다.

참고: 이 규칙은 PMD 7.7.0 이전에는 JUnitAssertionsShouldIncludeMessage였습니다.
        </description>
        <priority>3</priority>
        <example>
            <![CDATA[
public class Foo {
    @Test
    public void testSomething() {
        assertEquals("foo", "bar");
        // Use the form:
        // assertEquals("Foo does not equals bar", "foo", "bar");
        // instead
    }
}
]]>
        </example>
    </rule>

    <rule name="UnitTestContainsTooManyAsserts"
          language="java"
          since="5.0"
          message="단위 테스트에는 ${maximumAsserts}개 이상의 assert가 포함되어서는 안 됩니다."
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.UnitTestContainsTooManyAssertsRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#unittestcontainstoomanyasserts">
        <description>
            단위 테스트에는 너무 많은 어설션이 포함되어서는 안 됩니다. 많은 어설션은 복잡한 테스트를 나타내며,
            정확성을 검증하기 더 어렵습니다. 테스트 시나리오를 여러 개의 더 짧은 테스트 시나리오로
            분리하는 것을 고려하십시오. 이 규칙에서 사용되는 최대 어설션 수를 필요에 맞게 사용자 정의하십시오.

            이 규칙은 JUnit(3, 4 및 5)과 TestNG 테스트를 검사합니다.

            참고: 이 규칙은 PMD 7.7.0 이전에는 JUnitTestContainsTooManyAsserts였습니다.
        </description>
        <priority>3</priority>
        <example>
            <![CDATA[
public class MyTestCase {
    // Ok
    @Test
    public void testMyCaseWithOneAssert() {
        boolean myVar = false;
        assertFalse("should be false", myVar);
    }

    // Bad, too many asserts (assuming max=1)
    @Test
    public void testMyCaseWithMoreAsserts() {
        boolean myVar = false;
        assertFalse("myVar should be false", myVar);
        assertEquals("should equals false", false, myVar);
    }
}
]]>
        </example>
    </rule>

    <rule name="UnitTestShouldIncludeAssert"
          language="java"
          since="2.0"
          message="이 단위 테스트에는 assert() 또는 fail()이 포함되어야 합니다"
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.UnitTestShouldIncludeAssertRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#unittestshouldincludeassert">
        <description>
            단위 테스트에는 최소 하나의 어설션이 포함되어야 합니다. 이는 테스트를 더 견고하게 만들며,
            메시지와 함께 assert를 사용하면 개발자에게 테스트가 무엇을 하는지 더 명확한 아이디어를 제공합니다.

            이 규칙은 JUnit(3, 4 및 5)과 TestNG 테스트를 검사합니다.

            참고: 이 규칙은 PMD 7.7.0 이전에는 JUnitTestsShouldIncludeAssert였습니다.
        </description>
        <priority>3</priority>
        <example>
            <![CDATA[
public class Foo {
   @Test
   public void testSomething() {
      Bar b = findBar();
      // This is better than having a NullPointerException
      // assertNotNull("bar not found", b);
      b.work();
   }
}
]]>
        </example>
    </rule>

    <rule name="UnitTestShouldUseAfterAnnotation"
          language="java"
          since="4.0"
          message="이 메서드가 테스트 정리에 사용되는 경우 올바른 어노테이션을 적용하십시오"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#unittestshoulduseafterannotation">
        <description>
이 규칙은 정리 메서드로 적절하게 어노테이션이 지정되지 않은 `tearDown()`이라는 메서드를 감지합니다.
이는 주로 JUnit 3에서 업그레이드를 지원하기 위한 것으로, 정리 메서드의 이름이 `tearDown()`이어야 했습니다.
이 명명 규칙을 따르는 한, 더 새로운 JUnit 버전이나 TestNG에서도 누락을 감지하는 데 도움이 될 수 있습니다.

* JUnit 4는 각 테스트 실행 후 `@After`로 어노테이션된 메서드만 실행합니다.
* JUnit 5는 각 테스트 후 또는 클래스의 모든 테스트 후에 메서드를 실행하기 위해
  `@AfterEach`와 `@AfterAll` 어노테이션을 도입했습니다.
* TestNG는 각 테스트 후 또는 클래스의 테스트 후에 메서드를 실행하기 위해
  `@AfterMethod`와 `@AfterClass` 어노테이션을 제공합니다.

참고: 이 규칙은 PMD 7.7.0 이전에는 JUnit4TestShouldUseAfterAnnotation이었습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//MethodDeclaration[@Name='tearDown' and @Arity=0]
    [not(ModifierList/Annotation[
           pmd-java:typeIs('org.junit.After')
        or pmd-java:typeIs('org.junit.jupiter.api.AfterEach')
        or pmd-java:typeIs('org.junit.jupiter.api.AfterAll')
        or pmd-java:typeIs('org.testng.annotations.AfterClass')
        or pmd-java:typeIs('org.testng.annotations.AfterMethod')
    ])]
    (: Make sure this is a JUnit 4/5 or TestNG class :)
    [../MethodDeclaration[
            pmd-java:hasAnnotation('org.junit.Test')
         or pmd-java:hasAnnotation('org.junit.jupiter.api.Test')
         or pmd-java:hasAnnotation('org.testng.annotations.Test')
    ]]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class MyTest {
    public void tearDown() {
        bad();
    }
}
public class MyTest2 {
    @After public void tearDown() {
        good();
    }
}
]]>
        </example>
    </rule>

    <rule name="UnitTestShouldUseBeforeAnnotation"
          language="java"
          since="4.0"
          message="이 메서드가 테스트 설정에 사용되는 경우 올바른 어노테이션을 적용하십시오"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#unittestshouldusebeforeannotation">
        <description>
이 규칙은 설정 메서드로 적절하게 어노테이션이 지정되지 않은 `setUp()`이라는 메서드를 감지합니다.
이는 주로 JUnit 3에서 업그레이드를 지원하기 위한 것으로, 설정 메서드의 이름이 `setUp()`이어야 했습니다.
이 명명 규칙을 따르는 한, 더 새로운 JUnit 버전이나 TestNG에서도 누락을 감지하는 데 도움이 될 수 있습니다.

* JUnit 4는 모든 테스트 전에 `@Before`로 어노테이션된 메서드만 실행합니다.
* JUnit 5는 각 테스트 전 또는 클래스의 모든 테스트 전에 메서드를 실행하기 위해
  `@BeforeEach`와 `@BeforeAll` 어노테이션을 도입했습니다.
* TestNG는 각 테스트 전 또는 클래스의 테스트 전에 메서드를 실행하기 위해
  `@BeforeMethod`와 `@BeforeClass` 어노테이션을 제공합니다.

참고: 이 규칙은 PMD 7.7.0 이전에는 JUnit4TestShouldUseBeforeAnnotation이었습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//MethodDeclaration[@Name='setUp' and @Arity=0]
    [not(ModifierList/Annotation[
           pmd-java:typeIs('org.junit.Before')
        or pmd-java:typeIs('org.junit.jupiter.api.BeforeEach')
        or pmd-java:typeIs('org.junit.jupiter.api.BeforeAll')
        or pmd-java:typeIs('org.testng.annotations.BeforeMethod')
        or pmd-java:typeIs('org.testng.annotations.BeforeClass')
    ])]
    (: Make sure this is a JUnit 4/5 or TestNG class :)
    [../MethodDeclaration[
               pmd-java:hasAnnotation('org.junit.Test')
            or pmd-java:hasAnnotation('org.junit.jupiter.api.Test')
            or pmd-java:hasAnnotation('org.testng.annotations.Test')
    ]]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class MyTest {
    public void setUp() {
        bad();
    }
}
public class MyTest2 {
    @Before public void setUp() {
        good();
    }
}
]]>
        </example>
    </rule>

    <rule name="UnitTestShouldUseTestAnnotation"
          language="java"
          since="4.0"
          message="단위 테스트는 @Test 어노테이션을 사용해야 하며 그렇지 않으면 실행되지 않습니다. JUnit 5의 경우 테스트 메서드는 @RepeatedTest, @TestFactory, @TestTemplate 또는 @ParameterizedTest 어노테이션을 대신 사용할 수 있습니다."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#unittestshouldusetestannotation">
        <description>
            이 규칙은 적절하게 어노테이션이 지정되지 않아 실행되지 않을 "test"로 시작하는 모든 테스트 메서드를 감지합니다.

            JUnit 4에서는 `@Test` 어노테이션이 있는 메서드만 실행됩니다.
            JUnit 5에서는 테스트에 다음 어노테이션 중 하나를 사용해야 합니다: `@Test`, `@RepeatedTest`, `@TestFactory`, `@TestTemplate` 또는 `@ParameterizedTest`.
            TestNG에서는 `@Test` 어노테이션이 있는 메서드만 실행됩니다.

            참고: 이 규칙은 PMD 7.7.0 이전에는 JUnit4TestShouldUseTestAnnotation이었습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//ClassDeclaration[matches(@SimpleName, $testClassPattern) or pmd-java:typeIs('junit.framework.TestCase')]
    (: a junit 3 method :)
    /ClassBody/MethodDeclaration[
        @Visibility="public"
        and starts-with(@Name, 'test')
        and not(ModifierList/Annotation[
          pmd-java:typeIs('org.junit.Test')
          or pmd-java:typeIs('org.junit.jupiter.api.Test')
          or pmd-java:typeIs('org.junit.jupiter.api.RepeatedTest')
          or pmd-java:typeIs('org.junit.jupiter.api.TestFactory')
          or pmd-java:typeIs('org.junit.jupiter.api.TestTemplate')
          or pmd-java:typeIs('org.junit.jupiter.params.ParameterizedTest')
          or pmd-java:typeIs('org.testng.annotations.Test')
          ]
        )
    ]
]]>
                </value>
            </property>
            <property name="testClassPattern" type="Regex" description="테스트 클래스를 식별하는 데 사용되는 정규식 패턴" value="Test" />
        </properties>
        <example>
            <![CDATA[
public class MyTest {
    public void testBad() {
        doSomething();
    }

    @Test
    public void testGood() {
        doSomething();
    }
}
]]>
        </example>
    </rule>

    <rule name="UnnecessaryVarargsArrayCreation"
          language="java"
          since="7.1.0"
          message="가변 인수 메서드 호출에 대한 불필요한 명시적 배열 생성"
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.UnnecessaryVarargsArrayCreationRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#unnecessaryvarargsarraycreation">
        <description>
            가변 인수가 예상되는 곳에서 명시적 배열 생성을 보고합니다.
            예를 들어:
            ```java
            Arrays.asList(new String[] { "foo", "bar", });
            ```
            다음으로 대체할 수 있습니다:
            ```java
            Arrays.asList("foo", "bar");
            ```
        </description>
        <priority>3</priority>
        <example><![CDATA[
import java.util.Arrays;

class C {
    static {
        Arrays.asList(new String[]{"foo", "bar",});
        // should be
        Arrays.asList("foo", "bar");
    }
}
            ]]></example>
    </rule>

    <rule name="UnnecessaryWarningSuppression"
          language="java"
          since="7.14.0"
          message="사용되지 않는 억제 {0}."
          class="net.sourceforge.pmd.lang.rule.impl.UnnecessaryPmdSuppressionRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#unnecessarywarningsuppression">
        <description>
            이 규칙은 PMD 위반을 억제하지 않은 억제 주석과 어노테이션을 보고합니다.
            이 규칙의 위반은 억제할 수 없습니다.

            참고:
            - 이 규칙은 _현재 실행_ 중에 위반을 억제하지 않은 억제 주석/어노테이션을 보고합니다.
            즉, 이 규칙을 다른 규칙과 별도로 실행할 수 없으며, 경고를 생성할 수 있는 모든 규칙과
            함께 항상 실행해야 합니다. 일반 규칙셋에 이 규칙을 포함하면 대부분 문제가 되지 않습니다.
            - 현재 이 규칙은 PMD에 특정한 어노테이션만 보고합니다(예: `@SuppressWarnings("PMD")`).
            예를 들어 `@SuppressWarnings("all")`은 다른 도구가 억제해야 할 경고를 생성하는지
            알 수 없으므로 보고되지 않습니다. 향후 `@SuppressWarnings("unchecked")`나
            `"fallthrough"` 등 다른 일반적인 경우를 검사할 수 있을 것입니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
            public class Something {
                // Unless some rule triggered on the following line, this rule will report the comment:
                private void foo() {} // NOPMD
            }
            ]]>
        </example>
    </rule>

    <rule name="UnusedAssignment"
          language="java"
          since="6.26.0"
          message="이 변수에 할당된 값이 사용되지 않거나 항상 덮어쓰여집니다"
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.UnusedAssignmentRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#unusedassignment">
        <description>
            변수가 덮어쓰여지거나 범위를 벗어나기 전에 사용되지 않는 할당을 보고합니다.
            사용되지 않는 할당은 다음과 같은 경우입니다:
            1. 할당 후 변수가 읽히지 않는 경우, 또는
            2. 할당된 값이 다음 변수 읽기 전에 다른 할당에 의해 항상 덮어쓰여지는 경우.

            이 규칙은 `this`의 필드와 현재 클래스의 정적 필드에 대한 할당을 추적합니다.
            이는 타이밍에 민감한 동시성 코드에서 일부 오탐을 유발할 수 있으며, 이 규칙은 이를 감지할 수 없습니다.

            이 규칙은 표준 `@SuppressWarnings("unused")` 태그로 억제할 수 있습니다.

            이 규칙은 {% rule "UnusedLocalVariable" %}과 {% rule "UnusedFormalParameter" %}를 포함합니다.
            해당 위반은 이미 해당 규칙을 활성화한 경우를 대비하여 기본적으로 필터링되지만,
            `reportUnusedVariables` 속성으로 활성화할 수 있습니다. 이름이 `ignored` 또는 `unused`로
            시작하는 변수는 예외에 대한 표준 관행으로 필터링됩니다.

            제한사항:
            * 현재 이 규칙은 어떤 메서드 호출이 예외를 던지는지 또는 어떤 예외를 던지는지 알 수 없습니다.
            try 블록 본문에서 모든 메서드나 생성자 호출은 던지는 것으로 간주됩니다. 이는 미탐지를 유발할 수 있습니다.
            던지는 것으로 간주되는 유일한 다른 언어 구조는 `throw` 문이며, 특히
            `assert` 문이나 역참조 시 NullPointerException 등은 무시됩니다.
            * 이 규칙은 특수 `this(...)` 구문으로 호출되는 생성자 간의 할당을 해결할 수 없습니다.
            이는 미탐지를 유발할 수 있습니다.

            이 두 가지 제한사항은 PMD 7에서 부분적으로 완화될 수 있습니다.
        </description>
        <priority>3</priority>
        <example>
            <![CDATA[
            class A {
                // this field initializer is redundant,
                // it is always overwritten in the constructor
                int f = 1;

                A(int f) {
                    this.f = f;
                }
            }
        ]]>
        </example>
        <example><![CDATA[
class B {

    int method(int i, int j) {
        // this initializer is redundant,
        // it is overwritten in all branches of the `if`
        int k = 0;

        // Both the assignments to k are unused, because k is
        // not read after the if/else
        // This may hide a bug: the programmer probably wanted to return k
        if (i < j)
            k = i;
        else
            k = j;

        return j;
    }

}
        ]]>

        </example>
        <example><![CDATA[
class C {

    int method() {
        int i = 0;

        checkSomething(++i);
        checkSomething(++i);
        checkSomething(++i);
        checkSomething(++i);

        // That last increment is not reported unless
        // the property `checkUnusedPrefixIncrement` is
        // set to `true`
        // Technically it could be written (i+1), but it
        // is not very important
    }

}
        ]]>

        </example>
        <example><![CDATA[
class C {

    // variables that are truly unused (at most assigned to, but never accessed)
    // are only reported if property `reportUnusedVariables` is true

    void method(int param) { } // for example this method parameter

    // even then, you can suppress the violation with an annotation:

    void method(@SuppressWarning("unused") int param) { } // no violation, even if `reportUnusedVariables` is true

    // For catch parameters, or for resources which don't need to be used explicitly,
    // you can give a name that starts with "ignored" to ignore such warnings

    {
        try (Something ignored = Something.create()) {
            // even if ignored is unused, it won't be flagged
            // its purpose might be to side-effect in the create/close routines

        } catch (Exception e) { // this is unused and will cause a warning if `reportUnusedVariables` is true
            // you should choose a name that starts with "ignored"
            return;
        }
    }

}
        ]]>

        </example>
    </rule>

    <rule name="UnusedFormalParameter"
          language="java"
          since="0.8"
          message="''{1}''과(와) 같은 사용되지 않는 {0} 매개변수를 피하십시오."
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.UnusedFormalParameterRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#unusedformalparameter">
        <description>
메서드 본문에서 참조되지 않는 메서드와 생성자의 매개변수를 보고합니다.
이름이 `ignored` 또는 `unused`로 시작하는 매개변수는 필터링됩니다.

공개 메서드에서 사용되지 않는 형식 매개변수를 제거하면 코드베이스 전체에 파급 효과를 줄 수 있습니다.
따라서 기본적으로 이 규칙은 private 메서드만 고려합니다. 비-private 메서드를 포함하려면
`checkAll` 속성을 `true`로 설정하십시오. public 생성자에도 동일하게 적용됩니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public class Foo {
    private void bar(String howdy) {
        // howdy is not used
    }
}
]]>
        </example>
    </rule>

    <rule name="UnusedLabel"
          language="java"
          since="7.18.0"
          message="''{0}''과(와) 같은 사용되지 않는 레이블을 피하십시오."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#unusedlabel">
        <description>
사용되지 않는 레이블은 불필요하며 이 레이블이 무엇에 사용되는지 혼란을 줄 수 있습니다.
가독성을 향상시키려면 사용되지 않는 레이블을 단순히 제거해야 합니다.

이 규칙은 SonarSource 규칙 [S1065](https://sonarsource.github.io/rspec/#/rspec/S1065)를 구현합니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//LabeledStatement[let $label := @Label return
      not( (.//BreakStatement | .//ContinueStatement)[@Label = $label] )
]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
class Example {
    void main() {
        lbl1: {                     // violation: Label "lbl1" is not nused
            int x = 1;
            System.out.println(x);
        }
    }
}
]]>
        </example>
    </rule>

    <rule name="UnusedLocalVariable"
          language="java"
          since="0.1"
          message="''{0}''과(와) 같은 사용되지 않는 지역 변수를 피하십시오."
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.UnusedLocalVariableRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#unusedlocalvariable">
        <description>
지역 변수가 선언 및/또는 할당되었지만 사용되지 않는 경우를 감지합니다.
이름이 `ignored` 또는 `unused`로 시작하는 변수는 필터링됩니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public class Foo {
    public void doSomething() {
        int i = 5; // Unused
    }
}
]]>
        </example>
    </rule>

    <rule name="UnusedPrivateField"
          since="0.1"
          language="java"
          message="''{0}''과(와) 같은 사용되지 않는 private 필드를 피하십시오."
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.UnusedPrivateFieldRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#unusedprivatefield">
        <description>
private 필드가 선언 및/또는 값이 할당되었지만 사용되지 않는 경우를 감지합니다.

PMD 6.50.0부터 필드에 어노테이션이 있거나 둘러싸는 클래스에 어노테이션이 있는 경우 private 필드가 무시됩니다.
어노테이션은 종종 리플렉션이나 다른 수단으로 필드를 사용하는 프레임워크(의존성 주입, 모킹 또는
예를 들어 Lombok)를 활성화합니다. 이러한 사용은 정적 코드 분석으로 감지할 수 없습니다.
이전에는 이러한 프레임워크가 "ignoredAnnotations" 속성에 어노테이션을 나열하여 명시적으로 허용되었지만,
명시적으로 고려되지 않은 프레임워크에 대해 오탐이 발생하기 쉬웠습니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public class Something {
    private static int FOO = 2; // Unused
    private int i = 5; // Unused
    private int j = 6;
    public int addOne() {
        return j++;
    }
}
]]>
        </example>
    </rule>

    <rule name="UnusedPrivateMethod"
          language="java"
          since="0.7"
          message="''{0}''과(와) 같은 사용되지 않는 private 메서드를 피하십시오."
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.UnusedPrivateMethodRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#unusedprivatemethod">
        <description>
private 메서드가 선언되었지만 사용되지 않는 경우를 감지합니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public class Something {
    private void foo() {} // unused
}
]]>
        </example>
    </rule>

    <rule name="UseCollectionIsEmpty"
          language="java"
          since="3.9"
          message="size() == 0 (또는 size() != 0, size() &gt; 0, size() &lt; 1) 호출을 isEmpty() 호출로 대체하십시오"
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.UseCollectionIsEmptyRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#usecollectionisempty">
        <description>
java.util.Collection의 isEmpty() 메서드는 컬렉션에 요소가 있는지 확인하기 위해 제공됩니다.
size()의 값을 0과 비교하는 것은 isEmpty() 메서드만큼 의도를 잘 전달하지 못합니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public class Foo {
    void good() {
        List foo = getList();
        if (foo.isEmpty()) {
            // blah
        }
    }

    void bad() {
        List foo = getList();
        if (foo.size() == 0) {
            // blah
        }
    }
}
]]>
        </example>
    </rule>


    <rule name="UseEnumCollections"
          language="java"
          since="7.3.0"
          message="이 컬렉션은 {0}이(가) 될 수 있습니다"
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.UseEnumCollectionsRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#useenumcollections">
        <description>
            가능한 경우 키가 열거형 타입일 때 `HashSet`과 `HashMap` 대신 `EnumSet` 또는 `EnumMap`을
            사용하십시오. 특화된 열거형 컬렉션은 공간 및 시간 효율성이 더 높습니다.
            이 규칙은 키 타입이 열거형 타입인 해시 세트 또는 맵의 생성자 표현식을 보고합니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
            import java.util.EnumMap;
            import java.util.HashSet;

            enum Example {
                A, B, C;

                public static Set<Example> newSet() {
                    return new HashSet<>(); // Could be EnumSet.noneOf(Example.class)
                }

                public static <V> Map<Example, V> newMap() {
                    return new HashMap<>(); // Could be new EnumMap<>(Example.class)
                }
            }
            ]]>
        </example>
    </rule>

    <rule name="UseStandardCharsets"
          language="java"
          since="6.34.0"
          minimumLanguageVersion="1.7"
          message="StandardCharsets 상수를 사용하십시오"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#usestandardcharsets">
        <description>
Java 7부터 StandardCharsets는 UTF-8과 같은 일반적인 Charset 객체에 대한 상수를 제공합니다.
상수를 사용하면 오류 발생 가능성이 적으며, 내부 `Charset` 캐시를 스캔할 필요가 없으므로
`Charset.forName(...)`에 비해 약간의 성능 이점을 제공할 수 있습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//MethodCall[@MethodName = 'forName'][pmd-java:typeIs('java.nio.charset.Charset')]
    [
        ArgumentList/StringLiteral
            [@Image = ('"US-ASCII"', '"ISO-8859-1"', '"UTF-8"', '"UTF-16BE"', '"UTF-16LE"', '"UTF-16"')]
    ]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class UseStandardCharsets {
    public void run() {

        // looking up the charset dynamically
        try (OutputStreamWriter osw = new OutputStreamWriter(out, Charset.forName("UTF-8"))) {
            osw.write("test");
        }

        // best to use StandardCharsets
        try (OutputStreamWriter osw = new OutputStreamWriter(out, StandardCharsets.UTF_8)) {
            osw.write("test");
        }
    }
}
]]>
        </example>
    </rule>

    <rule name="UseTryWithResources"
          language="java"
          minimumLanguageVersion="1.7"
          since="6.12.0"
          message="리소스를 명시적으로 닫는 대신 try-with-resources 문 사용을 고려하십시오"
          class="net.sourceforge.pmd.lang.java.rule.bestpractices.UseTryWithResourcesRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#usetrywithresources">
        <description>
Java 7에서 try-with-resources 문이 도입되었습니다. 이 문은 각 리소스가 문의 끝에서 닫히도록 보장합니다.
finally 블록에서 리소스를 명시적으로 닫을 필요가 없습니다. 또한 예외가 더 잘 처리됩니다:
`try` 블록과 `finally` 블록 모두에서 예외가 발생한 경우, try 블록의 예외가 억제되었습니다.
`try`-with-resources 문을 사용하면 try 블록에서 던져진 예외가 보존됩니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public class TryWithResources {
    public void run() {
        InputStream in = null;
        try {
            in = openInputStream();
            int i = in.read();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (in != null) in.close();
            } catch (IOException ignored) {
                // ignored
            }
        }

        // better use try-with-resources
        try (InputStream in2 = openInputStream()) {
            int i = in2.read();
        }
    }
}
]]>
        </example>
    </rule>

    <rule name="UseVarargs"
          language="java"
          minimumLanguageVersion="1.5"
          since="5.0"
          message="마지막 매개변수로 배열을 받는 메서드나 생성자에 가변 인수 사용을 고려하십시오."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#usevarargs">
        <description>
Java 5에서 메서드와 생성자에 대한 가변 인수 매개변수 선언이 도입되었습니다. 이 문법적 편의는
이러한 메서드와 생성자의 사용자에게 유연성을 제공하여 배열 생성을 처리할 필요가 없게 합니다.

모든 메서드의 바이트 배열과 `public static void main(String[])` 메서드의 문자열 배열은 무시됩니다.
        </description>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//FormalParameters[not(parent::MethodDeclaration[@Overridden=true() or @MainMethod=true()])]
  /FormalParameter[position()=last()]
   [@Varargs=false()]
   [ArrayType[not(PrimitiveType[@Kind = "byte"] or ClassType[pmd-java:typeIs('java.lang.Byte')])]
    or VariableId[ArrayDimensions] and (PrimitiveType[not(@Kind="byte")] or ClassType[not(pmd-java:typeIs('java.lang.Byte'))])]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Foo {
    public void foo(String s, Object[] args) {
        // Do something here...
    }

    public void bar(String s, Object... args) {
        // Ahh, varargs tastes much better...
    }
}
]]>
        </example>
    </rule>

    <rule name="WhileLoopWithLiteralBoolean"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          language="java"
          since="6.13.0"
          message="루프를 단순화할 수 있습니다."
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#whileloopwithliteralboolean">
        <description>
`do {} while (true);`는 영원히 반복된다는 것을 알기 위해 문의 끝을 읽어야 하지만,
`while (true) {}`는 이해하기 더 쉽습니다.

`do {} while (false);`는 중복이며, 내부 변수 범위가 필요한 경우 블록 `{}`이면 충분합니다.

`while (false) {}`는 블록을 절대 실행하지 않으며 전체를 제거할 수 있습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
(: while loops with single boolean literal 'false', maybe parenthesized :)
//WhileStatement/BooleanLiteral[@True = false()]
|
(: do-while loops with single boolean literal ('false' or 'true'), maybe parenthesized :)
//DoStatement/BooleanLiteral
|
(: while loops with conditional or'ed boolean literals, maybe parenthesized :)
//WhileStatement[(InfixExpression[@Operator = ('|', '||')])
    (: no var access :)
    [count(VariableAccess) = 0]
    (: at least one false literal :)
    [count(BooleanLiteral[@True = false()]) >= 1]]
|
(: while loops with conditional and'ed boolean literals, maybe parenthesized :)
//WhileStatement[(InfixExpression[@Operator = ('&', '&&')])
    (: at least one false literal :)
    [count(BooleanLiteral[@True = false()]) >= 1]]
|
(: do-while loops with conditional or'ed boolean literals, maybe parenthesized :)
//DoStatement[(InfixExpression[@Operator = ('|', '||')])
    (: at least one true literal :)
    [count(BooleanLiteral[@True = true()]) >= 1
      (: or only boolean literal and no no var access :)
      or count(BooleanLiteral) >= 1
      and count(VariableAccess) = 0
    ]]
|
(: do-while loops with conditional and'ed boolean literals, maybe parenthesized :)
//DoStatement[(InfixExpression[@Operator = ('&', '&&')])
    (: at least one false literal :)
    [count(BooleanLiteral[@True = false()]) >= 1
      (: or only boolean literal and no no var access :)
      or count(BooleanLiteral) >= 1
      and count(VariableAccess) = 0
    ]]
                ]]></value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Example {
  {
    while (true) { } // allowed
    while (false) { } // disallowed
    do { } while (true); // disallowed
    do { } while (false); // disallowed
    do { } while (false | false); // disallowed
    do { } while (false || false); // disallowed
  }
}
]]>
        </example>
    </rule>

</ruleset>
