<?xml version="1.0" encoding="UTF-8"?>

<ruleset name="오류 발생 가능성"
    xmlns="http://pmd.sourceforge.net/ruleset/2.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://pmd.sourceforge.net/ruleset/2.0.0 https://pmd.sourceforge.io/ruleset_2_0_0.xsd">

    <description>
깨져 있거나, 매우 혼란스럽거나, 런타임 오류가 발생하기 쉬운 구문을 감지하는 규칙입니다.
    </description>

    <rule name="AssignmentInOperand"
          language="java"
          since="1.03"
          message="피연산자에서 {0}에 대한 할당을 피하세요"
          class="net.sourceforge.pmd.lang.java.rule.errorprone.AssignmentInOperandRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#assignmentinoperand">
        <description>
피연산자에서의 할당을 피하세요. 이는 코드를 더 복잡하고 읽기 어렵게 만들 수 있습니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public void bar() {
    int x = 2;
    if ((x = getX()) == 3) {
      System.out.println("3!");
    }
}
]]>
        </example>
    </rule>

    <rule name="AssignmentToNonFinalStatic"
          language="java"
          since="2.2"
          message="생성자에서 non-final static 필드 ''{0}''에 대한 안전하지 않은 할당 가능성이 있습니다."
          class="net.sourceforge.pmd.lang.java.rule.errorprone.AssignmentToNonFinalStaticRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#assignmenttononfinalstatic">
        <description>
static 필드의 안전하지 않은 사용 가능성을 식별합니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public class StaticField {
   static int x;
   public FinalFields(int y) {
    x = y; // unsafe
   }
}
]]>
        </example>
    </rule>

    <rule name="AvoidAccessibilityAlteration"
          language="java"
          since="4.1"
          message="setAccessible()를 사용하여 생성자, 메서드 또는 필드의 가시성을 변경하지 마세요"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#avoidaccessibilityalteration">
        <description>
`getDeclaredConstructors()`, `getDeclaredMethods()`, `getDeclaredFields()`와 같은 메서드는 private 생성자, 메서드, 필드도 반환합니다. 이들은 `setAccessible(true)`를 호출하여 접근 가능하게 만들 수 있습니다.
이는 캡슐화 원칙을 위반하여 정상적으로 보호되는 데이터에 대한 접근을 허용합니다.

이 규칙은 `setAccessible` 호출을 감지하고 접근성 변경 가능성을 찾습니다.
`setAccessible` 호출이 `PrivilegedAction` 내에 래핑되어 있으면, 접근 변경이 의도적인 것으로 간주되어 보고되지 않습니다.

Java 17에서는 `PrivilegedAction` 실행에 사용되는 보안 관리자가 더 이상 사용되지 않습니다: [JEP 411: Deprecate the Security Manager for Removal](https://openjdk.org/jeps/411).
향후 호환성을 위해, 의도적인 접근 변경은 일반적인 억제 방법(예: `@SuppressWarnings` 어노테이션 사용)으로 억제해야 합니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//MethodCall[
          pmd-java:matchesSig("java.lang.reflect.AccessibleObject#setAccessible(boolean)")
       or pmd-java:matchesSig("_#setAccessible(java.lang.reflect.AccessibleObject[],boolean)")
    ]
    [not(ArgumentList/BooleanLiteral[@True = false()])]
    (: exclude anonymous privileged action classes :)
    [not(ancestor::ConstructorCall[1][pmd-java:typeIs('java.security.PrivilegedAction')]/AnonymousClassDeclaration)]
    (: exclude inner privileged action classes :)
    [not(ancestor::ClassDeclaration[1][pmd-java:typeIs('java.security.PrivilegedAction')])]
    (: exclude privileged action lambdas :)
    [not(ancestor::LambdaExpression[pmd-java:typeIs('java.security.PrivilegedAction')])]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.security.AccessController;
import java.security.PrivilegedAction;

public class Violation {
    private void invalidSetAccessCalls() throws NoSuchMethodException, SecurityException {
        Constructor<?> constructor = this.getClass().getDeclaredConstructor(String.class);
        // call to forbidden setAccessible
        constructor.setAccessible(true);

        Method privateMethod = this.getClass().getDeclaredMethod("aPrivateMethod");
        // call to forbidden setAccessible
        privateMethod.setAccessible(true);

        // deliberate accessibility alteration
        String privateField = AccessController.doPrivileged(new PrivilegedAction<String>() {
            @Override
            public String run() {
                try {
                    Field field = Violation.class.getDeclaredField("aPrivateField");
                    field.setAccessible(true);
                    return (String) field.get(null);
                } catch (ReflectiveOperationException | SecurityException e) {
                    throw new RuntimeException(e);
                }
            }
        });
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidAssertAsIdentifier"
          language="java"
          maximumLanguageVersion="1.3"
          since="3.4"
          message="assert를 식별자로 사용하지 마세요. JDK 1.4에서 예약어가 되었습니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#avoidassertasidentifier">
        <description>
`assert`라는 용어를 사용하면 예약어이므로 최신 버전의 Java와 충돌합니다.

Java 1.4부터 `assert` 토큰은 예약어가 되었으며, 이를 식별자로 사용하면 Java 1.4 이후 버전에서 컴파일 오류가 발생합니다. 따라서 이 규칙은 Java 1.4 이전의 오래된 Java 코드에만 유용합니다. Java 업데이트 전에 문제가 되는 코드를 식별하는 데 사용할 수 있습니다.
        </description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>//VariableId[@Name='assert']</value>
            </property>
        </properties>
        <example>
<![CDATA[
public class A {
    public class Foo {
        String assert = "foo";
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidBranchingStatementAsLastInLoop"
          language="java"
          since="5.0"
          class="net.sourceforge.pmd.lang.java.rule.errorprone.AvoidBranchingStatementAsLastInLoopRule"
          message="루프의 마지막에 분기문을 사용하지 마세요."
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#avoidbranchingstatementaslastinloop">
        <description>
루프의 마지막 부분에 분기문을 사용하는 것은 버그일 수 있으며 혼란스럽습니다.
사용법이 버그가 아닌지 확인하거나 다른 접근 방식을 고려하세요.
        </description>
        <priority>2</priority>
        <example>
<![CDATA[
// unusual use of branching statement in a loop
for (int i = 0; i < 10; i++) {
    if (i*i <= 25) {
        continue;
    }
    break;
}

// this makes more sense...
for (int i = 0; i < 10; i++) {
    if (i*i > 25) {
        break;
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidCallingFinalize"
          language="java"
          since="3.0"
          message="finalize()를 명시적으로 호출하지 마세요"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#avoidcallingfinalize">
        <description>
Object.finalize() 메서드는 가비지 컬렉터가 객체에 대한 참조가 더 이상 없다고 판단할 때 호출합니다. 애플리케이션 로직에서 직접 호출해서는 안 됩니다.

Oracle은 JDK 9부터 Object.finalize()를 더 이상 사용되지 않음(deprecated)으로 선언했습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//MethodCall[pmd-java:matchesSig("java.lang.Object#finalize()")]
    (: it's ok inside finalize :)
    [not(SuperExpression and ancestor::*[self::MethodDeclaration or self::Initializer][1][@Name = 'finalize'][@Arity = 0][VoidType])]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
void foo() {
    Bar b = new Bar();
    b.finalize();
}
]]>
        </example>
    </rule>

    <rule name="AvoidCatchingGenericException"
          since="4.2.6"
          language="java"
          message="try-catch 블록에서 {0} 캐치를 피하세요"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#avoidcatchinggenericexception">
        <description>
try-catch 블록에서 일반적인 예외를 캐치하지 마세요. 지나치게 광범위한 예외 타입을 캐치하면 코드에서 실제로 무엇이 잘못될 수 있는지 이해하기 어렵고 실제 문제를 숨길 수 있습니다.

**이러한 예외를 캐치하지 말아야 하는 이유:**

* **Exception**: 모든 체크 예외의 기본 클래스입니다. 이를 캐치하면 모든 가능한 체크 예외를 동일하게 처리하게 되는데, 이는 거의 적절하지 않으며 오류 처리를 덜 정밀하게 만듭니다.

* **RuntimeException**: 프로그래밍 오류(논리 버그 등)를 나타냅니다. 일반적으로 캐치하여 처리하기보다는 코드에서 수정해야 합니다. 이를 캐치하면 개발 중에 해결해야 할 버그를 숨길 수 있습니다.

* **NullPointerException**: 일반적으로 프로그래밍 오류(null 참조 접근)를 나타냅니다. 이를 캐치하기보다는 null 검사나 방어적 프로그래밍을 통해 null 포인터 역참조를 피하도록 코드를 작성해야 합니다.

* **Throwable**: 모든 오류와 예외의 상위 클래스입니다. 이를 캐치하면 복구 가능한 예외와 심각한 오류(OutOfMemoryError 등)를 동일하게 처리하게 되어 위험합니다.

* **Error**: 애플리케이션이 처리를 시도해서는 안 되는 심각한 문제(OutOfMemoryError, StackOverflowError 등)를 나타냅니다. Error를 캐치하면 복구 불가능한 상황에서 JVM이 적절하게 종료되는 것을 방해할 수 있습니다.

**더 나은 접근 방식:**
- 의미 있게 처리할 수 있는 특정 예외 타입을 캐치하세요
- 다른 처리가 필요한 예외 타입에 대해 여러 catch 블록을 사용하세요
- 예외를 캐치하기보다는 방어적 프로그래밍 기법을 사용하여 예외를 방지하는 것을 고려하세요
        </description>
        <priority>3</priority>
        <properties>
            <property
                    name="typesThatShouldNotBeCaught"
                    type="List[String]"
                    description="catch 절에서 사용될 경우 위반을 트리거하는 정규화된 타입 이름 목록입니다."
            >
                <value>
                    java.lang.NullPointerException,
                    java.lang.Exception,
                    java.lang.RuntimeException,
                    java.lang.Throwable,
                    java.lang.Error
                </value>
            </property>
            <property name="xpath">
                <value>
                    <![CDATA[
//CatchParameter//ClassType[
    some $type in $typesThatShouldNotBeCaught
    satisfies pmd-java:typeIsExactly($type)]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
public class PrimitiveType {
    public void downCastPrimitiveType(int i) {
        try {
            System.out.println(" i [" + i + "]");
        } catch(NullPointerException e) {
            e.printStackTrace();
        } catch(RuntimeException e) {
            e.printStackTrace();
        } catch(Exception e) {
            e.printStackTrace();
        }
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidCatchingNPE"
          language="java"
          since="1.8"
          deprecated="true"
          message="NullPointerException 캐치를 피하세요. NPE의 원인을 제거하는 것을 고려하세요."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#avoidcatchingnpe">
        <description>
코드는 정상적인 상황에서 NullPointerException을 던져서는 안 됩니다. catch 블록이 원래 오류를 숨겨 나중에 더 미묘한 문제를 일으킬 수 있습니다.

**더 이상 사용되지 않음:** 이 규칙은 PMD 7.18.0부터 더 이상 사용되지 않으며 PMD 8.0.0에서 제거될 예정입니다.
이 규칙은 {% rule AvoidCatchingGenericException %}에 통합되었으며, 이제 어떤 예외가 위반을 유발하는지 설정할 수 있습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//CatchClause/CatchParameter/ClassType[pmd-java:typeIsExactly('java.lang.NullPointerException')]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Foo {
    void bar() {
        try {
            // do something
        } catch (NullPointerException npe) {
        }
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidCatchingThrowable"
          language="java"
          since="1.2"
          deprecated="true"
          message="catch 문은 오류를 포함하므로 throwable을 캐치해서는 안 됩니다."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#avoidcatchingthrowable">
        <description>
Throwable 오류를 캐치하는 것은 범위가 매우 넓기 때문에 권장되지 않습니다. OutOfMemoryError와 같은 런타임 문제를 포함하며, 이는 별도로 노출되고 관리되어야 합니다.

**더 이상 사용되지 않음:** 이 규칙은 PMD 7.18.0부터 더 이상 사용되지 않으며 PMD 8.0.0에서 제거될 예정입니다.
이 규칙은 {% rule AvoidCatchingGenericException %}에 통합되었으며, 이제 어떤 예외가 위반을 유발하는지 설정할 수 있습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                //CatchParameter[ClassType[pmd-java:typeIsExactly('java.lang.Throwable')]]/VariableId
                ]]></value>
            </property>
        </properties>
        <example>
<![CDATA[
public void bar() {
    try {
        // do something
    } catch (Throwable th) {  // should not catch Throwable
        th.printStackTrace();
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidDecimalLiteralsInBigDecimalConstructor"
          language="java"
          since="3.4"
          message="소수(float/double) 리터럴로 BigDecimal을 생성하지 마세요. 문자열 리터럴을 사용하세요"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#avoiddecimalliteralsinbigdecimalconstructor">
        <description>
"new BigDecimal(0.1)"의 결과가 정확히 0.1이라고 생각할 수 있지만, 실제로는 .1000000000000000055511151231257827021181583404541015625와 같습니다.
이는 0.1이 double(또는 유한한 길이의 이진 분수)로 정확하게 표현될 수 없기 때문입니다. 따라서 생성자에 전달되는 long 값은 외관과 달리 정확히 0.1이 아닙니다.

반면에 (String) 생성자는 완벽하게 예측 가능합니다: 'new BigDecimal("0.1")'은 예상대로 정확히 0.1과 같습니다. 따라서 일반적으로 이 생성자보다 (String) 생성자를 사용하는 것이 권장됩니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//ConstructorCall[pmd-java:matchesSig('java.math.BigDecimal#new(double)')]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
BigDecimal bd = new BigDecimal(1.123);       // loss of precision, this would trigger the rule

BigDecimal bd = new BigDecimal("1.123");     // preferred approach

BigDecimal bd = new BigDecimal(12);          // preferred approach, ok for integer values
]]>
        </example>
    </rule>

    <rule name="AvoidDuplicateLiterals"
          language="java"
          since="1.0"
          message="문자열 리터럴 {0}이(가) 이 파일에서 {1}번 나타납니다. 첫 번째 출현은 {2}번째 줄입니다"
          class="net.sourceforge.pmd.lang.java.rule.errorprone.AvoidDuplicateLiteralsRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#avoidduplicateliterals">
        <description>
중복된 문자열 리터럴을 포함하는 코드는 일반적으로 문자열을 상수 필드로 선언하여 개선할 수 있습니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
private void bar() {
     buz("Howdy");
     buz("Howdy");
     buz("Howdy");
     buz("Howdy");
}
private void buz(String x) {}
]]>
        </example>
    </rule>

    <rule name="AvoidEnumAsIdentifier"
          language="java"
          maximumLanguageVersion="1.4"
          since="3.4"
          message="enum을 식별자로 사용하지 마세요. JDK 1.5에서 예약어가 되었습니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#avoidenumasidentifier">
        <description>
`enum`이라는 용어를 사용하면 예약어이므로 최신 버전의 Java와 충돌합니다.

Java 1.5부터 `enum` 토큰은 예약어가 되었으며, 이를 식별자로 사용하면 Java 1.5 이후 버전에서 컴파일 오류가 발생합니다. 따라서 이 규칙은 Java 1.5 이전의 오래된 Java 코드에만 유용합니다. Java 업데이트 전에 문제가 되는 코드를 식별하는 데 사용할 수 있습니다.
        </description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>//VariableId[@Name='enum']</value>
            </property>
        </properties>
        <example>
<![CDATA[
public class A {
    public class Foo {
        String enum = "foo";
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidFieldNameMatchingMethodName"
          language="java"
          since="3.0"
          message="필드 {0}이(가) 메서드와 동일한 이름을 가지고 있습니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#avoidfieldnamematchingmethodname">
        <description>
필드 이름이 메서드와 동일한 이름을 가지면 혼란스러울 수 있습니다. 이는 허용되지만, 정보(필드)와 동작(메서드)을 구분하는 명확한 네이밍이 아닙니다. Smalltalk에 익숙한 개발자들은 메서드가 접근자 메서드를 나타내므로 이 접근 방식을 선호하기도 합니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//FieldDeclaration/VariableDeclarator/VariableId
    [some $method in ../../..[self::ClassBody or self::EnumBody]/MethodDeclaration
     satisfies lower-case(@Name) = lower-case($method/@Name)]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Foo {
    Object bar;
    // bar is data or an action or both?
    void bar() {
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidFieldNameMatchingTypeName"
          language="java"
          since="3.0"
          message="필드 이름이 선언 클래스 이름과 일치하면 다소 혼란스럽습니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#avoidfieldnamematchingtypename">
        <description>
필드 이름이 선언 타입 이름과 일치하면 다소 혼란스럽습니다.
이는 타입 및/또는 필드 이름을 더 신중하게 선택해야 한다는 것을 의미할 수 있습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//FieldDeclaration/VariableDeclarator/VariableId
    [lower-case(@Name) = lower-case(ancestor::ClassDeclaration[1]/@SimpleName)]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Foo extends Bar {
    int foo;    // There is probably a better name that can be used
}
public interface Operation {
    int OPERATION = 1; // There is probably a better name that can be used
}
]]>
        </example>
    </rule>

    <rule name="AvoidInstanceofChecksInCatchClause"
          language="java"
          since="3.0"
          message="캐치된 예외에 대해 instanceof 검사가 수행되고 있습니다. {0}에 대한 별도의 catch 절을 만드세요."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#avoidinstanceofchecksincatchclause">
        <description>
캐치된 각 예외 타입은 자체 catch 절에서 처리되어야 합니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//CatchParameter
    /following-sibling::Block//InfixExpression[@Operator = 'instanceof']
        /VariableAccess[@Name = ./ancestor::Block/preceding-sibling::CatchParameter/@Name]
            /following-sibling::TypeExpression/*
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
try { // Avoid this
    // do something
} catch (Exception ee) {
    if (ee instanceof IOException) {
        cleanup();
    }
}

try {  // Prefer this:
    // do something
} catch (IOException ee) {
    cleanup();
}
]]>
        </example>
    </rule>

    <rule name="AvoidLiteralsInIfCondition"
          language="java"
          since="4.2.6"
          message="if 문에서 {0}과 같은 리터럴 사용을 피하세요"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#avoidliteralsinifcondition">
        <description>
조건문에서 하드코딩된 리터럴 사용을 피하세요. 설명적인 이름을 가진 static 변수나 private 멤버로 선언하면 유지보수성이 향상됩니다. 기본적으로 리터럴 "-1"과 "0"은 무시됩니다.
"ignoreMagicNumbers" 속성으로 더 많은 예외를 정의할 수 있습니다.

이 규칙은 기본적으로 깊은 표현식을 고려하지 않지만, `ignoreExpressions` 속성을 통해 활성화할 수 있습니다.
이 속성을 false로 설정하면 `i == 1 + 5`와 같은 if 조건도 보고됩니다. 이 경우 표현식에 여러 리터럴이 포함되어 있으면 ignoreMagicNumbers 속성은 고려되지 않습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="ignoreMagicNumbers"
                      description="무시해야 할 매직 넘버의 쉼표로 구분된 목록"
                      type="String" value="-1,0"/>
            <property name="ignoreExpressions"
                      description="true이면 단순 if 조건의 리터럴만 고려됩니다. 그렇지 않으면 표현식의 리터럴도 검사됩니다."
                      type="Boolean" value="true"/>
            <property name="xpath">
                <value>
<![CDATA[
(: simple case - no deep expressions - this is always executed :)
//IfStatement/*[1]/*[pmd-java:nodeIs('Literal')]
    [not(pmd-java:nodeIs('NullLiteral'))]
    [not(pmd-java:nodeIs('BooleanLiteral'))]
    [empty(index-of(tokenize($ignoreMagicNumbers, '\s*,\s*'), @Image))]
|
(: consider also deeper expressions :)
//IfStatement[$ignoreExpressions = false()]/*[1]//*[not(self::UnaryExpression[@Operator = '-'])]/*[pmd-java:nodeIs('Literal')]
    [not(pmd-java:nodeIs('NullLiteral'))]
    [not(pmd-java:nodeIs('BooleanLiteral'))]
    [empty(index-of(tokenize($ignoreMagicNumbers, '\s*,\s*'), @Image))]
|
(: consider negative literals :)
//IfStatement[$ignoreExpressions = false()]/*[1]//UnaryExpression[@Operator = '-']/*[pmd-java:nodeIs('Literal')]
    [not(pmd-java:nodeIs('NullLiteral'))]
    [not(pmd-java:nodeIs('BooleanLiteral'))]
    [empty(index-of(tokenize($ignoreMagicNumbers, '\s*,\s*'), concat('-', @Image)))]
|
(: consider multiple literals in expressions :)
//IfStatement[$ignoreExpressions = false()]/*[1][count(*[pmd-java:nodeIs('Literal')]
    [not(pmd-java:nodeIs('NullLiteral'))]
    [not(pmd-java:nodeIs('BooleanLiteral'))]) > 1]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
private static final int MAX_NUMBER_OF_REQUESTS = 10;

public void checkRequests() {

    if (i == 10) {                        // magic number, buried in a method
      doSomething();
    }

    if (i == MAX_NUMBER_OF_REQUESTS) {    // preferred approach
      doSomething();
    }

    if (aString.indexOf('.') != -1) {}     // magic number -1, by default ignored
    if (aString.indexOf('.') >= 0) { }     // alternative approach

    if (aDouble > 0.0) {}                  // magic number 0.0
    if (aDouble >= Double.MIN_VALUE) {}    // preferred approach

    // with rule property "ignoreExpressions" set to "false"
    if (i == pos + 5) {}  // violation: magic number 5 within an (additive) expression
    if (i == pos + SUFFIX_LENGTH) {} // preferred approach
    if (i == 5 && "none".equals(aString)) {} // 2 violations: magic number 5 and literal "none"
}
]]>
        </example>
    </rule>

    <rule name="AvoidLosingExceptionInformation"
          since="4.2.6"
          language="java"
          message="catch 블록에서 예외의 접근자를 호출하면서 정보를 사용하지 않는 문을 피하세요"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#avoidlosingexceptioninformation"
          deprecated="true">
        <description>
catch 블록에서 예외의 접근자를 호출하면서 정보를 사용하지 않는 문은 코드 크기만 늘립니다. 호출을 제거하거나 반환 결과를 사용하세요.

**더 이상 사용되지 않음:** 이 규칙은 PMD 7.17.0부터 더 이상 사용되지 않으며 PMD 8.0.0에서 제거될 예정입니다.
이 규칙은 {% rule UselessPureMethodCall %}로 대체되었습니다.
        </description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//CatchClause/Block//ExpressionStatement/MethodCall[
    pmd-java:matchesSig("java.lang.Throwable#getMessage()")
    or pmd-java:matchesSig("java.lang.Throwable#getLocalizedMessage()")
    or pmd-java:matchesSig("java.lang.Throwable#getCause()")
    or pmd-java:matchesSig("java.lang.Throwable#getStackTrace()")
    or pmd-java:matchesSig("java.lang.Object#toString()")
]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public void bar() {
    try {
        // do something
    } catch (SomeException se) {
        se.getMessage();
    }
}
]]>
        </example>
    </rule>

    <rule name="AvoidMultipleUnaryOperators"
          language="java"
          since="4.2"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          message="여러 단항 연산자를 사용하는 것은 버그일 수 있으며 혼란스럽습니다."
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#avoidmultipleunaryoperators">
        <description>
여러 단항 연산자의 사용은 문제가 될 수 있으며 혼란스럽습니다.
의도된 사용이 버그가 아닌지 확인하거나 표현식을 단순화하는 것을 고려하세요.
        </description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                    (: Only report on the toplevel one :)
                    //UnaryExpression[UnaryExpression and not(parent::UnaryExpression)]
                ]]></value>
            </property>
        </properties>
        <example>
<![CDATA[
// These are typo bugs, or at best needlessly complex and confusing:
int i = - -1;
int j = + - +1;
int z = ~~2;
boolean b = !!true;
boolean c = !!!true;

// These are better:
int i = 1;
int j = -1;
int z = 2;
boolean b = true;
boolean c = false;

// And these just make your brain hurt:
int i = ~-2;
int j = -~7;
]]>
        </example>
    </rule>

    <rule name="AvoidUsingOctalValues"
          language="java"
          since="3.9"
          message="0으로 시작하는 정수 리터럴(8진수로 해석됨)을 피하세요. 10진수 리터럴을 얻으려면 앞의 0을 제거하세요(또는 명시적으로 0x, 0b 접두사를 사용하세요)"
          class="net.sourceforge.pmd.lang.java.rule.errorprone.AvoidUsingOctalValuesRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#avoidusingoctalvalues">
        <description>
Java에서 0으로 시작하는 정수 리터럴은 8진수(기수 8) 값으로 해석되어 예기치 않은 동작과 버그를 유발할 수 있습니다. 대부분의 개발자는 10진수(기수 10) 해석을 기대하므로 8진수 리터럴은 일반적인 혼란과 오류의 원인이 됩니다. 예를 들어, 012는 예상되는 12가 아닌 10진수로 10과 같습니다.
이 규칙은 10진수 값으로 오해될 수 있는 정수 리터럴을 플래그하여 이러한 실수를 방지하는 데 도움을 줍니다.
앞에 0이 없는 10진수 리터럴을 사용하거나, 의도한 기수를 명확히 하기 위해 16진수의 경우 0x, 2진수의 경우 0b와 같은 명시적 접두사를 사용하세요.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
// Bad: These look like decimal but are actually octal
int timeout = 060;     // Actually 48 in decimal, not 60!
int count = 012;       // Actually 10 in decimal, not 12!

// Good: Use decimal literals
int timeout = 60;      // Clear decimal value
int count = 12;        // Clear decimal value

// Good: Use explicit prefixes for other bases
int hexValue = 0xFF;   // Clearly hexadecimal
int binaryValue = 0b1010; // Clearly binary (Java 7+)
]]>
        </example>
    </rule>

    <rule name="BrokenNullCheck"
          language="java"
          since="3.8"
          message="이 표현식은 NullPointerException을 던질 것입니다"
          class="net.sourceforge.pmd.lang.java.rule.errorprone.BrokenNullCheckRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#brokennullcheck">
        <description>
null 검사가 깨져 있어 자체적으로 NullPointerException을 던질 것입니다.
|| 대신 &amp;&amp;를 사용하거나 그 반대일 가능성이 높습니다.
        </description>
        <priority>2</priority>
        <example>
<![CDATA[
public String bar(String string) {
  // should be &&
    if (string!=null || !string.equals(""))
        return string;
  // should be ||
    if (string==null && string.equals(""))
        return string;
}
]]>
        </example>
    </rule>

    <rule name="CallSuperFirst"
          since="4.2.5"
          language="java"
          message="super는 메서드의 시작 부분에서 호출되어야 합니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#callsuperfirst">
        <description>Super는 메서드의 시작 부분에서 호출되어야 합니다</description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//ClassDeclaration
    [
      pmd-java:typeIs('android.app.Activity') or
      pmd-java:typeIs('android.app.Application') or
      pmd-java:typeIs('android.app.Service')
    ]
    //MethodDeclaration
    [
      @Name=('onCreate', 'onConfigurationChanged', 'onPostCreate', 'onPostResume', 'onRestart',
             'onRestoreInstanceState', 'onResume', 'onStart')
    ]
    [not(Block/*[1]/MethodCall[SuperExpression][@MethodName = ancestor::MethodDeclaration/@Name])]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
import android.app.Activity;
import android.os.Bundle;

public class DummyActivity extends Activity {
    public void onCreate(Bundle bundle) {
        // missing call to super.onCreate(bundle)
        foo();
    }
}
]]>
        </example>
    </rule>

    <rule name="CallSuperLast"
          since="4.2.5"
          language="java"
          message="super는 메서드의 끝 부분에서 호출되어야 합니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#callsuperlast">
        <description>
Super는 메서드의 끝 부분에서 호출되어야 합니다
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//ClassDeclaration
    [
      pmd-java:typeIs('android.app.Activity') or
      pmd-java:typeIs('android.app.Application') or
      pmd-java:typeIs('android.app.Service')
    ]
    //MethodDeclaration
    [
      @Name=('finish', 'onDestroy', 'onPause', 'onSaveInstanceState', 'onStop', 'onTerminate')
    ]
    [not(Block/*[last()]/MethodCall[SuperExpression][@MethodName = ancestor::MethodDeclaration/@Name])]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
import android.app.Activity;

public class DummyActivity extends Activity {
    public void onPause() {
        foo();
        // missing call to super.onPause()
    }
}
]]>
        </example>
    </rule>

    <rule name="CheckSkipResult"
          language="java"
          since="5.0"
          message="요청한 바이트 수가 건너뛰어졌는지 확인하기 위해 InputStream의 skip() 메서드가 반환하는 값을 확인하세요."
          class="net.sourceforge.pmd.lang.java.rule.errorprone.CheckSkipResultRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#checkskipresult">
        <description>
skip() 메서드는 요청한 것보다 적은 수의 바이트를 건너뛸 수 있습니다. 반환된 값을 확인하여 그러한 경우인지 아닌지 확인하세요.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public class Foo {

   private FileInputStream _s = new FileInputStream("file");

   public void skip(int n) throws IOException {
      _s.skip(n); // You are not sure that exactly n bytes are skipped
   }

   public void skipExactly(int n) throws IOException {
      while (n != 0) {
         long skipped = _s.skip(n);
         if (skipped == 0)
            throw new EOFException();
         n -= skipped;
      }
   }
]]>
        </example>
    </rule>

    <rule name="ClassCastExceptionWithToArray"
          language="java"
          since="3.4"
          message="이 Collection.toArray() 메서드 사용은 ClassCastException을 던질 것입니다."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#classcastexceptionwithtoarray">
        <description>
Collection에서 특정 클래스의 배열을 파생할 때, `toArray()` 메서드의 매개변수로 동일한 클래스의 배열을 제공해야 합니다. 그렇지 않으면 `ClassCastException`이 발생합니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//CastExpression[ArrayType/ClassType[not(pmd-java:typeIsExactly('java.lang.Object'))]]
    /MethodCall[pmd-java:matchesSig("java.util.Collection#toArray()")]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
Collection c = new ArrayList();
Integer obj = new Integer(1);
c.add(obj);

    // this would trigger the rule (and throw a ClassCastException if executed)
Integer[] a = (Integer [])c.toArray();

   // this is fine and will not trigger the rule
Integer[] b = (Integer [])c.toArray(new Integer[0]);
]]>
        </example>
    </rule>

    <rule name="CloneMethodMustBePublic"
          language="java"
          since="5.4.0"
          message="클래스가 Cloneable을 구현하면 clone() 메서드는 public이어야 합니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#clonemethodmustbepublic">
        <description>
Java 매뉴얼에 따르면 "관례상, 이 인터페이스를 구현하는 클래스는 Object.clone()(protected)을 public 메서드로 오버라이드해야 합니다."
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//MethodDeclaration[not(pmd-java:modifiers() = "public")]
    [@Name = 'clone']
    [@Arity = 0]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Foo implements Cloneable {
    @Override
    protected Object clone() throws CloneNotSupportedException { // Violation, must be public
    }
}

public class Foo implements Cloneable {
    @Override
    protected Foo clone() { // Violation, must be public
    }
}

public class Foo implements Cloneable {
    @Override
    public Object clone() // Ok
}
]]>
        </example>
    </rule>

    <rule name="CloneMethodMustImplementCloneable"
          language="java"
          since="1.9"
          message="clone() 메서드는 Cloneable 인터페이스를 구현하는 경우에만 구현해야 합니다"
          class="net.sourceforge.pmd.lang.java.rule.errorprone.CloneMethodMustImplementCloneableRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#clonemethodmustimplementcloneable">
        <description>
clone() 메서드는 클래스가 Cloneable 인터페이스를 구현하는 경우에만 구현해야 합니다. 단, CloneNotSupportedException만 던지는 final 메서드는 예외입니다.

이 규칙은 클래스가 Cloneable 클래스를 구현하거나 확장하는지도 감지할 수 있습니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public class MyClass {
 public Object clone() throws CloneNotSupportedException {
  return foo;
 }
}
]]>
        </example>
    </rule>

    <rule name="CloneMethodReturnTypeMustMatchClassName"
          language="java"
          minimumLanguageVersion="1.5"
          since="5.4.0"
          message="Cloneable을 구현할 때 clone() 메서드의 반환 타입은 클래스 이름이어야 합니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#clonemethodreturntypemustmatchclassname">
        <description>
클래스가 `Cloneable`을 구현하면 `clone()` 메서드의 반환 타입은 클래스 이름이어야 합니다. 이렇게 하면 clone 메서드의 호출자가 반환된 clone을 올바른 타입으로 캐스트할 필요가 없습니다.

참고: 이러한 공변 반환 타입은 Java 1.5 이상에서만 가능합니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//MethodDeclaration
    [@Name = 'clone']
    [@Arity = 0]
    [ClassType[1]/@SimpleName != ancestor::ClassDeclaration[1]/@SimpleName]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Foo implements Cloneable {
    @Override
    protected Object clone() { // Violation, Object must be Foo
    }
}

public class Foo implements Cloneable {
    @Override
    public Foo clone() { //Ok
    }
}
]]>
        </example>
    </rule>

    <rule name="CloseResource"
          language="java"
          since="1.2.2"
          message="이 {0} 객체와 같은 리소스가 사용 후 닫히는지 확인하세요"
          class="net.sourceforge.pmd.lang.java.rule.errorprone.CloseResourceRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#closeresource">
        <description>
리소스(`java.sql.Connection`, `java.sql.Statement`, `java.sql.ResultSet` 객체 및 `java.lang.AutoCloseable`의 모든 하위 타입)가 사용 후 항상 닫히는지 확인하세요.
그렇지 않으면 리소스 누수가 발생할 수 있습니다.

참고: 상위 타입(예: `java.lang.AutoCloseable`)을 설정하면 이 규칙이 모든 하위 타입(예: `java.io.FileInputStream`)에 대해 자동으로 트리거됩니다. 추가로 `java.sql.Connection`을 지정하면 타입 해석/auxclasspath가 올바르게 설정되지 않은 경우 타입 감지에 도움이 됩니다.

참고: PMD 6.16.0부터 `types` 속성의 기본값에 `java.lang.AutoCloseable`이 포함되어 표준 `java.io.*Stream` 클래스가 관련된 경우도 감지합니다. 이전 동작을 복원하려면 types에서 "AutoCloseable"을 제거하세요.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public class Bar {
    public void withSQL() {
        Connection c = pool.getConnection();
        try {
            // do stuff
        } catch (SQLException ex) {
           // handle exception
        } finally {
            // oops, should close the connection using 'close'!
            // c.close();
        }
    }

    public void withFile() {
        InputStream file = new FileInputStream(new File("/tmp/foo"));
        try {
            int c = file.in();
        } catch (IOException e) {
            // handle exception
        } finally {
            // TODO: close file
        }
    }
}
]]>
        </example>
    </rule>

    <rule name="CollectionTypeMismatch"
          language="java"
          since="7.17.0"
          message="''{0}'' 타입의 객체는 ''{1}''을 기대하는 컬렉션에 있을 수 없습니다"
          class="net.sourceforge.pmd.lang.java.rule.errorprone.CollectionTypeMismatchRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#collectiontypemismatch">
        <description>
타입 불일치로 인해 전달된 객체가 컬렉션에 있을 수 없는 컬렉션 메서드 호출을 감지합니다. 이는 호환되지 않는 타입이 컬렉션 메서드(contains(), remove(), indexOf() 등)와 함께 사용되는 잠재적인 프로그래밍 오류를 잡는 데 도움이 됩니다.

검사되는 메서드:
- Collection: contains(), remove(), removeAll(), retainAll(), containsAll()
- List: indexOf(), lastIndexOf()
- Map: containsKey(), containsValue(), get(), getOrDefault(), remove()
- Deque: removeFirstOccurrence(), removeLastOccurrence()
- Hashtable: contains() (값을 검사하는 레거시 메서드)
- ConcurrentHashMap: contains() (값을 검사하는 레거시 메서드)
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
List<Integer> numbers = Arrays.asList(1, 2, 3);
numbers.remove("string"); // violation: String cannot be in Integer list

Map<String, Integer> map = new HashMap<>();
map.get(42); // violation: Integer key cannot be in String-keyed map

Set<String> names = new HashSet<>();
names.contains(123); // violation: Integer cannot be in String set
]]>
        </example>
    </rule>

    <rule name="CompareObjectsWithEquals"
          language="java"
          since="3.2"
          message="객체 참조를 비교하려면 equals()를 사용하세요."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#compareobjectswithequals">
        <description>
객체 참조를 비교하려면 `equals()`를 사용하세요. `==`으로 비교하는 것을 피하세요.

명명된 상수와 객체를 비교하는 것이 유용한 경우가 있으므로(예: 센티널 값에 대한 상수를 정의할 때), 이 규칙은 모든 대문자 이름을 가진 필드와의 비교(예: `this == SENTINEL`)를 무시합니다. 이는 상수 필드에 대한 일반적인 네이밍 규칙입니다.

`typesThatCompareByReference` 속성에 예외를 나열하여 일부 타입의 참조 비교를 허용할 수 있습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="typesThatCompareByReference" type="List[String]" description="참조 비교가 허용되는 정규화된 타입 이름 목록입니다.">
                <value>java.lang.Enum,java.lang.Class</value>
            </property>
            <property name="xpath">
                <value>
<![CDATA[
//InfixExpression
    [@Operator = ("==", "!=")]
    [count(*
        [not(self::NullLiteral)]
        [pmd-java:typeIs('java.lang.Object')]
        [not(some $t in $typesThatCompareByReference satisfies pmd-java:typeIs($t))]
      ) = 2
    ]
    [not(ancestor::MethodDeclaration[1][@Name = "equals"])]
    (: Is not a field access with an all-caps identifier :)
    [not(FieldAccess[upper-case(@Name)=@Name]
     or VariableAccess[upper-case(@Name)=@Name])]
]]>
        </value>
            </property>
        </properties>
        <example>
<![CDATA[
class Foo {
  boolean bar(String a, String b) {
    return a == b;
  }
}

]]>
        </example>
    </rule>

    <rule name="ComparisonWithNaN"
          language="java"
          since="6.36.0"
          message="NaN과의 비교는 항상 false를 반환합니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#comparisonwithnan">
        <description><![CDATA[
            double 및 float `NaN`(Not-a-Number) 값과의 비교를 보고합니다.
            이들은 직관적이지 않은 동작을 하도록 [지정](https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.21.1)되어 있습니다: NaN은 자기 자신과 같지 않은 것으로 간주됩니다.
            이는 `someDouble == Double.NaN`과 같은 검사가 `someDouble`이 실제로 NaN 값이더라도 항상 false를 반환한다는 것을 의미합니다. 값이 NaN 값인지 테스트하려면 대신 `Double.isNaN(someDouble)`(또는 `Float.isNaN`)을 사용해야 합니다. `!=` 연산자도 마찬가지로 처리해야 합니다.
            마지막으로, `someDouble <= Double.NaN`과 같은 비교는 무의미하며 항상 false로 평가됩니다.

            이 규칙은 PMD 6.36.0에서 "BadComparison"에서 이름이 변경되었습니다.
        ]]></description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//InfixExpression[@Operator = ("==", "!=", "<=", ">=", "<", ">")]/FieldAccess[@Name='NaN' and (pmd-java:typeIs('double') or pmd-java:typeIs('float'))]
]]>
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
boolean x = (y == Double.NaN);
]]>
        </example>
    </rule>

    <rule name="ConfusingArgumentToVarargsMethod"
          language="java"
          since="7.1.0"
          message="가변인자 또는 비가변인자 호출인지 불분명합니다. 의도를 명확히 하려면 {0} 또는 {0}[]로 캐스트하거나, 가변인자 매개변수를 개별적으로 전달하세요."
          class="net.sourceforge.pmd.lang.java.rule.errorprone.ConfusingArgumentToVarargsMethodRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#confusingargumenttovarargsmethod">
        <description>
            가변인자 메서드에 전달된 혼란스러운 인수를 보고합니다.

            이는 배열이 단일 가변인자 인수로 전달될 때, 배열 타입이 가변인자 메서드가 기대하는 배열 타입과 정확히 일치하지 않을 때 발생할 수 있습니다. 해당 배열이 기대하는 배열 타입의 컴포넌트 타입의 하위 타입이면, 호출된 가변인자 메서드가 어떤 값을 받을지 명확하지 않을 수 있습니다.
            예를 들어 다음과 같은 경우:
            ```java
            void varargs(Object... parm);
            ```
            다음과 같이 호출하면:
            ```java
            varargs(new String[]{"a"});
            ```
            메서드가 `new Object[]{ new String[] {"a"} }` 값을 받을지 아니면 `new String[] {"a"}`만 받을지(후자가 발생) 명확하지 않습니다. 이 혼란은 `String[]`이 `Object[]`의 하위 타입이면서 동시에 `Object`의 하위 타입이기 때문에 발생합니다. 이 경우 의도를 명확히 하려면 캐스트를 사용하거나 개별 요소를 다음과 같이 전달하세요:
            ```java
            // varargs call
            // parm will be `new Object[] { "a" }`
            varargs("a");

            // non-varargs call
            // parm will be `new String[] { "a" }`
            varargs((Object[]) new String[]{"a"});

            // varargs call
            // parm will be `new Object[] { new String[] { "a" } }`
            varargs((Object) new String[]{"a"});
            ```

            또 다른 혼란스러운 경우는 가변인자 인수로 `null`을 전달하는 것입니다. 여기서 단일 null 요소를 가진 배열을 전달하려는 것인지, null 배열을 전달하려는 것인지(후자가 발생) 명확하지 않습니다. 이것도 마찬가지로 캐스트로 명확히 할 수 있습니다.
        </description>
        <priority>3</priority>
        <example><![CDATA[
            import java.util.Arrays;

            abstract class C {
                abstract void varargs(Object... args);
                static {
                    varargs(new String[] { "a" });
                    varargs(null);
                }
            }
            ]]></example>
    </rule>

    <rule name="ConstructorCallsOverridableMethod"
          language="java"
          since="1.04"
          message="객체 생성 중 오버라이드 가능한 {0}이(가) 호출되었습니다{1}"
          class="net.sourceforge.pmd.lang.java.rule.errorprone.ConstructorCallsOverridableMethodRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#constructorcallsoverridablemethod">
        <description>
객체 초기화 중에 `this`에서 오버라이드 가능한 메서드 호출을 보고합니다. 이들은 불완전하게 생성된 객체에서 호출되며, 오버라이드된 경우 디버그하기 어려울 수 있습니다.
이는 하위 클래스가 일반적으로 모든 메서드에서 상위 클래스가 완전히 초기화되었다고 가정하기 때문입니다. 그렇지 않은 경우 생성자에서 버그가 나타날 수 있습니다. 예를 들어, 아직 null인 일부 필드가 NullPointerException을 유발하거나 나중에 폭발하도록 다른 곳에 저장될 수 있습니다.

이 문제를 피하려면 생성자에서 static, private 또는 final 메서드만 사용하세요.
이러한 메서드도 안전하려면 전이적으로 오버라이드 가능한 메서드를 호출해서는 안 됩니다.
        </description>
        <priority>1</priority>
        <example>
<![CDATA[
public class SeniorClass {
  public SeniorClass(){
      toString(); //may throw NullPointerException if overridden
  }
  public String toString(){
    return "IAmSeniorClass";
  }
}
public class JuniorClass extends SeniorClass {
  private String name;
  public JuniorClass(){
    super(); //Automatic call leads to NullPointerException
    name = "JuniorClass";
  }
  public String toString(){
    return name.toUpperCase();
  }
}
]]>
        </example>
    </rule>

    <rule name="DetachedTestCase"
          language="java"
          since="6.13.0"
          message="분리된 JUnit 테스트 케이스일 가능성이 있습니다."
          class="net.sourceforge.pmd.lang.java.rule.errorprone.DetachedTestCaseRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#detachedtestcase">
        <description>
이 메서드는 public 또는 default 가시성, 비정적 접근, 인수 없음, 반환 값 없음, 어노테이션 없음이지만, 하나 이상의 JUnit 테스트 케이스를 가진 클래스의 멤버이므로 테스트 케이스로 보입니다. 유틸리티 메서드라면 private 가시성을 가져야 합니다. 무시된 테스트라면 @Test와 @Ignore로 어노테이션되어야 합니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public class MyTest {
    @Test
    public void someTest() {
    }

    // violation: Not annotated
    public void someOtherTest () {
    }

}
]]>
        </example>
    </rule>

    <rule name="DoNotCallGarbageCollectionExplicitly"
          language="java"
          since="4.2"
          message="가비지 컬렉션을 명시적으로 트리거하지 마세요."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#donotcallgarbagecollectionexplicitly">
        <description>
`System.gc()`, `Runtime.getRuntime().gc()`, `System.runFinalization()` 호출은 권장되지 않습니다.
코드는 `-Xdisableexplicitgc` 옵션을 사용하여 가비지 컬렉션을 비활성화하든 그렇지 않든 동일한 동작을 해야 합니다.

또한 "현대적인" JVM은 가비지 컬렉션을 매우 잘 처리합니다. 메모리 누수와 관련 없는 메모리 사용 문제가 애플리케이션 내에서 발생하면, 코드 자체가 아닌 JVM 옵션으로 처리해야 합니다.
        </description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//MethodCall[
       pmd-java:matchesSig("java.lang.System#gc()")
    or pmd-java:matchesSig("java.lang.Runtime#gc()")
    or pmd-java:matchesSig("java.lang.System#runFinalization()")
    or pmd-java:matchesSig("java.lang.Runtime#runFinalization()")
]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class GCCall {
    public GCCall() {
        // Explicit gc call !
        System.gc();
    }

    public void doSomething() {
        // Explicit gc call !
        Runtime.getRuntime().gc();
    }

    public explicitGCcall() {
        // Explicit gc call !
        System.gc();
    }

    public void doSomething() {
        // Explicit gc call !
        Runtime.getRuntime().gc();
    }
}
]]>
        </example>
    </rule>

    <rule name="DoNotExtendJavaLangThrowable"
          language="java"
          since="6.0.0"
          message="예외는 java.lang.Throwable을 확장해서는 안 됩니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#donotextendjavalangthrowable">
        <description>
Throwable 대신 Exception 또는 RuntimeException을 확장하세요.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//ClassDeclaration/ExtendsList/ClassType
  [pmd-java:typeIsExactly('java.lang.Throwable')]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Foo extends Throwable { }
]]>
        </example>
    </rule>

    <rule name="DoNotHardCodeSDCard"
          since="4.2.6"
          language="java"
          message="/sdcard를 하드코딩하지 마세요."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#donothardcodesdcard">
        <description>
"/sdcard" 대신 Environment.getExternalStorageDirectory()를 사용하세요
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>//StringLiteral[starts-with(@Image,'"/sdcard')]</value>
            </property>
        </properties>
        <example>
<![CDATA[
public class MyActivity extends Activity {
    protected void foo() {
        String storageLocation = "/sdcard/mypackage";   // hard-coded, poor approach

       storageLocation = Environment.getExternalStorageDirectory() + "/mypackage"; // preferred approach
    }
}
]]>
        </example>
    </rule>

    <rule name="DoNotTerminateVM"
          language="java"
          since="4.1"
          message="J2EE/JEE 앱에서 System.exit()를 사용하면 안 됩니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#donotterminatevm">
        <description>
웹 애플리케이션은 `System.exit()`를 호출해서는 안 됩니다. 웹 컨테이너나 애플리케이션 서버만이 JVM을 중지해야 합니다. 그렇지 않으면 웹 애플리케이션이 동일한 애플리케이션 서버에서 실행 중인 모든 다른 애플리케이션을 종료시킵니다.

이 규칙은 동등한 호출인 `Runtime.getRuntime().exit()`와 `Runtime.getRuntime().halt()`도 검사합니다.

이 규칙은 PMD 6.29.0에서 "DoNotCallSystemExit"에서 이름이 변경되었습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//(MethodDeclaration[@MainMethod = false()] | Initializer)//MethodCall[
    pmd-java:matchesSig("java.lang.System#exit(int)")
    or pmd-java:matchesSig("java.lang.Runtime#exit(int)")
    or pmd-java:matchesSig("java.lang.Runtime#halt(int)")
]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public void bar() {
    System.exit(0);                 // never call this when running in an application server!
}
public void foo() {
    Runtime.getRuntime().exit(0);   // never stop the JVM manually, the container will do this.
}
]]>
        </example>
    </rule>

    <rule name="DoNotThrowExceptionInFinally"
          language="java"
          since="4.2"
          message="finally 블록의 throw 문은 제어 흐름을 이해하기 어렵게 만듭니다."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#donotthrowexceptioninfinally">
        <description>
'finally' 블록 내에서 예외를 던지는 것은 다른 예외나 코드 결함을 마스킹할 수 있으므로 혼란스럽습니다.
참고: 이것은 Lint4j 규칙 "A throw in a finally block"의 PMD 구현입니다
        </description>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value>//FinallyClause[descendant::ThrowStatement]</value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Foo {
    public void bar() {
        try {
            // Here do some stuff
        } catch( Exception e) {
            // Handling the issue
        } finally {
            // is this really a good idea ?
            throw new Exception();
        }
    }
}
]]>
        </example>
    </rule>

    <rule name="DontImportSun"
          language="java"
          since="1.5"
          deprecated="true"
          message="'sun.*' 패키지에서 임포트하는 것을 피하세요"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#dontimportsun">
        <description>
'sun.*' 패키지에서 임포트하는 것을 피하세요. 이 패키지들은 이식성이 없으며 변경될 수 있습니다.

Sun API에 의존해야 하는 경우, 이 의존성을 가능한 한 작은 범위로 제한하세요. 예를 들어, 불안정한 API 주변에 안정적인 래퍼 클래스를 작성합니다. 그런 다음 래퍼의 구현에서 이 규칙을 억제할 수 있습니다.

**더 이상 사용되지 않음:** 이 규칙은 PMD 7.21.0부터 더 이상 사용되지 않으며 PMD 8.0.0에서 제거될 예정입니다.
이 규칙은 {% rule UnsupportedJdkApiUsage %}로 대체되었습니다.
        </description>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//ImportDeclaration[starts-with(@ImportedName, 'sun.')]
]]>
                </value>
            </property>

        </properties>
        <example>
<![CDATA[
import sun.misc.foo;
public class Foo {}
]]>
        </example>
    </rule>

    <rule name="DontUseFloatTypeForLoopIndices"
          language="java"
          since="4.3"
          message="루프 인덱스에 부동 소수점을 사용하지 마세요. 부동 소수점을 사용해야 한다면 double을 사용하세요."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#dontusefloattypeforloopindices">
        <description>
루프 인덱스에 부동 소수점을 사용하지 마세요. 부동 소수점을 사용해야 한다면, float가 충분한 정밀도를 제공한다고 확신하고 성능 요구(공간 또는 시간)가 있는 경우가 아니라면 double을 사용하세요.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//ForStatement[
    ForInit//VariableId[pmd-java:typeIs('float')]
    or ForUpdate//VariableAccess[pmd-java:typeIs('float')]
]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Count {
  public static void main(String[] args) {
    final int START = 2000000000;
    int count = 0;
    for (float f = START; f < START + 50; f++)
      count++;
      //Prints 0 because (float) START == (float) (START + 50).
      System.out.println(count);
      //The termination test misbehaves due to floating point granularity.
    }
}
]]>
        </example>
    </rule>

    <rule name="EmptyCatchBlock"
          language="java"
          since="0.1"
          message="빈 catch 블록을 피하세요"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#emptycatchblock">
        <description>
빈 Catch 블록은 예외가 캐치되었지만 아무 작업도 수행되지 않는 인스턴스를 찾습니다.
대부분의 경우 이는 처리되거나 보고되어야 하는 예외를 삼키는 것입니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//CatchClause[
  Block[
      count(*) = 0
      and ($allowCommentedBlocks = false() or @containsComment = false())
  ]
  and CatchParameter/VariableId[not(matches(@Name, $allowExceptionNameRegex))]
]
]]>
                </value>
            </property>
            <property name="allowCommentedBlocks" type="Boolean" description="주석을 포함하는 빈 블록을 건너뜁니다" value="false"/>
            <property name="allowExceptionNameRegex" type="Regex" description="이 정규식과 일치하는 이름의 예외를 캐치하는 빈 블록을 건너뜁니다" value="^(ignored|expected)$"/>
        </properties>
        <example>
<![CDATA[
public void doSomething() {
    try {
        FileInputStream fis = new FileInputStream("/tmp/bugger");
    } catch (IOException ioe) {
        // not good
    }
}
]]>
        </example>
    </rule>

    <rule name="EmptyFinalizer"
          language="java"
          since="1.5"
          message="빈 finalize 메서드를 피하세요"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#emptyfinalizer">
        <description>
빈 finalize 메서드는 아무 목적이 없으며 제거해야 합니다. Oracle은 JDK 9부터 Object.finalize()를 더 이상 사용되지 않음(deprecated)으로 선언했습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//ClassDeclaration
  /ClassBody
    /MethodDeclaration[@Name = "finalize"][@Arity = 0][@Final = false() or ancestor::ClassDeclaration[@Final = true()]]
      /Block[not(*)]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Foo {
   protected void finalize() {}
}
]]>
        </example>
    </rule>

    <rule name="EqualsNull"
          language="java"
          since="1.9"
          message="null과 비교하기 위해 equals()를 사용하지 마세요"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#equalsnull">
        <description>
null 테스트에 equals() 메서드를 사용해서는 안 됩니다. 대신 '==' 연산자를 사용해야 합니다.
        </description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//MethodCall[@MethodName = "equals" and ArgumentList[count(*) = 1 and NullLiteral]]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
String x = "foo";

if (x.equals(null)) {   // bad form
    doSomething();
}

if (x == null) {        // preferred
    doSomething();
}
]]>
        </example>
    </rule>

    <rule name="FinalizeDoesNotCallSuperFinalize"
          language="java"
          since="1.5"
          message="finalize 메서드의 마지막 문은 super.finalize() 호출이어야 합니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#finalizedoesnotcallsuperfinalize">
        <description>
finalize()가 구현된 경우, 마지막 동작은 super.finalize를 호출하는 것이어야 합니다. Oracle은 JDK 9부터 Object.finalize()를 더 이상 사용되지 않음(deprecated)으로 선언했습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<!-- in English: a method declaration of finalize(), with no arguments, containing
a block whose last statement is NOT a call to super.finalize -->
<![CDATA[
//MethodDeclaration[@Name = "finalize"][@Arity = 0]
   /Block/*[last()]
      [not(MethodCall[@MethodName = "finalize"]/SuperExpression)]
      [not(FinallyClause/Block/ExpressionStatement/
          MethodCall[@MethodName = "finalize"]/SuperExpression)]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
protected void finalize() {
    something();
    // neglected to call super.finalize()
}
]]>
        </example>
    </rule>

    <rule name="FinalizeOnlyCallsSuperFinalize"
          language="java"
          since="1.5"
          message="Finalize는 super.finalize()를 호출하는 것 외에 다른 작업도 수행해야 합니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#finalizeonlycallssuperfinalize">
        <description>
finalize()가 구현된 경우, super.finalize()를 호출하는 것 외에 다른 작업도 수행해야 합니다. Oracle은 JDK 9부터 Object.finalize()를 더 이상 사용되지 않음(deprecated)으로 선언했습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//MethodDeclaration[@Name='finalize'][@Arity = 0]
   [Block[@Size=1]/ExpressionStatement/MethodCall[@MethodName = "finalize"][SuperExpression]]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
protected void finalize() {
    super.finalize();
}
]]>
        </example>
    </rule>

    <rule name="FinalizeOverloaded"
          language="java"
          since="1.5"
          message="Finalize 메서드는 오버로드되어서는 안 됩니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#finalizeoverloaded">
        <description>
finalize()라는 이름의 메서드는 매개변수를 가져서는 안 됩니다. 이는 혼란스러우며 Object.finalize()를 오버로드하려는 시도일 가능성이 높습니다. VM에 의해 호출되지 않습니다.

Oracle은 JDK 9부터 Object.finalize()를 더 이상 사용되지 않음(deprecated)으로 선언했습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//MethodDeclaration[@Name='finalize'][@Arity > 0]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Foo {
    // this is confusing and probably a bug
    protected void finalize(int a) {
    }
}
]]>
        </example>
    </rule>

    <rule name="FinalizeShouldBeProtected"
          language="java"
          since="1.1"
          message="finalize()를 오버라이드하는 경우 protected로 만드세요"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#finalizeshouldbeprotected">
        <description>
finalize()를 오버라이드할 때, 새 메서드는 protected로 설정해야 합니다. public으로 만들면 다른 클래스가 부적절한 시점에 호출할 수 있습니다.

Oracle은 JDK 9부터 Object.finalize()를 더 이상 사용되지 않음(deprecated)으로 선언했습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//MethodDeclaration[@Visibility != "protected"][@Name='finalize'][@Arity = 0]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public void finalize() {
    // do something
}
]]>
        </example>
    </rule>

    <rule name="IdempotentOperations"
          language="java"
          since="2.0"
          message="멱등 연산(변수를 자기 자신에게 할당하는 것과 같은)을 피하세요."
          class="net.sourceforge.pmd.lang.java.rule.errorprone.IdempotentOperationsRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#idempotentoperations">
        <description>
멱등 연산을 피하세요 - 아무 효과가 없습니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public class Foo {
 public void bar() {
  int x = 2;
  x = x;
 }
}
]]>
        </example>
    </rule>

    <rule name="IdenticalConditionalBranches"
          language="java"
          since="7.18.0"
          message="조건문이 조건을 무시합니다"
          class="net.sourceforge.pmd.lang.java.rule.errorprone.IdenticalConditionalBranchesRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#identicalconditionalbranches">
        <description>
            조건이 true일 때와 false일 때 동일한 작업을 수행하는 조건문은 잘못되었거나(분기 중 하나를 변경해야 함) 중복됩니다(분기 중 하나로 대체할 수 있음).
        </description>
        <priority>3</priority>
        <example>
            <![CDATA[
class Test {
    int method1() {
        if (Math.random() > 0.5) {
            return 1;
        } else {
            return 1;
        }
    }
    int method2() {
        return Math.random() > 0.5 ? 1 : 1;
    }
}
]]>
        </example>
    </rule>

    <rule name="ImplicitSwitchFallThrough"
          language="java"
          since="3.0"
          message="이 switch case는 이전 case에서의 fall-through로 도달할 수 있습니다"
          class="net.sourceforge.pmd.lang.java.rule.errorprone.ImplicitSwitchFallThroughRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#implicitswitchfallthrough">
        <description>
각 case 옵션에 break 또는 return 문이 없는 switch 문은 문제가 있는 동작을 나타낼 수 있습니다. 빈 case는 의도적인 fall-through를 나타내므로 무시됩니다.

fall-through로 도달하는 case 레이블 앞에 `// fallthrough` 주석을 달거나, `@SuppressWarnings("fallthrough")`를 사용하여 위반을 무시할 수 있습니다.

이 규칙은 PMD 6.37.0에서 "MissingBreakInSwitch"에서 이름이 변경되었습니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public void bar(int status) {
    switch(status) {
      case CANCELLED:
        doCancelled();
        // break; hm, should this be commented out?
      case NEW:
        doNew();
        // is this really a fall-through?
        // what happens if you add another case after this one?
      case REMOVED:
        doRemoved();
        // fallthrough - this comment just clarifies that you want a fallthrough
      case OTHER: // empty case - this is interpreted as an intentional fall-through
      case ERROR:
        doErrorHandling();
        break;
    }
}
]]>
        </example>
    </rule>

    <rule name="InstantiationToGetClass"
          language="java"
          since="2.0"
          message="getClass()를 호출하기 위해 객체를 인스턴스화하지 마세요. 대신 .class public 멤버를 사용하세요"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#instantiationtogetclass">
        <description>
getClass()를 호출하기 위해 객체를 인스턴스화하지 마세요. 대신 .class public 멤버를 사용하세요.
        </description>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//MethodCall
 [@MethodName='getClass']
 [ConstructorCall]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
// replace this
Class c = new String().getClass();

// with this:
Class c = String.class;
]]>
        </example>
    </rule>

    <rule name="InvalidLogMessageFormat"
          language="java"
          since="5.5.0"
          message="잘못된 메시지 형식"
          class="net.sourceforge.pmd.lang.java.rule.errorprone.InvalidLogMessageFormatRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#invalidlogmessageformat">
        <description>
slf4j 및 log4j2(6.19.0부터) 로거에서 인수와 플레이스홀더의 수가 일치하지 않는 메시지를 검사합니다.

6.32.0부터 매개변수화된 메시지 플레이스홀더(`{}`) 외에도 문자열 형식 메시지의 형식 지정자(`%s`)도 지원됩니다.

이 규칙은 PMD 6.19.0에서 "InvalidSlf4jMessageFormat"에서 이름이 변경되었습니다.
        </description>
        <priority>5</priority>
        <example>
<![CDATA[
LOGGER.error("forget the arg {}");
LOGGER.error("forget the arg %s");
LOGGER.error("too many args {}", "arg1", "arg2");
LOGGER.error("param {}", "arg1", new IllegalStateException("arg")); //The exception is shown separately, so is correct.
]]>
        </example>
    </rule>

    <rule name="JumbledIncrementer"
          language="java"
          since="1.0"
          message="내부 루프의 for 업데이트 표현식에서 외부 루프 증분자를 수정하지 마세요"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#jumbledincrementer">
        <description>
뒤섞인 루프 증분자를 피하세요 - 이는 보통 실수이며, 의도적이더라도 혼란스럽습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//ForStatement
    [not(ForInit) or ForInit//VariableId/@Name != ForUpdate//VariableAccess/@Name]
    [ForUpdate//VariableAccess[@AccessType = 'WRITE']/@Name
     =
     ancestor::ForStatement/ForInit//VariableId/@Name
    ]
]]>
                </value>
            </property>
        </properties>
        <example>
 <![CDATA[
public class JumbledIncrementerRule1 {
    public void foo() {
        for (int i = 0; i < 10; i++) {          // only references 'i'
            for (int k = 0; k < 20; i++) {      // references both 'i' and 'k'
                System.out.println("Hello");
            }
        }
    }
}
]]>
        </example>
    </rule>

    <rule name="JUnitSpelling"
          language="java"
          since="1.0"
          message="JUnit 프레임워크 메서드(setUp 또는 tearDown)의 철자가 잘못되었을 수 있습니다"
          class="net.sourceforge.pmd.lang.java.rule.errorprone.JUnitSpellingRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#junitspelling">
        <description>
            JUnit 3에서 setUp 메서드는 테스트 실행에 필요한 모든 데이터 엔티티를 설정하는 데 사용됩니다.
            tearDown 메서드는 테스트 실행에 필요한 모든 데이터 엔티티를 정리하는 데 사용됩니다.
            테스트가 모든 것을 올바르게 설정하고 정리하려면 메서드 이름의 철자를 틀려서는 안 됩니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
import junit.framework.*;

public class Foo extends TestCase {
    public void setup() {}    // oops, should be setUp
    public void TearDown() {} // oops, should be tearDown
}
]]>
        </example>
    </rule>

    <rule name="JUnitStaticSuite"
          language="java"
          since="1.0"
          message="public이면서 static이 아닌 suite() 메서드가 있으므로 JUnit이 TestSuite를 가져오기 위해 호출하지 않습니다. 의도한 것입니까?"
          class="net.sourceforge.pmd.lang.java.rule.errorprone.JUnitStaticSuiteRule"
          typeResolution="true"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#junitstaticsuite">
        <description>
JUnit 테스트의 suite() 메서드는 public이면서 static이어야 합니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
import junit.framework.*;

public class Foo extends TestCase {
    public void suite() {}         // oops, should be static
}
]]>
        </example>
        <example>
<![CDATA[
import junit.framework.*;

public class Foo extends TestCase {
    private static void suite() {} // oops, should be public
}
]]>
        </example>
    </rule>

    <rule name="MethodWithSameNameAsEnclosingClass"
          language="java"
          since="1.5"
          message="메서드는 포함 클래스와 동일한 이름을 가져서는 안 됩니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#methodwithsamenameasenclosingclass">
        <description>
메서드는 포함 클래스와 동일한 이름을 가져서는 안 됩니다.
생성자처럼 보여 혼란스러울 수 있습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//MethodDeclaration[@Name = ancestor::ClassDeclaration/@SimpleName]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class MyClass {

    public MyClass() {}         // this is OK because it is a constructor

    public void MyClass() {}    // this is bad because it is a method
}
]]>
        </example>
    </rule>

    <rule name="MisplacedNullCheck"
          language="java"
          since="3.5"
          message="여기서 null 검사가 잘못 배치되었습니다. 변수 ''{0}''이(가) null이면 NullPointerException이 발생합니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#misplacednullcheck">
        <description>
여기서 null 검사가 잘못 배치되었습니다. 변수가 null이면 `NullPointerException`이 발생합니다.
검사가 쓸모없거나(변수가 절대 `null`이 아님) 잘못된 것입니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//InfixExpression[@Operator = '&&']
    /InfixExpression[@Operator = '!=']
        (: one side is null :)
        [NullLiteral]
        (: other side checks for the variable used somewhere in the first child of conditional and expression :)
        [VariableAccess]
        [some $var in preceding-sibling::*//VariableAccess
            [parent::MethodCall or parent::FieldAccess]
            [not(ancestor::InfixExpression[@Operator = '||'])]
            /@Name
            satisfies $var = VariableAccess/@Name
        ]
    /VariableAccess
|
//InfixExpression[@Operator = '||']
    /InfixExpression[@Operator = '==']
        (: one side is null :)
        [NullLiteral]
        (: other side checks for the variable used somewhere in the first child of conditional or expression :)
        [VariableAccess]
        [some $var in preceding-sibling::*//VariableAccess
            [parent::MethodCall or parent::FieldAccess]
            [not(ancestor::InfixExpression[@Operator = '&&'])]
            /@Name
            satisfies $var = VariableAccess/@Name
        ]
    /VariableAccess
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Foo {
    void bar() {
        if (a.equals(baz) && a != null) {} // a could be null, misplaced null check

        if (a != null && a.equals(baz)) {} // correct null check
    }
}
]]>
        </example>
        <example>
<![CDATA[
public class Foo {
    void bar() {
        if (a.equals(baz) || a == null) {} // a could be null, misplaced null check

        if (a == null || a.equals(baz)) {} // correct null check
    }
}
]]>
        </example>
    </rule>

    <rule name="MissingSerialVersionUID"
          language="java"
          since="3.0"
          message="Serializable을 구현하는 클래스는 serialVersionUID를 설정해야 합니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#missingserialversionuid">
        <description>
Serializable 클래스는 serialVersionUID 필드를 제공해야 합니다.
serialVersionUID 필드는 추상 기본 클래스에도 필요합니다. 상속 체인의 각 개별 클래스는 자체 serialVersionUID 필드가 필요합니다. [Should an abstract class have a serialVersionUID](https://stackoverflow.com/questions/893259/should-an-abstract-class-have-a-serialversionuid)도 참조하세요.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//ClassDeclaration
    [@Interface = false()]
    [count(ClassBody/FieldDeclaration/VariableDeclarator/VariableId[@Name='serialVersionUID']) = 0]
    [(ImplementsList | ExtendsList)/ClassType[pmd-java:typeIs('java.io.Serializable')]]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Foo implements java.io.Serializable {
    String name;
    // Define serialization id to avoid serialization related bugs
    // i.e., public static final long serialVersionUID = 4328743;
}
]]>
        </example>
    </rule>

    <rule name="MissingStaticMethodInNonInstantiatableClass"
          language="java"
          since="3.0"
          message="클래스를 인스턴스화할 수 없으며 static 메서드나 필드를 제공하지 않습니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#missingstaticmethodinnoninstantiatableclass">
        <description>
private 생성자를 가지고 static 메서드나 필드가 없는 클래스는 사용할 수 없습니다.

private 생성자 중 하나가 어노테이션으로 표시된 경우, 클래스는 더 이상 인스턴스화 불가능한 것으로 간주되지 않으며 위반이 보고되지 않습니다.
`annotations` 속성을 참조하세요.
        </description>
        <priority>3</priority>
        <properties>
            <property name="annotations" type="List[String]" value="org.springframework.beans.factory.annotation.Autowired,javax.inject.Inject,com.google.inject.Inject,lombok.Builder" description="생성자가 이 어노테이션 중 하나로 표시된 경우 클래스는 무시됩니다."/>
            <property name="xpath">
                <value>
<![CDATA[
let $topLevelClass := /*/ClassDeclaration return
let $isLombokUtility := exists($topLevelClass[pmd-java:hasAnnotation('lombok.experimental.UtilityClass')]) return
$topLevelClass[
        (: non-instantiable :)
        $isLombokUtility or
        (
            (: no lombok produced constructors :)
            not(pmd-java:hasAnnotation('lombok.NoArgsConstructor') or
                pmd-java:hasAnnotation('lombok.RequiredArgsConstructor') or
                pmd-java:hasAnnotation('lombok.AllArgsConstructor') or
                pmd-java:hasAnnotation('lombok.Builder')) and
            (: or has non-default constructors … :)
            ClassBody/ConstructorDeclaration and
                (: … but only private … :)
                not(ClassBody/ConstructorDeclaration[@Visibility != "private"]) and
                (: … and none annotated … :)
                (every $x in $annotations satisfies
                      not(ClassBody/ConstructorDeclaration/ModifierList/Annotation[pmd-java:typeIs($x)]))
        )
    ]
    [
        (: With no visible static methods … :)
        not(ClassBody/MethodDeclaration[($isLombokUtility or pmd-java:modifiers() = "static") and @Visibility != "private"]) and
        (: … nor fields … :)
        not(ClassBody/FieldDeclaration[($isLombokUtility or pmd-java:modifiers() = "static") and @Visibility != "private"]) and
        (: … no nested classes, that are non-private and static … :)
        not(ClassBody/ClassDeclaration
            [pmd-java:modifiers() = "static" and @Visibility != "private"]
            (: … and a non-private method returning the outer class type … :)
            [(ClassBody/MethodDeclaration
                [@Visibility != "private"]
                [descendant::ReturnStatement/*[1][pmd-java:typeIs(ancestor::ClassDeclaration[@Nested = false()]/@BinaryName)]]
            ) or (
                (: … or the inner class extends the outer class :)
                ExtendsList/ClassType[@SimpleName = ancestor::ClassDeclaration[@Nested = false()]/@SimpleName]
            )]
    )]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
// This class is unusable, since it cannot be
// instantiated (private constructor),
// and no static method can be called.

public class Foo {
  private Foo() {}
  void foo() {}
}

]]>
        </example>
    </rule>

    <rule name="MoreThanOneLogger"
          language="java"
          since="2.0"
          message="클래스에 둘 이상의 로거가 포함되어 있습니다."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#morethanonelogger">
        <description>
일반적으로 각 클래스에서 하나의 로거만 사용됩니다. 이 규칙은 slf4j, log4j, Java Util Logging 및 log4j2(6.19.0부터)를 지원합니다.
        </description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
//ClassDeclaration[
  count(
    ClassBody/FieldDeclaration/ClassType[
      pmd-java:typeIs("org.apache.log4j.Logger") or
      pmd-java:typeIs("org.apache.logging.log4j.Logger") or
      pmd-java:typeIs("java.util.logging.Logger") or
      pmd-java:typeIs("org.slf4j.Logger")
    ]
  ) > 1
]
                ]]></value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Foo {
    Logger log = Logger.getLogger(Foo.class.getName());
    // It is very rare to see two loggers on a class, normally
    // log information is multiplexed by levels
    Logger log2= Logger.getLogger(Foo.class.getName());
}
]]>
        </example>
    </rule>

    <rule name="NonCaseLabelInSwitchStatement" deprecated="true" ref="NonCaseLabelInSwitch" />

    <rule name="NonCaseLabelInSwitch"
          language="java"
          since="1.5"
          message="switch 문 또는 표현식에 case가 아닌 레이블이 있습니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#noncaselabelinswitch">
        <description>
switch 문 또는 switch 표현식에 case가 아닌 레이블(예: 명명된 break/continue 레이블)이 있습니다.
이는 합법적이지만 혼란스럽습니다. case 레이블과 case가 아닌 레이블을 혼동하기 쉽습니다.

참고: 이 규칙은 PMD 7.7.0에서 `NonCaseLabelInSwitchStatement`에서 이름이 변경되었습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>//(SwitchStatement|SwitchExpression)//LabeledStatement</value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Foo {
  void bar(int a) {
   switch (a) {
     case 1:
       // do something
     mylabel: // this is legal, but confusing!
       break;
     default:
       break;
    }
  }
}
]]>
        </example>
    </rule>

    <rule name="NonSerializableClass"
          language="java"
          since="1.1"
          message="직렬화 가능한 클래스 ''{1}''의 필드 ''{0}''이(가) 직렬화 불가능한 타입 ''{2}''입니다."
          class="net.sourceforge.pmd.lang.java.rule.errorprone.NonSerializableClassRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#nonserializableclass">
        <description>
클래스가 `Serializable`로 표시된 경우 모든 필드도 직렬화 가능해야 합니다. 필드를 제외하려면 transient로 표시할 수 있습니다. Static 필드는 고려되지 않습니다.

이 규칙은 직렬화 불가능한 모든 필드를 보고합니다.

클래스가 수동 직렬화를 수행하는 메서드(`writeObject`, `readObject`)를 구현하거나 대체 객체(`writeReplace`, `readResolve`)를 사용하면 이 클래스는 무시됩니다.

참고: 이 규칙은 PMD 6.52.0에서 개편되었습니다. 이전에는 "BeanMembersShouldSerialize"라고 불렸습니다.
`prefix` 속성은 더 이상 사용되지 않습니다. 직렬화 가능한 클래스에서는 이름에 관계없이 모든 필드가 직렬화 가능해야 하기 때문입니다.
        </description>
        <priority>3</priority>
        <example>
            <![CDATA[
class Buzz implements java.io.Serializable {
    private static final long serialVersionUID = 1L;

    private transient int someFoo;          // good, it's transient
    private static int otherFoo;            // also OK, it's static
    private java.io.FileInputStream stream; // bad - FileInputStream is not serializable

    public void setStream(FileInputStream stream) {
        this.stream = stream;
    }

    public int getSomeFoo() {
          return this.someFoo;
    }
}
]]>
        </example>
    </rule>

    <rule name="NonStaticInitializer"
          language="java"
          since="1.5"
          message="비정적 초기화 블록은 혼란스럽습니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#nonstaticinitializer">
        <description>
비정적 초기화 블록은 생성자가 호출될 때마다(생성자 호출 직전에) 호출됩니다. 이는 유효한 언어 구조이지만 거의 사용되지 않으며 혼란스럽습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//Initializer[@Static=false()][not(ancestor::*[3][self::ConstructorCall or self::EnumConstant])]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class MyClass {
  // this block gets run before any call to a constructor
  {
    System.out.println("I am about to construct myself");
  }
}
]]>
        </example>
    </rule>

    <rule name="NullAssignment"
          language="java"
          since="1.02"
          message="객체에 null을 할당하는 것은 코드 냄새입니다. 리팩토링을 고려하세요."
          class="net.sourceforge.pmd.lang.java.rule.errorprone.NullAssignmentRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#nullassignment">
        <description>
변수에(선언 외부에서) "null"을 할당하는 것은 일반적으로 좋지 않은 관행입니다. 때때로 이러한 유형의 할당은 프로그래머가 코드에서 무슨 일이 일어나고 있는지 완전히 이해하지 못하고 있다는 표시입니다.

참고: 이 종류의 할당은 객체를 역참조하고 가비지 컬렉션을 유도하기 위해 일부 경우에 사용될 수 있습니다.
        </description>
        <priority>3</priority>
        <example>
 <![CDATA[
public void bar() {
  Object x = null; // this is OK
  x = new Object();
     // big, complex piece of code here
  x = null; // this is not required
     // big, complex piece of code here
}
]]>
        </example>
    </rule>

    <rule name="OverrideBothEqualsAndHashcode"
          language="java"
          since="0.4"
          message="equals()와 hashCode()를 모두 오버라이드하세요"
          class="net.sourceforge.pmd.lang.java.rule.errorprone.OverrideBothEqualsAndHashcodeRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#overridebothequalsandhashcode">
        <description>
`public boolean Object.equals(Object other)`와 `public int Object.hashCode()`를 모두 오버라이드하거나 둘 다 오버라이드하지 마세요.
부모 클래스에서 `hashCode()`를 상속받더라도 `hashCode()`를 구현하고 명시적으로 상위 클래스에 위임하는 것을 고려하세요.

두 메서드를 모두 오버라이드하지 않으면 `equals()`와 `hashCode()` 사이의 계약을 위반할 수 있습니다. 가장 중요한 것은 두 인스턴스가 동일하면 동일한 해시 코드를 가져야 한다는 것입니다. `HashSet`이나 `HashMap`과 같은 해시 기반 컬렉션에서 이러한 유효하지 않은 인스턴스를 사용하면 중복되거나 누락된 항목이 발생할 수 있습니다.

이 규칙은 `Comparable`을 구현하는 타입을 고려하지 않습니다. 이에 대한 별도의 규칙 {% rule OverrideBothEqualsAndHashCodeOnComparable %}이 있습니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public class Bar {        // poor, missing a hashcode() method
    public boolean equals(Object o) {
      // do some comparison
    }
}

public class Baz {        // poor, missing an equals() method
    public int hashCode() {
      // return some hash value
    }
}

public class Foo {        // perfect, both methods provided
    public boolean equals(Object other) {
      // do some comparison
    }
    public int hashCode() {
      // return some hash value
    }
}
]]>
        </example>
    </rule>

    <rule name="OverrideBothEqualsAndHashCodeOnComparable"
          language="java"
          since="7.17.0"
          message="Comparable을 구현할 때 equals()와 hashCode()를 모두 오버라이드해야 합니다"
          class="net.sourceforge.pmd.lang.java.rule.errorprone.OverrideBothEqualsAndHashCodeOnComparableRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#overridebothequalsandhashcodeoncomparable">
        <description>
            `Comparable`을 구현하는 클래스는 인스턴스가 컬렉션에서 사용되는 경우 `equals()`와 `hashCode()`를 모두 오버라이드해야 합니다. 이는 클래스의 자연 순서가 `equals()`와 일관되도록 하기 위함입니다.
            그렇지 않으면 `Set` 인터페이스를 준수하지 않는 집합에서 예기치 않은 동작이 발생할 수 있습니다. `Set` 인터페이스는 객체 동등성을 결정하기 위해 `equals()`에 의존하지만, `TreeSet`과 같은 정렬된 집합은 대신 `compareTo()`를 사용합니다. 이러한 객체가 정렬된 맵의 키로 사용될 때도 동일한 문제가 발생할 수 있습니다.

            참고 1: 이 규칙은 {% rule OverrideBothEqualsAndHashcode %}와 관련이 있습니다. `Comparable`을 구현하는 클래스에 대해서만 누락된 `equals()` 및/또는 `hashCode()` 메서드를 보고합니다.

            참고 2: 이 규칙은 `equals()` 또는 `hashCode()` 중 하나만 오버라이드되고 둘 다 오버라이드되지 않은 경우에만 레코드를 보고합니다. 레코드가 생성된 equals/hashCode 메서드를 사용하는 경우, `compareTo()` 구현은 모든 레코드 컴포넌트가 고려되는 경우에만 `equals()`와 일관됩니다.
        </description>
        <priority>3</priority>
        <example>
            <![CDATA[
public class Bar implements Comparable<Bar> {  // poor - missing equals() and hashCode()
    public int compareTo(Bar other) {
        // some comparison
    }
}

public class Baz implements Comparable<Baz> {  // poor - missing hashCode()
    public int compareTo(Baz other) {
        // some comparison
    }
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        return compareTo((Baz) o) == 0;
    }
}

public class Foo implements Comparable<Foo> {  // correct
    public int compareTo(Foo other) {
        // some comparison
    }
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        return compareTo((Foo) o) == 0;
    }
    public int hashCode() {
        // return hash code
    }
}
]]>
        </example>
    </rule>

    <rule name="ProperCloneImplementation"
          language="java"
          since="1.4"
          message="Object clone()은 super.clone()으로 구현해야 합니다"
          class="net.sourceforge.pmd.lang.java.rule.errorprone.ProperCloneImplementationRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#propercloneimplementation">
        <description>
Object clone()은 super.clone()으로 구현해야 합니다.
        </description>
        <priority>2</priority>
        <example>
<![CDATA[
class Foo{
    public Object clone(){
        return new Foo(); // This is bad
    }
}
]]>
        </example>
    </rule>

    <rule name="ProperLogger"
          language="java"
          since="3.3"
          message="로거는 private static final로 정의되어야 하며 올바른 클래스를 가져야 합니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#properlogger">
        <description>
로거는 일반적으로 private static final로 정의되어야 하며 올바른 클래스와 연결되어야 합니다.
`private final Log log;`은 로거를 전달해야 하는 드문 경우에도 허용되며, 로거가 생성자에 전달되어야 한다는 제한이 있습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//FieldDeclaration
    [ClassType[pmd-java:typeIs($loggerClass)]]
    [
        (: check modifiers :)
        (not(pmd-java:modifiers() = 'private') or not(pmd-java:modifiers() = 'final'))
        (: check logger name :)
        or (pmd-java:modifiers() = 'static' and VariableDeclarator/VariableId/@Name != $staticLoggerName)
        or (not(pmd-java:modifiers() = 'static') and VariableDeclarator/VariableId/@Name != $loggerName)
        (: check logger argument type matches class or enum name :)
        or .//ArgumentList/ClassLiteral/ClassType/@SimpleName != ancestor::ClassDeclaration/@SimpleName
        or .//ArgumentList/ClassLiteral/ClassType/@SimpleName != ancestor::EnumDeclaration/@SimpleName

        (: special case - final logger initialized inside constructor :)
        or (VariableDeclarator/@Initializer = false()
            and not(pmd-java:modifiers() = 'static')
            and not(ancestor::ClassBody/ConstructorDeclaration
                //AssignmentExpression[@Operator = '=']
                    [FieldAccess[1]/@Name = $loggerName or VariableAccess[1]/@Name = $loggerName]
                    [*[2][@Name = ancestor::ConstructorDeclaration//FormalParameter/VariableId/@Name]])
        )
    ]
]]>
                </value>
            </property>
            <property name="staticLoggerName" type="String" description="static Logger 변수의 이름" value="LOG"/>
            <property name="loggerName" type="String" description="Logger 인스턴스 변수의 이름" value="log"/>
            <property name="loggerClass" type="String" description="로거의 클래스 이름" value="org.apache.commons.logging.Log"/>
        </properties>
        <example>
 <![CDATA[
public class Foo {

    private static final Log LOG = LogFactory.getLog(Foo.class);    // proper way

    protected Log LOG = LogFactory.getLog(Testclass.class);         // wrong approach
}
]]>
        </example>
    </rule>

    <rule name="ReplaceJavaUtilCalendar"
          language="java"
          since="7.16.0"
          message="java.util.Calendar 사용은 java.time의 클래스로 대체해야 합니다"
          minimumLanguageVersion="1.8"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#replacejavautilcalendar">
        <description>
레거시 `java.util.Calendar` API는 오류가 발생하기 쉽고, 가변적이며, 스레드 안전하지 않습니다. 혼란스러운 월 인덱싱(1월 = 0),
일관성 없는 필드 의미론, 그리고 장황한 사용 패턴을 가지고 있습니다. 현대적인 `java.time API`(Java 8에서 도입)는
불변이고 스레드 안전한 대안을 명확하고 직관적인 메서드로 제공합니다.

`java.time` 패키지의 `LocalDate`(날짜 전용 연산), `LocalDateTime`(날짜와 시간),
또는 `ZonedDateTime`(시간대가 중요한 경우)을 대신 사용하세요.

참고: JPA 3.2(Jakarta Persistence) 이후로 `java.util.Date`와 `java.util.Calendar` 및 기타의 사용은
`java.time` API를 선호하여 더 이상 권장되지 않습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                //LocalVariableDeclaration[ClassType[pmd-java:typeIs('java.util.Calendar')]] |
                //FormalParameter[ClassType[pmd-java:typeIs('java.util.Calendar')]] |
                //FieldDeclaration[ClassType[pmd-java:typeIs('java.util.Calendar')]] |
                //ConstructorCall[ClassType[pmd-java:typeIs('java.util.Calendar')]]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZonedDateTime;

public class Foo {
    void problematic() {
        // Problematic - using legacy Calendar API
        Calendar cal = Calendar.getInstance();
        cal.set(2024, Calendar.JANUARY, 15); // Month indexing is confusing (0-based)
        cal.add(Calendar.DAY_OF_MONTH, 7);

        Calendar specific = new GregorianCalendar(2024, 0, 15); // Also problematic
    }

    void preferred() {
        // Preferred - using modern java.time API
        LocalDate date = LocalDate.of(2024, 1, 15); // Month indexing is intuitive (1-based)
        LocalDate weekLater = date.plusDays(7);

        LocalDateTime dateTime = LocalDateTime.now();
        ZonedDateTime zonedDateTime = ZonedDateTime.now();
    }
}
]]>
        </example>
    </rule>

    <rule name="ReplaceJavaUtilDate"
          language="java"
          since="7.16.0"
          message="java.util.Date 사용은 java.time의 클래스로 대체해야 합니다"
          minimumLanguageVersion="1.8"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#replacejavautildate">
        <description>
레거시 `java.util.Date` 클래스는 가변적이고, 스레드 안전하지 않으며, 혼란스러운 API를 가지고 있습니다. 많은 메서드가
더 이상 사용되지 않으며, 시간대를 제대로 처리하지 못하고, 하나만 필요할 때도 날짜와 시간을 모두 나타냅니다.
생성자 매개변수는 특히 오류가 발생하기 쉽습니다: 연도는 "1900 이후의 연도"이고 월은 0부터 시작합니다(1월 = 0).
현대적인 java.time API(Java 8에서 도입)는 더 나은 타입 안전성, 불변성, 그리고 명확한 의미론을 제공합니다.

`java.time` 패키지의 `LocalDate`(날짜만), `LocalTime`(시간만), `LocalDateTime`(날짜와 시간),
`Instant`(타임스탬프), 또는 `ZonedDateTime`(시간대가 있는 날짜-시간)을 대신 사용하세요.

참고: 이것은 `java.sql.Date`, `java.sql.Time` 및 `java.sql.Timestamp`와 같은 하위 타입도 포함합니다.
JPA 3.2(Jakarta Persistence) 이후로 `java.util.Date`와 `java.util.Calendar` 및 기타의 사용은
`java.time` API를 선호하여 더 이상 권장되지 않습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value><![CDATA[
                //LocalVariableDeclaration[ClassType[pmd-java:typeIs('java.util.Date')]] |
                //FormalParameter[ClassType[pmd-java:typeIs('java.util.Date')]] |
                //FieldDeclaration[ClassType[pmd-java:typeIs('java.util.Date')]] |
                //ConstructorCall[ClassType[pmd-java:typeIs('java.util.Date')]]
                ]]></value>
            </property>
        </properties>
        <example>
            <![CDATA[
import java.util.Date;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZonedDateTime;

public class Foo {
    void problematic() {
        // Problematic - using legacy Date API
        Date now = new Date();
        Date epoch = new Date(0L);
        Date custom = new Date(124, 0, 15); // Deprecated constructor: year=1900+124=2024, month=0=January

        // Mutable operations are error-prone
        now.setTime(System.currentTimeMillis());
    }

    void preferred() {
        // Preferred - using modern java.time API
        Instant now = Instant.now(); // For timestamps
        LocalDate today = LocalDate.now(); // For date only
        LocalDateTime dateTime = LocalDateTime.now(); // For date and time
        ZonedDateTime zonedDateTime = ZonedDateTime.now(); // With timezone

        // Immutable operations are safer
        LocalDate tomorrow = today.plusDays(1);
        LocalDateTime nextHour = dateTime.plusHours(1);
    }
}
]]>
        </example>
    </rule>

    <rule name="ReturnEmptyCollectionRatherThanNull"
          language="java"
          since="6.37.0"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          message="'null' 대신 빈 컬렉션을 반환하세요."
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#returnemptycollectionratherthannull">
        <description>
컬렉션(배열, Collection 또는 Map 등)을 반환하는 모든 메서드에서는 null 참조 대신 빈 컬렉션을 반환하는 것이 좋습니다.
이렇게 하면 모든 결과에 대한 null 검사가 불필요해지고 의도치 않은 NullPointerException을 방지할 수 있습니다.

Effective Java, 3판, 항목 54: null 대신 빈 컬렉션이나 배열을 반환하라 참조
        </description>
        <priority>1</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//ReturnStatement/NullLiteral
[ancestor::MethodDeclaration[1]
    [ArrayType
     or ClassType[pmd-java:typeIs('java.util.Collection')
        or pmd-java:typeIs('java.util.Map')]]
]
[not(./ancestor::LambdaExpression)]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Example {
    // Not a good idea...
    public int[] badBehavior() {
        // ...
        return null;
    }

    // Good behavior
    public String[] bonnePratique() {
        //...
        return new String[0];
    }
}
]]>
        </example>
    </rule>

    <rule name="ReturnFromFinallyBlock"
          language="java"
          since="1.05"
          message="finally 블록에서 반환하는 것을 피하세요"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#returnfromfinallyblock">
        <description>
finally 블록에서 반환하는 것을 피하세요. 이는 예외를 무시할 수 있습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>//FinallyClause//ReturnStatement except //FinallyClause//(MethodDeclaration|LambdaExpression)//ReturnStatement</value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Bar {
    public String foo() {
        try {
            throw new Exception( "My Exception" );
        } catch (Exception e) {
            throw e;
        } finally {
            return "A. O. K."; // return not recommended here
        }
    }
}
]]>
        </example>
    </rule>

    <rule name="SimpleDateFormatNeedsLocale"
          language="java"
          since="2.0"
          message="SimpleDateFormat 객체를 생성할 때 Locale을 지정하세요"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#simpledateformatneedslocale">
        <description>
SimpleDateFormat 인스턴스를 생성할 때 로캘에 적합한 형식이 사용되도록 Locale을 지정하세요.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//ConstructorCall
    [pmd-java:typeIs('java.text.SimpleDateFormat')]
    [ArgumentList/@Size = 1]
]]>
                    </value>
                </property>
            </properties>
        <example>
<![CDATA[
public class Foo {
  // Should specify Locale.US (or whatever)
  private SimpleDateFormat sdf = new SimpleDateFormat("pattern");
}
]]>
        </example>
    </rule>

    <rule name="SingleMethodSingleton"
          language="java"
          since="5.4"
          message="클래스에 여러 개의 getInstance 메서드가 있습니다. 검토해 주세요."
          class="net.sourceforge.pmd.lang.java.rule.errorprone.SingleMethodSingletonRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#singlemethodsingleton">
        <description>
일부 클래스에는 오버로드된 getInstance가 포함되어 있습니다. 오버로드된 getInstance 메서드의 문제는
오버로드된 메서드를 사용하여 생성된 인스턴스가 캐시되지 않아
매 호출마다 새 객체가 생성된다는 것입니다.
        </description>
        <priority>2</priority>
        <example>
<![CDATA[
public class Singleton {

    private static Singleton singleton = new Singleton( );

    private Singleton(){ }

    public static Singleton getInstance( ) {
        return singleton;
    }

    public static Singleton getInstance(Object obj){
        Singleton singleton = (Singleton) obj;
        return singleton;           //violation
    }
}
]]>
        </example>
    </rule>

    <rule name="SingletonClassReturningNewInstance"
          language="java"
          since="5.4"
          message="getInstance 메서드가 항상 새 객체를 생성하여 싱글턴 디자인 패턴 동작을 준수하지 않습니다. 검토해 주세요"
          class="net.sourceforge.pmd.lang.java.rule.errorprone.SingletonClassReturningNewInstanceRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#singletonclassreturningnewinstance">
        <description>
싱글턴 클래스는 하나의 인스턴스만 가져야 합니다. 인스턴스가 이미 생성되었는지
확인하지 않으면 여러 인스턴스가 생성될 수 있습니다.
        </description>
        <priority>2</priority>
        <example>
<![CDATA[
class Singleton {
    private static Singleton instance = null;
    public static Singleton getInstance() {
        synchronized(Singleton.class) {
            return new Singleton(); // this should be assigned to the field
        }
    }
}
]]>
        </example>
    </rule>

    <rule name="StaticEJBFieldShouldBeFinal"
          language="java"
          since="4.1"
          message="EJB는 non-final static 필드를 가져서는 안 됩니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#staticejbfieldshouldbefinal">
        <description>
J2EE 사양에 따르면, EJB는 쓰기 접근이 가능한 static 필드를 가져서는 안 됩니다.
그러나 static 읽기 전용 필드는 허용됩니다. 이는 컨테이너가 여러 JRE에
인스턴스를 분산할 때 올바른 동작을 보장합니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//ClassDeclaration[ImplementsList/ClassType[
        pmd-java:typeIs('javax.ejb.SessionBean')
     or pmd-java:typeIs('javax.ejb.EJBHome')
     or pmd-java:typeIs('javax.ejb.EJBLocalObject')
     or pmd-java:typeIs('javax.ejb.EJBLocalHome')
     or pmd-java:typeIs('javax.ejb.EJBObject')
    ]]
    /ClassBody/FieldDeclaration
        [pmd-java:modifiers() = 'static']
        [not(pmd-java:modifiers() = 'final')]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class SomeEJB extends EJBObject implements EJBLocalHome {

    private static int CountA;          // poor, field can be edited

    private static final int CountB;    // preferred, read-only access
}
]]>
        </example>
    </rule>

    <rule name="StringBufferInstantiationWithChar"
          language="java"
          since="3.9"
          message="`new StringBuilder()` 또는 `new StringBuffer()`의 인수가 char에서 int로 암시적으로 변환됩니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#stringbufferinstantiationwithchar">
        <description>
초기화 인수로 제공된 개별 문자 값은 정수로 변환됩니다.
이로 인해 예상보다 큰 내부 버퍼 크기가 발생할 수 있습니다. 예시:

```
new StringBuffer()      //  16
new StringBuffer(6)     //  6
new StringBuffer("hello world")  // 11 + 16 = 27
new StringBuffer('A')   //  chr(A) = 65
new StringBuffer("A")   //  1 + 16 = 17

new StringBuilder()     //  16
new StringBuilder(6)    //  6
new StringBuilder("hello world")  // 11 + 16 = 27
new StringBuilder('C')   //  chr(C) = 67
new StringBuilder("A")   //  1 + 16 = 17
```
        </description>
        <priority>4</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//ConstructorCall[ArgumentList/*[pmd-java:typeIsExactly('char')]]
    [pmd-java:matchesSig('java.lang.StringBuilder#new(int)')
     or pmd-java:matchesSig('java.lang.StringBuffer#new(int)')]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
// misleading instantiation, these buffers
// are actually sized to 99 characters long
StringBuffer  sb1 = new StringBuffer('c');
StringBuilder sb2 = new StringBuilder('c');

// in these forms, just single characters are allocated
StringBuffer  sb3 = new StringBuffer("c");
StringBuilder sb4 = new StringBuilder("c");
]]>
        </example>
    </rule>

    <rule name="SuspiciousEqualsMethodName"
          language="java"
          since="2.0"
          message="메서드 이름과 매개변수 수가 equals(Object)와 의심스럽게 유사합니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#suspiciousequalsmethodname">
        <description>
메서드 이름과 매개변수 수가 `Object.equals`와 의심스럽게 유사하여 이를 재정의하려는 의도를 나타낼 수 있습니다.
그러나 이 메서드는 `Object.equals`를 재정의하지 않고 오버로드합니다.
`Object.equals` 메서드를 오버로드하는 것은 다른 프로그래머에게 혼란을 주고, 오류가 발생하기 쉬우며 유지보수가 어렵습니다.
특히 상속을 사용할 때 하위 클래스에서 사용되는 `@Override` 어노테이션이 잘못된 안정감을 줄 수 있습니다.
`Object.equals` 메서드에 대한 자세한 내용은 Effective Java, 3판, 항목 10: equals를 재정의할 때는
일반 규약을 따르라를 참조하세요.
        </description>
        <priority>2</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//MethodDeclaration[@Name = 'equals'][
    (@Arity = 1
     and not(FormalParameters/FormalParameter[pmd-java:typeIsExactly('java.lang.Object')])
     or not(PrimitiveType[@Kind = 'boolean'])
    ) or (
     @Arity = 2
     and PrimitiveType[@Kind = 'boolean']
     and FormalParameters/FormalParameter[pmd-java:typeIsExactly('java.lang.Object')]
     and not(pmd-java:hasAnnotation('java.lang.Override'))
    )
]
| //MethodDeclaration[@Name = 'equal'][
    @Arity = 1
    and FormalParameters/FormalParameter[pmd-java:typeIsExactly('java.lang.Object')]
]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Foo {
   public int equals(Object o) {
     // oops, this probably was supposed to be boolean equals
   }
   public boolean equals(String s) {
     // oops, this probably was supposed to be equals(Object)
   }
   public boolean equals(Object o1, Object o2) {
     // oops, this probably was supposed to be equals(Object)
   }
}
]]>
        </example>
    </rule>

    <rule name="SuspiciousHashcodeMethodName"
          language="java"
          since="1.5"
          message="메서드 이름과 반환 타입이 hashCode()와 의심스럽게 유사합니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#suspicioushashcodemethodname">
        <description>
메서드 이름과 반환 타입이 hashCode()와 의심스럽게 유사하여 hashCode() 메서드를 재정의하려는 의도를 나타낼 수 있습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//MethodDeclaration[
        lower-case(@Name) = 'hashcode'
    and @Name != 'hashCode'
    and @Arity = 0
    and PrimitiveType[@Kind = 'int']
]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Foo {
    public int hashcode() { // oops, this probably was supposed to be 'hashCode'
    }
}
]]>
        </example>
    </rule>

    <rule name="SuspiciousOctalEscape"
          language="java"
          since="1.5"
          message="문자열 리터럴에서 8진수 이스케이프 뒤에 의심스러운 십진수 문자가 있습니다: {0}"
          class="net.sourceforge.pmd.lang.java.rule.errorprone.SuspiciousOctalEscapeRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#suspiciousoctalescape">
        <description>
문자열 리터럴 내에서 의심스러운 8진수 이스케이프 시퀀스가 발견되었습니다.
Java 언어 사양(섹션 3.10.6)에 따르면 리터럴 문자열 내의 8진수
이스케이프 시퀀스는 백슬래시 뒤에 다음이 와야 합니다:

    OctalDigit | OctalDigit OctalDigit | ZeroToThree OctalDigit OctalDigit

8진수 이스케이프 시퀀스 뒤에 8진수가 아닌 숫자가 오면 혼란을 줄 수 있습니다.
예를 들어 "\038"은 8진수 이스케이프 시퀀스 "\03" 뒤에 리터럴 문자 "8"이
오는 것으로 해석됩니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
public void foo() {
  // interpreted as octal 12, followed by character '8'
  System.out.println("suspicious: \128");
}
]]>
        </example>
    </rule>

    <rule name="TestClassWithoutTestCases"
          language="java"
          since="3.0"
          message="클래스 ''{0}''은(는) 테스트 클래스일 수 있지만 테스트 케이스가 없습니다."
          class="net.sourceforge.pmd.lang.java.rule.errorprone.TestClassWithoutTestCasesRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#testclasswithouttestcases">
        <description>
테스트 클래스는 일반적으로 "Test", "Tests" 또는 "TestCase" 접두사나 접미사로 시작하거나 끝납니다. 해당 이름을 가진 비테스트 클래스는
좋은 관행이 아닙니다. 대부분의 사람들이 테스트 케이스라고 가정하기 때문입니다. 테스트 클래스에는
"testXXX"(JUnit3)라는 이름의 테스트 메서드가 있거나 어노테이션(예: `@Test`)을 사용합니다.

매칭할 정규식은 testClassPattern 속성을 사용하여 구성할 수 있습니다. 이름에 의한
테스트 클래스 감지를 비활성화하려면 이 속성을 빈 문자열로 설정하세요.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
//Consider changing the name of the class if it is not a test
//Consider adding test methods if it is a test
public class CarTest {
   public static void main(String[] args) {
    // do something
   }
   // code
}
]]>
        </example>
    </rule>


    <rule name="UnconditionalIfStatement"
          language="java"
          since="1.5"
          message="항상 true이거나 항상 false인 'if' 문을 사용하지 마세요"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#unconditionalifstatement">
        <description>
조건이 항상 true이거나 항상 false인 "if" 문을 사용하지 마세요.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
 <![CDATA[
//IfStatement[BooleanLiteral[1]]
union
//IfStatement/(VariableAccess|UnaryExpression[@Operator = '!']/VariableAccess)/self::VariableAccess[@CompileTimeConstant = false()]
[@Name = ancestor::IfStatement
         /preceding-sibling::LocalVariableDeclaration[PrimitiveType[@Kind = "boolean"]]
         /VariableDeclarator[@Initializer = true()][BooleanLiteral]
         /@Name]
(: var is only initialized with a literal and used only with the if statement, there is no other var access :)
[let $name := @Name return count(ancestor::Block//VariableAccess[@Name = $name]) = 1]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Foo {
    public void close() {
        if (true) {        // fixed conditional, not recommended
            // ...
        }
    }
}
]]>
        </example>
    </rule>

    <rule name="UnnecessaryBooleanAssertion"
          language="java"
          since="3.0"
          message="assertTrue(true) 또는 유사한 문은 불필요합니다"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#unnecessarybooleanassertion">
        <description>
boolean 리터럴을 사용한 JUnit 테스트 단언은 항상 같은 값으로 평가되므로 불필요합니다.
흐름 제어를 사용하거나(`assertTrue(false)` 또는 유사한 경우) `assertTrue(true)` 및 `assertFalse(false)` 같은
문을 단순히 제거하는 것을 고려하세요. 오류를 발견한 후 테스트를 중단하려면 `fail()` 메서드를
사용하고 왜 중단되었는지에 대한 표시 메시지를 제공하세요.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//ClassDeclaration
    [pmd-java:typeIs('junit.framework.TestCase')
     or .//Annotation[pmd-java:typeIs('org.junit.Test')
                   or pmd-java:typeIs('org.junit.jupiter.api.Test')
                   or pmd-java:typeIs('org.junit.jupiter.api.RepeatedTest')
                   or pmd-java:typeIs('org.junit.jupiter.api.TestFactory')
                   or pmd-java:typeIs('org.junit.jupiter.api.TestTemplate')
                   or pmd-java:typeIs('org.junit.jupiter.params.ParameterizedTest')
     ]
    ]
    //MethodCall[@MethodName = ('assertTrue', 'assertFalse')]
        [ArgumentList
            [
                BooleanLiteral or
                UnaryExpression[@Operator = '!'][BooleanLiteral]
            ]
        ]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class SimpleTest extends TestCase {
    public void testX() {
        assertTrue(true);            // serves no real purpose - remove it
    }
}
]]>
        </example>
    </rule>

    <rule name="UnnecessaryCaseChange"
          language="java"
          since="3.3"
          message="toUpperCase/toLowerCase().equals() 대신 equalsIgnoreCase()를 사용하는 것이 더 깔끔합니다."
          class="net.sourceforge.pmd.lang.java.rule.errorprone.UnnecessaryCaseChangeRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#unnecessarycasechange">
        <description>
toUpperCase/toLowerCase().equals()를 사용하는 것보다 equalsIgnoreCase()를 사용하는 것이 더 빠릅니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
boolean answer1 = buz.toUpperCase().equals("BAZ");              // should be buz.equalsIgnoreCase("BAZ")

boolean answer2 = buz.toUpperCase().equalsIgnoreCase("BAZ");    // another unnecessary toUpperCase()
]]>
        </example>
    </rule>

    <rule name="UnnecessaryConversionTemporary"
          language="java"
          since="0.1"
          message="기본 타입을 문자열로 변환할 때 불필요한 임시 객체를 피하세요"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#unnecessaryconversiontemporary">
        <description>
기본 타입을 문자열로 변환할 때 임시 객체를 사용하지 마세요. 대신 래퍼 클래스의 정적 변환 메서드를 사용하세요.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//MethodCall[@MethodName = 'toString']
    [ConstructorCall[position() = 1]
        [
            pmd-java:typeIs('java.lang.Integer')
         or pmd-java:typeIs('java.lang.Long')
         or pmd-java:typeIs('java.lang.Float')
         or pmd-java:typeIs('java.lang.Byte')
         or pmd-java:typeIs('java.lang.Double')
         or pmd-java:typeIs('java.lang.Short')
        ]
    ]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public String convert(int x) {
    String foo = new Integer(x).toString(); // this wastes an object

    return Integer.toString(x);             // preferred approach
}
]]>
        </example>
    </rule>

    <rule name="UnsupportedJdkApiUsage"
          language="java"
          since="7.21.0"
          message="지원되지 않는 JDK API를 사용하지 마세요"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#unsupportedjdkapiusage">
        <description>
`sun.*` 또는 `jdk.internal.*` 패키지의 클래스를 임포트하거나 API를 사용하는 것을 피하세요.
`sun.misc.Unsafe` 또는 `jdk.internal.misc.Unsafe`를 포함합니다. 이 패키지들은 이식성이 없고 안정적이지 않으며
향후 JDK 버전에서 변경되거나 제거될 수 있습니다. 이름에서 알 수 있듯이, `Unsafe` 클래스의 메서드는 특히 위험하며
VarHandle API(JDK 9에서 도입)와 Foreign Function &amp; Memory API(JDK 22에서 도입) 같은
더 안전한 대안으로 대체되었습니다. 예제가 포함된 더 안전한 대안은 [JEP 471](https://openjdk.org/jeps/471)을 참조하세요.

Sun API에 의존해야 하는 경우, 안정적인 래퍼 클래스 내부와 같이 최소한의 격리된 범위에 사용을 제한하세요.
이러한 래퍼의 구현에서 이 규칙을 억제할 수 있지만, 가능한 한 공식 API로 마이그레이션하는 것이
강력히 권장됩니다.

이러한 지원되지 않는 API의 사용은 내부 용도로만 의도되었으므로 Java 컴파일러에 의해서도
경고됩니다. 이 PMD 규칙은 독립적인 코드 검토를 용이하게 하고 컴파일러 경고가
간과되었을 수 있는 인스턴스를 포착하기 위해 추가되었습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
                    //ImportDeclaration[starts-with(@ImportedName, 'sun.') or starts-with(@ImportedName, 'jdk.internal.')]
                    |
                    //MethodCall[pmd-java:matchesSig('sun.misc.Unsafe#_(_*)') or pmd-java:matchesSig('jdk.internal.misc.Unsafe#_(_*)')]
                </value>
            </property>
        </properties>
        <example>
            <![CDATA[
public final class MemoryWiper {
  public static void main(final String[] args) throws NoSuchFieldException, IllegalAccessException {
    for (final String s : args) {
      sun.misc.Unsafe.getUnsafe().putAddress(Long.parseLong(s), 0L); // bad
    }
  }
}
]]>
        </example>
    </rule>

    <rule name="UnusedNullCheckInEquals"
          language="java"
          since="3.5"
          message="이미 null이 아님을 확인한 객체에 대해 equals()를 호출하세요"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#unusednullcheckinequals">
        <description>
객체 참조가 null인지 확인한 후에는, 그 객체를 다른 객체의 equals() 메서드에 전달하는 것이 아니라
해당 객체에서 equals()를 호출해야 합니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//InfixExpression[@Operator = '&&']
  /MethodCall[pmd-java:matchesSig("java.lang.Object#equals(java.lang.Object)")]
             [not(StringLiteral)]
             [not(VariableAccess[@CompileTimeConstant = true()])]
             [ArgumentList/VariableAccess/@Name = ..//InfixExpression[@Operator = '!='][NullLiteral]/VariableAccess/@Name]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Test {

    public String method1() { return "ok";}
    public String method2() { return null;}

    public void method(String a) {
        String b;
        // I don't know it method1() can be "null"
        // but I know "a" is not null..
        // I'd better write a.equals(method1())

        if (a!=null && method1().equals(a)) { // will trigger the rule
            //whatever
        }

        if (method1().equals(a) && a != null) { // won't trigger the rule
            //whatever
        }

        if (a!=null && method1().equals(b)) { // won't trigger the rule
            //whatever
        }

        if (a!=null && "LITERAL".equals(a)) { // won't trigger the rule
            //whatever
        }

        if (a!=null && !a.equals("go")) { // won't trigger the rule
            a=method2();
            if (method1().equals(a)) {
                //whatever
            }
        }
    }
}
]]>
        </example>
    </rule>

    <rule name="UseCorrectExceptionLogging"
          language="java"
          since="3.2"
          message="예외 로깅에 올바른 로깅 문을 사용하세요"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#usecorrectexceptionlogging">
        <description>
전체 스택 트레이스가 출력되도록 하려면 String과 Throwable 두 개의 인수를 가진 로깅 문을 사용하세요.

이 규칙은 [Apache Commons Logging](https://commons.apache.org/proper/commons-logging/)에만 적용됩니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//CatchClause/Block//MethodCall
    [pmd-java:matchesSig('org.apache.commons.logging.Log#_(java.lang.Object)')]
    [ArgumentList[not(MethodCall)]//VariableAccess/@Name = ancestor::CatchClause/CatchParameter/@Name]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Main {
    private static final Log _LOG = LogFactory.getLog( Main.class );
    void bar() {
        try {
        } catch( Exception e ) {
            _LOG.error( e ); //Wrong!
        } catch( OtherException oe ) {
            _LOG.error( oe.getMessage(), oe ); //Correct
        }
    }
}
]]>
        </example>
    </rule>

    <rule name="UseEqualsToCompareStrings"
          language="java"
          since="4.1"
          message="'==' 또는 '!=' 대신 equals()를 사용하여 문자열을 비교하세요"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#useequalstocomparestrings">
        <description>
'==' 또는 '!='를 사용하여 문자열을 비교하는 것은 양쪽 모두에 인턴된 문자열(`String#intern()`)을
사용하는 경우에만 신뢰할 수 있습니다.

대신 `equals()` 메서드를 사용하세요.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//InfixExpression[@Operator = ('==', '!=')]
                 [count(*[pmd-java:typeIsExactly('java.lang.String')]) = 2]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
public boolean test(String s) {
    if (s == "one") return true;        // unreliable
    if ("two".equals(s)) return true;   // better
    return false;
}
]]>
        </example>
    </rule>

    <rule name="UselessOperationOnImmutable"
          language="java"
          since="3.5"
          message="불변 객체에 대한 연산 결과가 무시됩니다"
          class="net.sourceforge.pmd.lang.java.rule.errorprone.UselessOperationOnImmutableRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#uselessoperationonimmutable"
          deprecated="true">
        <description>
불변 객체에 대한 연산은 연산 결과가 새로운 객체이므로 객체 자체를 변경하지 않습니다.
따라서 이러한 연산의 결과를 무시하는 것은 아마도 실수입니다. 해당 연산을 제거할 수 있을 것입니다.

이 규칙은 `String`, `BigDecimal`, `BigInteger` 또는 `java.time.*`의 모든 타입을 불변으로 인식합니다.

**더 이상 사용되지 않음:** 이 규칙은 PMD 7.17.0부터 더 이상 사용되지 않으며 PMD 8.0.0에서 제거됩니다.
이 규칙은 {% rule UselessPureMethodCall %}로 대체되었습니다.
        </description>
        <priority>3</priority>
        <example>
<![CDATA[
import java.math.*;

class Test {
    void method1() {
        BigDecimal bd=new BigDecimal(10);
        bd.add(new BigDecimal(5));      // this will trigger the rule
    }
    void method2() {
        BigDecimal bd=new BigDecimal(10);
        bd = bd.add(new BigDecimal(5)); // this won't trigger the rule
    }
}
]]>
        </example>
    </rule>

    <rule name="UselessPureMethodCall"
          language="java"
          since="7.17.0"
          message="결과가 사용되지 않는 순수 메서드 {0}을(를) 호출하지 마세요."
          class="net.sourceforge.pmd.lang.java.rule.errorprone.UselessPureMethodCallRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#uselesspuremethodcall">
        <description>
이 규칙은 결과가 사용되지 않는 순수 메서드 호출을 감지합니다. 순수 메서드는 부작용이 없는 메서드입니다.
따라서 이러한 메서드 호출의 결과를 무시하는 것은 아마도 실수입니다.

메서드 호출을 제거하거나 결과를 사용해야 합니다.
        </description>
        <priority>3</priority>
        <example>
            <![CDATA[
public class Something {
    public void foo() {
        List.of("foo").size(); // result unused
        Stream.of("bar").map(item -> System.out.format("%s", item)); // result unused
        Stream.of("bar").forEach(item -> System.out.format("%s", item)); // better
    }
}
]]>
        </example>
    </rule>

    <rule name="UseLocaleWithCaseConversions"
          language="java"
          since="2.0"
          message="String.toLowerCase()/toUpperCase() 호출 시 Locale을 사용하세요"
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#uselocalewithcaseconversions">
        <description>
`String::toLowerCase()/toUpperCase()` 변환을 수행할 때 대소문자 변환 규칙을 지정하기 위해
명시적 locale 인수를 사용하세요.

인수 없이 `String::toLowerCase()`를 사용하면 암시적으로 `Locale::getDefault()`를 사용합니다.
문제는 기본 로캘이 현재 JVM 설정(보통 실행 중인 시스템)에 따라 달라진다는 것입니다.
시스템 기본값을 사용하는 것이 정확히 원하는 것일 수 있지만(예: 표준 입력을 통해 받은 문자열을 조작하는 경우),
그렇지 않을 수도 있습니다(예: 네트워크나 파일을 통해 문자열을 받고 인코딩이 환경과 무관하게
잘 정의된 경우). 후자의 경우, 기본 로캘을 사용하면 다른 대소문자 변환 규칙을 가진
로캘의 시스템에서 예상치 못한 결과를 낼 수 있어 대소문자 변환이 불안정해집니다.
예를 들어 터키어에서 `i`의 대문자 형태는 영어에서의 `I`(U+0049)가 아닌 `\u0130`(U+0130, 비ASCII)입니다.

이 규칙은 문자열을 다룰 때 개발자가 로캘에 대해 생각하도록 *강제*하기 위한 것입니다.
작성 시점에 로캘 선택에 대한 의식적인 결정을 내림으로써, 나중에 놀라운 동작의 위험을 줄이고
미래의 독자에게 의도를 전달할 수 있습니다.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//MethodCall[pmd-java:matchesSig("java.lang.String#toLowerCase()") or pmd-java:matchesSig("java.lang.String#toUpperCase()")]
            [not(MethodCall[@MethodName = "toHexString"])]
]]>
                </value>
            </property>
        </properties>
        <example>
<![CDATA[
// violation - implicitly system-dependent conversion
if (x.toLowerCase().equals("list")) {}

// The above will not match "LIST" on a system with a Turkish locale.
// It could be replaced with
if (x.toLowerCase(Locale.US).equals("list")) { }
// or simply
if (x.equalsIgnoreCase("list")) { }

// ok - system independent conversion
String z = a.toLowerCase(Locale.ROOT);

// ok - explicit system-dependent conversion
String z2 = a.toLowerCase(Locale.getDefault());
]]>
        </example>
    </rule>

    <rule name="UseProperClassLoader"
          language="java"
          since="3.7"
          message="J2EE에서 getClassLoader()가 예상대로 동작하지 않을 수 있습니다. 대신 Thread.currentThread().getContextClassLoader()를 사용하세요."
          class="net.sourceforge.pmd.lang.rule.xpath.XPathRule"
          externalInfoUrl="${pmd.website.baseurl}/pmd_rules_java_errorprone.html#useproperclassloader">
        <description>
J2EE에서 getClassLoader() 메서드가 예상대로 동작하지 않을 수 있습니다.
대신 Thread.currentThread().getContextClassLoader()를 사용하세요.
        </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>//MethodCall[pmd-java:matchesSig("java.lang.Class#getClassLoader()")]</value>
            </property>
        </properties>
        <example>
<![CDATA[
public class Foo {
    ClassLoader cl = Bar.class.getClassLoader();
}
]]>
        </example>
    </rule>

</ruleset>