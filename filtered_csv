name,category,description
AvoidReassigningParameters,bestpractices,"메서드나 생성자의 입력 매개변수에 값을 재할당하는 것은 권장되지 않습니다. 이는 코드를 이해하기
더 어렵게 만들 수 있기 때문입니다. 코드는 대개 매개변수 값이 변경되지 않는다는 가정 하에 읽히며,
할당은 최소 놀람 원칙을 위반합니다. 이는 특히 매개변수가 메서드의 javadoc 등에 문서화되어 있고
새 내용이 원래 문서화된 내용과 다른 경우에 문제가 됩니다.

대신 임시 지역 변수를 사용하십시오. 이를 통해 새 이름을 할당할 수 있어 코드를 더 잘 이해할 수 있습니다.

이 규칙은 메서드와 생성자를 모두 고려합니다. 형식 매개변수에 대한 할당이 여러 개인 경우,
첫 번째 할당만 보고됩니다."
GuardLogStatement,bestpractices,"로그 레벨을 사용할 때마다 실제로 활성화되어 있는지 확인하거나, 그렇지 않으면 관련 문자열 생성 및
조작과 메서드 호출을 건너뛰어야 합니다.

로그 레벨 확인의 대안으로 매개변수 치환, 포맷터 또는 람다를 사용한 지연 로깅이 있습니다.
사용 가능한 대안은 실제 로깅 프레임워크에 따라 다릅니다."
ImplicitFunctionalInterface,bestpractices,"`@FunctionalInterface` 어노테이션으로 명시적으로 선언되지 않은 함수형 인터페이스를 보고합니다.
            인터페이스가 우연히 함수형 인터페이스인 경우, 이를 명확히 하기 위해
            `@SuppressWarnings(&quot;PMD.ImplicitFunctionalInterface&quot;)` 어노테이션을 추가해야 합니다."
AbstractClassWithoutAbstractMethod,bestpractices,"추상 클래스에 추상 메서드가 포함되어 있지 않습니다. 추상 클래스는 불완전한 구현을 나타내며,
하위 클래스에서 추상 메서드를 구현하여 완성해야 합니다. 클래스가 기본 클래스로만 사용되도록
의도된 경우(직접 인스턴스화하지 않음), protected 생성자를 제공하여 직접 인스턴스화를 방지할 수 있습니다."
AccessorClassGeneration,bestpractices,"생성자의 클래스 외부에서 private 생성자를 통해 인스턴스화하면 접근자(accessor)가 생성되는 경우가 많습니다.
팩토리 메서드를 사용하거나 생성자를 non-private로 변경하면 이 상황을 제거할 수 있습니다.
생성된 클래스 파일은 실제로 인터페이스입니다. 이는 접근하는 클래스에게 인터페이스를 보조 매개변수로
받는 새로운 숨겨진 패키지 범위 생성자를 호출할 수 있는 능력을 부여합니다.
이로 인해 private 생성자가 사실상 패키지 범위를 가진 것처럼 되어 식별하기 어렵습니다.

_참고:_ 이 규칙은 Java 10 이하에서만 실행됩니다.
Java 11부터 [JEP 181: Nest-Based Access Control](https://openjdk.org/jeps/181)이 구현되었습니다.
즉, Java 11 이상에서는 접근자 클래스가 더 이상 생성되지 않습니다."
AccessorMethodGeneration,bestpractices,"다른 클래스에서 private 필드/메서드에 접근할 때, Java 컴파일러는 패키지-private 가시성을 가진 접근자 메서드를
생성합니다. 이는 오버헤드를 추가하고 Android에서는 dex 메서드 수에 영향을 줍니다.
필드/메서드의 가시성을 private에서 패키지-private로 변경하면 이 상황을 피할 수 있습니다.


_참고:_ 이 규칙은 Java 10 이하에서만 실행됩니다.
Java 11부터 [JEP 181: Nest-Based Access Control](https://openjdk.org/jeps/181)이 구현되었습니다.
즉, Java 11 이상에서는 접근자 클래스가 더 이상 생성되지 않습니다."
ArrayIsStoredDirectly,bestpractices,"배열을 받는 생성자와 메서드는 객체를 복제하여 복사본을 저장해야 합니다.
이렇게 하면 사용자의 향후 변경이 원본 배열에 영향을 미치는 것을 방지할 수 있습니다."
AvoidMessageDigestField,bestpractices,"MessageDigest 인스턴스를 필드로 선언하면 이 인스턴스가 여러 스레드에서 직접 사용 가능하게 됩니다.
            이러한 MessageDigest 인스턴스의 공유는 접근이 올바르게 동기화되지 않으면 잘못된 결과를 초래하므로
            가능하면 피해야 합니다.
            필요한 곳에서 새 인스턴스를 생성하여 로컬로 사용하십시오.
            새 인스턴스를 생성하는 것이 공유 인스턴스에 대한 접근을 동기화하는 것보다 쉽습니다."
AvoidPrintStackTrace,bestpractices,printStackTrace() 사용을 피하고 대신 로거 호출을 사용하십시오.
AvoidReassigningCatchVariables,bestpractices,"catch 문에서 잡은 예외 변수의 재할당은 다음과 같은 이유로 피해야 합니다:

1) 필요한 경우, 멀티 catch를 쉽게 추가할 수 있으며 코드는 여전히 컴파일됩니다.

2) 최소 놀람 원칙에 따라, catch 문에서 잡은 변수가 항상 try 블록에서 던져진 것과 동일하도록 보장하고자 합니다."
AvoidReassigningLoopVariables,bestpractices,"루프 변수의 재할당은 찾기 어려운 버그를 유발할 수 있습니다. 이러한 변수가 변경될 수 있는 방식을 방지하거나 제한하십시오.

foreach 루프에서, `foreachReassign` 속성으로 설정:
- `deny`: 루프 본문에서 루프 변수의 모든 재할당을 보고합니다. _이것이 기본값입니다._
- `allow`: 루프 변수를 검사하지 않습니다.
- `firstOnly`: 루프 본문의 첫 번째 문을 제외한 루프 변수의 모든 재할당을 보고합니다.
            _사용 전 값의 정규화나 정리가 허용되지만 변수의 다른 변경은 허용되지 않는 경우에 유용합니다._

for 루프에서, `forReassign` 속성으로 설정:
- `deny`: 루프 본문에서 제어 변수의 모든 재할당을 보고합니다. _이것이 기본값입니다._
- `allow`: 제어 변수를 검사하지 않습니다.
- `skip`: 조건부 증감(`++`, `--`, `+=`, `-=`)을 제외한 제어 변수의 모든 재할당을 보고합니다.
            _제어 변수의 우발적 재할당이나 무조건적 증가를 방지합니다._"
AvoidStringBufferField,bestpractices,"StringBuffer/StringBuilder는 상당히 커질 수 있으므로 수명이 긴 객체 내에 보관될 경우
메모리 누수의 원인이 될 수 있습니다."
AvoidUsingHardCodedIP,bestpractices,"하드코딩된 IP 주소가 있는 애플리케이션은 경우에 따라 배포가 불가능해질 수 있습니다.
IP 주소를 외부화하는 것이 바람직합니다."
CheckResultSet,bestpractices,"ResultSet의 탐색 메서드(next, previous, first, last)의 반환값을 항상 확인하십시오.
반환값이 'false'인 경우 적절하게 처리해야 합니다."
ConstantsInInterface,bestpractices,"인터페이스에서 상수를 사용하는 것은 나쁜 관행입니다. 인터페이스는 타입을 정의하며, 상수는 클래스나 열거형에 배치하는 것이 더 나은 구현 세부사항입니다. 상수가 열거 타입의 멤버로 가장 잘 볼 수 있다면 enum 타입으로 내보내야 합니다.
다른 시나리오에서는 유틸리티 클래스 사용을 고려하십시오. Effective Java의 '인터페이스는 타입 정의용으로만 사용하라'를 참조하십시오."
DoubleBraceInitialization,bestpractices,"이중 중괄호 초기화는 컬렉션 등을 간결하게 초기화하는 패턴입니다. 그러나 이는 암묵적으로
            새로운 .class 파일을 생성하며, 객체는 둘러싸는 객체에 대한 강한 참조를 보유합니다.
            이러한 이유로 비록 장황하더라도 객체를 정상적으로 초기화하는 것이 바람직합니다.

            이 규칙은 단일 초기화 블록만 있는 익명 클래스를 이중 중괄호 초기화의 인스턴스로 간주합니다.
            현재 초기화 블록에서 호출된 메서드가 익명 클래스 외부에서 접근 가능한지 여부를 판단할 방법이 없으며,
            그러한 합법적인 경우는 당분간 억제해야 합니다."
EnumComparison,bestpractices,"열거형을 비교할 때 `equals()`는 피하고 `==`를 사용하는 것이 좋습니다.

`==` 사용의 장점:
* `equals()`와 동일한 의미
* 잠재적인 null 포인터 예외에 대한 문제가 적음
* 정적 타입 검사 지원: 호환되지 않는 두 열거형 타입을 비교하면 컴파일러가 알려줍니다.
  equals를 사용하면 런타임에서만 알 수 있거나 전혀 알 수 없습니다.

이 규칙은 SonarSource 규칙 [S4551](https://sonarsource.github.io/rspec/#/rspec/S4551)을 구현합니다.

참고로, 원시 타입과 열거형만 `==`를 사용하여 비교해야 합니다. 다른 객체를 비교하려면
`equals()`가 올바른 방법입니다. {%rule java/errorprone/CompareObjectsWithEquals %}
및 {%rule java/errorprone/UseEqualsToCompareStrings %}을 참조하십시오."
ExhaustiveSwitchHasDefault,bestpractices,"열거형이나 봉인된 클래스에 대해 switch를 사용할 때, 컴파일러는 모든 가능한 케이스가 처리되는지 확인합니다.
케이스가 누락되면 컴파일 오류가 발생합니다. 그러나 default 케이스가 추가되면 이 컴파일러 검사가
더 이상 수행되지 않아 런타임에서 버그를 발견하기 어려워집니다.

default 케이스를 사용하지 않으면 새로운 열거형 상수나 봉인된 클래스 계층에 새 하위 클래스가
추가될 때마다 컴파일 오류가 발생합니다. 런타임이 아닌 컴파일 타임에 이 문제를 발견할 수 있습니다.

참고: 수정 방법이 단순히 default 케이스를 제거하는 것만은 아닙니다. 구현해야 할 누락된 케이스가 있을 수 있습니다."
ForLoopCanBeForeach,bestpractices,"안전하게 foreach 구문으로 대체할 수 있는 루프를 보고합니다. 이 규칙은 리스트, 배열 및 반복자에 대한
루프를 고려합니다. 루프가 인덱스 변수를 리스트나 배열의 요소에 접근하는 데만 사용하고,
업데이트 문이 하나만 있으며, 리스트나 배열의 *모든* 요소를 왼쪽에서 오른쪽으로 순회하는 경우에만
안전하게 대체할 수 있습니다."
ForLoopVariableCount,bestpractices,"'for' 루프에 제어 변수가 많으면 루프가 어떤 값 범위를 순회하는지 파악하기 어려워집니다.
기본적으로 이 규칙은 변수가 하나만 있는 일반 'for' 루프를 허용합니다."
JUnit4SuitesShouldUseSuiteAnnotation,bestpractices,"JUnit 3에서는 suite() 메서드로 테스트 스위트를 나타냅니다. JUnit 4에서는
@RunWith(Suite.class) 어노테이션으로 스위트를 나타냅니다."
LabeledStatement,bestpractices,"이 규칙은 레이블이 지정된 문의 사용을 감지합니다. 기본적으로 레이블이 있는 루프는 허용하여
레이블과 함께 `break` / `continue`를 사용할 수 있습니다. 이는 `allowLoops` 속성을 통해
모든 레이블을 감지하도록 변경할 수 있습니다.

레이블은 제어 흐름을 이해하기 어렵게 만들며 피해야 합니다. goto 문과 혼동될 수 있으며
코드를 읽고 유지보수하기 어렵게 만듭니다.

내부 루프에서 빠져나와야 하는 경우, 여러 루프를 함수로 리팩토링하는 것을 고려하십시오.
그러면 break를 return으로 대체할 수 있습니다.

이 규칙은 SonarSource 규칙 [S1119](https://sonarsource.github.io/rspec/#/rspec/S1119)를 구현합니다.

사용되지 않는 레이블을 감지하려면 {% rule UnusedLabel %} 규칙을 사용하십시오."
LiteralsFirstInComparisons,bestpractices,"모든 문자열 비교에서 리터럴을 먼저 배치하십시오. 두 번째 인수가 null이면 NullPointerException을
            피할 수 있으며, 단순히 false를 반환합니다. compareTo 및 compareToIgnoreCase에서
            리터럴 위치를 바꾸면 결과가 변경될 수 있으니 예제를 참조하십시오.

            컴파일 타임 상수 문자열은 리터럴과 동일하게 취급됩니다. 이는 클래스 파일에 인라인되어
            반드시 null이 아니므로 런타임에 NPE를 발생시킬 수 없기 때문입니다."
LooseCoupling,bestpractices,"구현 타입(예: `HashSet`)에 대한 과도한 결합은 요구사항이 변경될 때 대체 구현을 사용하는 능력을
제한합니다. 가능한 경우, 보다 일반적인 타입(예: `Set`)을 사용하여 변수와 매개변수를 선언하십시오.

이 규칙은 구체적인 컬렉션 타입의 사용을 보고합니다. 인터페이스와 동일하게 취급해야 하는
사용자 정의 타입은 `allowedTypes` 속성으로 구성할 수 있습니다."
MethodReturnsInternalArray,bestpractices,"내부 배열을 호출자에게 노출하면 객체 캡슐화를 위반합니다. 요소를 소유하지 않는 외부에서
제거하거나 교체할 수 있기 때문입니다. 배열의 복사본을 반환하는 것이 더 안전합니다."
MissingOverride,bestpractices,"오버라이드된 메서드에 @Override를 추가하면 컴파일 타임에 해당 메서드가 실제로 오버라이드하는지
            확인할 수 있어 리팩토링에 도움이 되고 의도를 명확히 합니다."
NonExhaustiveSwitch,bestpractices,"switch 문은 제어 흐름을 따라가기 쉽도록 모든 경우를 포괄해야 합니다.
            이는 `default` 케이스를 추가하거나, switch가 열거형 타입인 경우 각 열거형 상수에 대한
            switch 분기를 보장하여 달성할 수 있습니다.

            패턴 매칭을 사용하는 Switch 문은 컴파일러가 이미 모든 케이스가 처리되는지 확인하므로
            이 규칙에서 고려하지 않습니다. Switch 표현식도 마찬가지로 이 규칙에서 고려하지 않습니다."
PreserveStackTrace,bestpractices,"catch 블록 내에서 던져지지만 해당 catch 블록이 선언한 예외 매개변수를 참조하지 않는 예외를 보고합니다.
원래 예외의 스택 트레이스가 손실되어 던져진 예외의 정보가 줄어들 수 있습니다.

스택 트레이스를 보존하려면 원래 예외를 `Throwable#initCause`를 사용하여 새 예외의 원인으로 사용하거나,
생성자 인수로 새 예외에 전달할 수 있습니다. `Throwable#addSuppressed`를 사용하여 보존할 수도 있습니다.
이 규칙은 실제로 원래 예외를 인수로 받는 모든 메서드나 생성자가 원래 스택 트레이스를 보존한다고 가정합니다.

이 규칙은 `InvocationTargetException`과 `PrivilegedActionException`이 원인 예외로 대체되는 것을 허용합니다.
폐기된 스택 트레이스 부분은 이러한 경우 JDK 내부 코드뿐이므로 그다지 유용하지 않습니다.
또한 이름이 `ignored`로 시작하는 예외도 무시합니다."
PrimitiveWrapperInstantiation,bestpractices,"원시 래퍼 생성자의 사용을 보고합니다. Java 9부터 더 이상 사용되지 않으며 사용하지 말아야 합니다.
            Java 9 이전에도 해당하는 정적 `valueOf` 팩토리 메서드(Java 1.5부터 컴파일러에 의해
            자동으로 삽입될 수 있음)로 대체할 수 있습니다.
            이는 매번 새 인스턴스를 생성하는 대신 공통 인스턴스를 재사용할 수 있는 장점이 있습니다.

            `Boolean`의 경우, `Boolean.valueOf` 대신 명명된 상수 `Boolean.TRUE`와 `Boolean.FALSE`가
            선호됩니다."
RelianceOnDefaultCharset,bestpractices,"JVM의 기본 문자셋을 사용하는 API에 대해 문자셋을 반드시 지정하여 서로 다른 JVM, 프로그램 및
서버 간에 안정적인 인코딩 동작을 보장하십시오. 플랫폼의 기본 문자셋을 사용하면 코드의 이식성이
떨어지고 다른 시스템에서 실행할 때 예기치 않은 동작이 발생할 수 있습니다.

또한 Java 18부터 이러한 API의 기본 문자셋은 일관되게 UTF-8입니다
([JEP 400](https://openjdk.org/jeps/400) 참조). 이로 인해 다른 시스템에서의 예기치 않은 동작은
줄어들지만, 특히 UTF-8이 원하는 문자셋이 아닌 경우 문자셋을 명시적으로 지정하는 것이 여전히 권장됩니다."
ReplaceEnumerationWithIterator,bestpractices,Enumeration 사용을 더 새로운 java.util.Iterator로 대체하는 것을 고려하십시오.
ReplaceHashtableWithMap,bestpractices,스레드 안전성이 필요하지 않은 경우 Hashtable 사용을 더 새로운 java.util.Map으로 대체하는 것을 고려하십시오.
ReplaceVectorWithList,bestpractices,비용이 많이 드는 스레드 안전 작업이 필요하지 않은 경우 Vector 사용을 더 새로운 java.util.ArrayList로 대체하는 것을 고려하십시오.
SimplifiableTestAssertion,bestpractices,"보다 구체적인 어설션 메서드를 사용하여 단순화할 수 있는 테스트 어설션을 보고합니다.
            이를 통해 더 나은 오류 메시지를 제공하고 어설션의 가독성을 높일 수 있습니다."
UnitTestAssertionsShouldIncludeMessage,bestpractices,"단위 어설션에는 설명 메시지가 포함되어야 합니다. 즉, `assertEquals()`의 인수가 2개인 버전이 아닌
인수가 3개인 버전을 사용하십시오.

이 규칙은 JUnit(3, 4 및 5)과 TestNG를 사용하는 테스트를 지원합니다.

참고: 이 규칙은 PMD 7.7.0 이전에는 JUnitAssertionsShouldIncludeMessage였습니다."
UnitTestContainsTooManyAsserts,bestpractices,"단위 테스트에는 너무 많은 어설션이 포함되어서는 안 됩니다. 많은 어설션은 복잡한 테스트를 나타내며,
            정확성을 검증하기 더 어렵습니다. 테스트 시나리오를 여러 개의 더 짧은 테스트 시나리오로
            분리하는 것을 고려하십시오. 이 규칙에서 사용되는 최대 어설션 수를 필요에 맞게 사용자 정의하십시오.

            이 규칙은 JUnit(3, 4 및 5)과 TestNG 테스트를 검사합니다.

            참고: 이 규칙은 PMD 7.7.0 이전에는 JUnitTestContainsTooManyAsserts였습니다."
UnitTestShouldIncludeAssert,bestpractices,"단위 테스트에는 최소 하나의 어설션이 포함되어야 합니다. 이는 테스트를 더 견고하게 만들며,
            메시지와 함께 assert를 사용하면 개발자에게 테스트가 무엇을 하는지 더 명확한 아이디어를 제공합니다.

            이 규칙은 JUnit(3, 4 및 5)과 TestNG 테스트를 검사합니다.

            참고: 이 규칙은 PMD 7.7.0 이전에는 JUnitTestsShouldIncludeAssert였습니다."
UnitTestShouldUseAfterAnnotation,bestpractices,"이 규칙은 정리 메서드로 적절하게 어노테이션이 지정되지 않은 `tearDown()`이라는 메서드를 감지합니다.
이는 주로 JUnit 3에서 업그레이드를 지원하기 위한 것으로, 정리 메서드의 이름이 `tearDown()`이어야 했습니다.
이 명명 규칙을 따르는 한, 더 새로운 JUnit 버전이나 TestNG에서도 누락을 감지하는 데 도움이 될 수 있습니다.

* JUnit 4는 각 테스트 실행 후 `@After`로 어노테이션된 메서드만 실행합니다.
* JUnit 5는 각 테스트 후 또는 클래스의 모든 테스트 후에 메서드를 실행하기 위해
  `@AfterEach`와 `@AfterAll` 어노테이션을 도입했습니다.
* TestNG는 각 테스트 후 또는 클래스의 테스트 후에 메서드를 실행하기 위해
  `@AfterMethod`와 `@AfterClass` 어노테이션을 제공합니다.

참고: 이 규칙은 PMD 7.7.0 이전에는 JUnit4TestShouldUseAfterAnnotation이었습니다."
UnitTestShouldUseBeforeAnnotation,bestpractices,"이 규칙은 설정 메서드로 적절하게 어노테이션이 지정되지 않은 `setUp()`이라는 메서드를 감지합니다.
이는 주로 JUnit 3에서 업그레이드를 지원하기 위한 것으로, 설정 메서드의 이름이 `setUp()`이어야 했습니다.
이 명명 규칙을 따르는 한, 더 새로운 JUnit 버전이나 TestNG에서도 누락을 감지하는 데 도움이 될 수 있습니다.

* JUnit 4는 모든 테스트 전에 `@Before`로 어노테이션된 메서드만 실행합니다.
* JUnit 5는 각 테스트 전 또는 클래스의 모든 테스트 전에 메서드를 실행하기 위해
  `@BeforeEach`와 `@BeforeAll` 어노테이션을 도입했습니다.
* TestNG는 각 테스트 전 또는 클래스의 테스트 전에 메서드를 실행하기 위해
  `@BeforeMethod`와 `@BeforeClass` 어노테이션을 제공합니다.

참고: 이 규칙은 PMD 7.7.0 이전에는 JUnit4TestShouldUseBeforeAnnotation이었습니다."
UnitTestShouldUseTestAnnotation,bestpractices,"이 규칙은 적절하게 어노테이션이 지정되지 않아 실행되지 않을 ""test""로 시작하는 모든 테스트 메서드를 감지합니다.

            JUnit 4에서는 `@Test` 어노테이션이 있는 메서드만 실행됩니다.
            JUnit 5에서는 테스트에 다음 어노테이션 중 하나를 사용해야 합니다: `@Test`, `@RepeatedTest`, `@TestFactory`, `@TestTemplate` 또는 `@ParameterizedTest`.
            TestNG에서는 `@Test` 어노테이션이 있는 메서드만 실행됩니다.

            참고: 이 규칙은 PMD 7.7.0 이전에는 JUnit4TestShouldUseTestAnnotation이었습니다."
UnnecessaryVarargsArrayCreation,bestpractices,"가변 인수가 예상되는 곳에서 명시적 배열 생성을 보고합니다.
            예를 들어:
            ```java
            Arrays.asList(new String[] { ""foo"", ""bar"", });
            ```
            다음으로 대체할 수 있습니다:
            ```java
            Arrays.asList(""foo"", ""bar"");
            ```"
UnnecessaryWarningSuppression,bestpractices,"이 규칙은 PMD 위반을 억제하지 않은 억제 주석과 어노테이션을 보고합니다.
            이 규칙의 위반은 억제할 수 없습니다.

            참고:
            - 이 규칙은 _현재 실행_ 중에 위반을 억제하지 않은 억제 주석/어노테이션을 보고합니다.
            즉, 이 규칙을 다른 규칙과 별도로 실행할 수 없으며, 경고를 생성할 수 있는 모든 규칙과
            함께 항상 실행해야 합니다. 일반 규칙셋에 이 규칙을 포함하면 대부분 문제가 되지 않습니다.
            - 현재 이 규칙은 PMD에 특정한 어노테이션만 보고합니다(예: `@SuppressWarnings(""PMD"")`).
            예를 들어 `@SuppressWarnings(""all"")`은 다른 도구가 억제해야 할 경고를 생성하는지
            알 수 없으므로 보고되지 않습니다. 향후 `@SuppressWarnings(""unchecked"")`나
            `""fallthrough""` 등 다른 일반적인 경우를 검사할 수 있을 것입니다."
UnusedAssignment,bestpractices,"변수가 덮어쓰여지거나 범위를 벗어나기 전에 사용되지 않는 할당을 보고합니다.
            사용되지 않는 할당은 다음과 같은 경우입니다:
            1. 할당 후 변수가 읽히지 않는 경우, 또는
            2. 할당된 값이 다음 변수 읽기 전에 다른 할당에 의해 항상 덮어쓰여지는 경우.

            이 규칙은 `this`의 필드와 현재 클래스의 정적 필드에 대한 할당을 추적합니다.
            이는 타이밍에 민감한 동시성 코드에서 일부 오탐을 유발할 수 있으며, 이 규칙은 이를 감지할 수 없습니다.

            이 규칙은 표준 `@SuppressWarnings(""unused"")` 태그로 억제할 수 있습니다.

            이 규칙은 {% rule ""UnusedLocalVariable"" %}과 {% rule ""UnusedFormalParameter"" %}를 포함합니다.
            해당 위반은 이미 해당 규칙을 활성화한 경우를 대비하여 기본적으로 필터링되지만,
            `reportUnusedVariables` 속성으로 활성화할 수 있습니다. 이름이 `ignored` 또는 `unused`로
            시작하는 변수는 예외에 대한 표준 관행으로 필터링됩니다.

            제한사항:
            * 현재 이 규칙은 어떤 메서드 호출이 예외를 던지는지 또는 어떤 예외를 던지는지 알 수 없습니다.
            try 블록 본문에서 모든 메서드나 생성자 호출은 던지는 것으로 간주됩니다. 이는 미탐지를 유발할 수 있습니다.
            던지는 것으로 간주되는 유일한 다른 언어 구조는 `throw` 문이며, 특히
            `assert` 문이나 역참조 시 NullPointerException 등은 무시됩니다.
            * 이 규칙은 특수 `this(...)` 구문으로 호출되는 생성자 간의 할당을 해결할 수 없습니다.
            이는 미탐지를 유발할 수 있습니다.

            이 두 가지 제한사항은 PMD 7에서 부분적으로 완화될 수 있습니다."
UnusedFormalParameter,bestpractices,"메서드 본문에서 참조되지 않는 메서드와 생성자의 매개변수를 보고합니다.
이름이 `ignored` 또는 `unused`로 시작하는 매개변수는 필터링됩니다.

공개 메서드에서 사용되지 않는 형식 매개변수를 제거하면 코드베이스 전체에 파급 효과를 줄 수 있습니다.
따라서 기본적으로 이 규칙은 private 메서드만 고려합니다. 비-private 메서드를 포함하려면
`checkAll` 속성을 `true`로 설정하십시오. public 생성자에도 동일하게 적용됩니다."
UnusedLabel,bestpractices,"사용되지 않는 레이블은 불필요하며 이 레이블이 무엇에 사용되는지 혼란을 줄 수 있습니다.
가독성을 향상시키려면 사용되지 않는 레이블을 단순히 제거해야 합니다.

이 규칙은 SonarSource 규칙 [S1065](https://sonarsource.github.io/rspec/#/rspec/S1065)를 구현합니다."
UnusedLocalVariable,bestpractices,"지역 변수가 선언 및/또는 할당되었지만 사용되지 않는 경우를 감지합니다.
이름이 `ignored` 또는 `unused`로 시작하는 변수는 필터링됩니다."
UnusedPrivateField,bestpractices,"private 필드가 선언 및/또는 값이 할당되었지만 사용되지 않는 경우를 감지합니다.

PMD 6.50.0부터 필드에 어노테이션이 있거나 둘러싸는 클래스에 어노테이션이 있는 경우 private 필드가 무시됩니다.
어노테이션은 종종 리플렉션이나 다른 수단으로 필드를 사용하는 프레임워크(의존성 주입, 모킹 또는
예를 들어 Lombok)를 활성화합니다. 이러한 사용은 정적 코드 분석으로 감지할 수 없습니다.
이전에는 이러한 프레임워크가 ""ignoredAnnotations"" 속성에 어노테이션을 나열하여 명시적으로 허용되었지만,
명시적으로 고려되지 않은 프레임워크에 대해 오탐이 발생하기 쉬웠습니다."
UnusedPrivateMethod,bestpractices,private 메서드가 선언되었지만 사용되지 않는 경우를 감지합니다.
UseCollectionIsEmpty,bestpractices,"java.util.Collection의 isEmpty() 메서드는 컬렉션에 요소가 있는지 확인하기 위해 제공됩니다.
size()의 값을 0과 비교하는 것은 isEmpty() 메서드만큼 의도를 잘 전달하지 못합니다."
UseEnumCollections,bestpractices,"가능한 경우 키가 열거형 타입일 때 `HashSet`과 `HashMap` 대신 `EnumSet` 또는 `EnumMap`을
            사용하십시오. 특화된 열거형 컬렉션은 공간 및 시간 효율성이 더 높습니다.
            이 규칙은 키 타입이 열거형 타입인 해시 세트 또는 맵의 생성자 표현식을 보고합니다."
UseStandardCharsets,bestpractices,"Java 7부터 StandardCharsets는 UTF-8과 같은 일반적인 Charset 객체에 대한 상수를 제공합니다.
상수를 사용하면 오류 발생 가능성이 적으며, 내부 `Charset` 캐시를 스캔할 필요가 없으므로
`Charset.forName(...)`에 비해 약간의 성능 이점을 제공할 수 있습니다."
UseTryWithResources,bestpractices,"Java 7에서 try-with-resources 문이 도입되었습니다. 이 문은 각 리소스가 문의 끝에서 닫히도록 보장합니다.
finally 블록에서 리소스를 명시적으로 닫을 필요가 없습니다. 또한 예외가 더 잘 처리됩니다:
`try` 블록과 `finally` 블록 모두에서 예외가 발생한 경우, try 블록의 예외가 억제되었습니다.
`try`-with-resources 문을 사용하면 try 블록에서 던져진 예외가 보존됩니다."
WhileLoopWithLiteralBoolean,bestpractices,"`do {} while (true);`는 영원히 반복된다는 것을 알기 위해 문의 끝을 읽어야 하지만,
`while (true) {}`는 이해하기 더 쉽습니다.

`do {} while (false);`는 중복이며, 내부 변수 범위가 필요한 경우 블록 `{}`이면 충분합니다.

`while (false) {}`는 블록을 절대 실행하지 않으며 전체를 제거할 수 있습니다."
OneDeclarationPerLine,bestpractices,"Java에서는 같은 타입의 여러 변수 선언을 한 줄에 할 수 있습니다.
그러나 이는 상당히 지저분한 코드를 초래할 수 있습니다. 이 규칙은 같은 줄에 여러 선언이 있는지 검사합니다."
UseVarargs,bestpractices,"Java 5에서 메서드와 생성자에 대한 가변 인수 매개변수 선언이 도입되었습니다. 이 문법적 편의는
이러한 메서드와 생성자의 사용자에게 유연성을 제공하여 배열 생성을 처리할 필요가 없게 합니다.

모든 메서드의 바이트 배열과 `public static void main(String[])` 메서드의 문자열 배열은 무시됩니다."
ClassNamingConventions,codestyle,"타입 선언에 대한 설정 가능한 명명 규칙입니다. 이 규칙은 해당 종류(예: enum 또는
            interface)에 적용되는 정규식과 일치하지 않는 타입 선언을 보고합니다.
            각 정규식은 속성을 통해 설정할 수 있습니다.

            기본적으로 이 규칙은 표준 Java 명명 규칙(Pascal case)을 사용합니다.

            이 규칙은 유틸리티 클래스를 감지하고 해당 클래스에 다른 명명 규칙을 적용할 수 있습니다.
            예를 들어, `utilityClassPattern` 속성을 `[A-Z][a-zA-Z0-9]+(Utils?|Helper|Constants)`로
            설정하면 ""Util(s)"", ""Helper"" 또는 ""Constants""로 끝나지 않는 유틸리티 클래스를 보고합니다.

            이 규칙에서 유틸리티 클래스는 다음과 같이 정의됩니다: 상위 클래스를 상속하거나
            인터페이스를 구현하지 않으며, 정적 필드 또는 메서드만 있는 구체적인 클래스입니다.

            이 규칙은 다음 규칙을 사용하여 테스트 클래스를 감지합니다: 테스트 클래스는 최상위 클래스로,
            JUnit 3 TestCase를 상속하거나 JUnit4/5 또는 TestNG의 Test 어노테이션이 달린 메서드가
            하나 이상 있는 클래스입니다."
EmptyMethodInAbstractClassShouldBeAbstract,codestyle,"추상 클래스의 빈 메서드 또는 자동 생성된 메서드는 abstract로 태그해야 합니다. 이는 구체적인
하위 클래스에서 자체 버전을 구현해야 하는 개발자의 부적절한 사용을 제거하는 데 도움이 됩니다."
FieldNamingConventions,codestyle,"필드 선언에 대한 설정 가능한 명명 규칙입니다. 이 규칙은 해당 종류(예: 상수(static final),
            enum 상수, final 필드)에 적용되는 정규식과 일치하지 않는 변수 선언을 보고합니다.
            각 정규식은 속성을 통해 설정할 수 있습니다.

            기본적으로 이 규칙은 표준 Java 명명 규칙(Camel case)을 사용하며, 상수와 enum 상수에는
            ALL_UPPER 규칙을 사용합니다."
FinalParameterInAbstractMethod,codestyle,인터페이스 메서드의 매개변수를 final로 선언하는 것은 무의미합니다. 구현체에서 이를 준수하지 않을 수 있기 때문입니다.
FormalParameterNamingConventions,codestyle,"메서드 및 람다의 형식 매개변수에 대한 설정 가능한 명명 규칙입니다.
            이 규칙은 해당 종류(예: 람다 매개변수 또는 final 형식 매개변수)에 적용되는 정규식과
            일치하지 않는 형식 매개변수를 보고합니다. 각 정규식은 속성을 통해 설정할 수 있습니다.

            기본적으로 이 규칙은 표준 Java 명명 규칙(Camel case)을 사용합니다."
LocalVariableNamingConventions,codestyle,"지역 변수 선언 및 기타 로컬 범위 변수에 대한 설정 가능한 명명 규칙입니다. 이 규칙은
            해당 종류(예: final 변수 또는 catch절 매개변수)에 적용되는 정규식과 일치하지 않는
            변수 선언을 보고합니다. 각 정규식은 속성을 통해 설정할 수 있습니다.

            기본적으로 이 규칙은 표준 Java 명명 규칙(Camel case)을 사용합니다."
MethodNamingConventions,codestyle,"메서드 선언에 대한 설정 가능한 명명 규칙입니다. 이 규칙은 해당 종류(예: JUnit 테스트 또는
            네이티브 메서드)에 적용되는 정규식과 일치하지 않는 메서드 선언을 보고합니다.
            각 정규식은 속성을 통해 설정할 수 있습니다.

            기본적으로 이 규칙은 표준 Java 명명 규칙(Camel case)을 사용합니다."
ModifierOrder,codestyle,"JLS에서 권장하는 수정자 순서를 강제합니다. 수정자 정렬 외에도 이 규칙은 모든 어노테이션이
            모든 수정자 키워드 앞에 나타나도록 강제합니다.
            `typeAnnotations` 속성을 설정하면 타입 어노테이션이 수정자 키워드의 오른쪽, 적용되는
            타입 옆에 나타나도록 강제할 수도 있습니다.
            이 속성은 세 가지 값을 가질 수 있습니다:
            - `onType`: 타입 어노테이션은 적용되는 타입 옆에 배치되어야 합니다
            - `onDecl`: 타입 어노테이션은 다른 어노테이션과 함께 수정자 앞에 배치되어야 합니다.
            타입 어노테이션이 구문적으로 타입 내에 나타나는 경우(예:
            `public Map.@Nullable Entry&lt;K,V&gt; method()` 또는 `public &lt;T&gt; @NonNull T method()`)에는
            강제되지 않습니다.
            - `anywhere` (기본값): 어느 위치든 허용됩니다. 그러나 키워드 수정자 사이에 산재할 수는
            없습니다. 타입 어노테이션이 아닌 어노테이션은 여전히 키워드 수정자 앞에 있어야 합니다."
AvoidUsingNativeCode,codestyle,"Java Native Interface(JNI) 호출에 대한 불필요한 의존은 애플리케이션의 이식성을 직접적으로 낮추고
유지보수 부담을 증가시킵니다."
AtLeastOneConstructor,codestyle,"비정적(non-static) 클래스는 최소 하나의 생성자를 선언해야 합니다.
정적 멤버만 있는 클래스는 무시되며, 이러한 클래스를 탐지하려면 [UseUtilityClassRule](pmd_rules_java_design.html#useutilityclass)을 참조하세요."
AvoidDollarSigns,codestyle,변수/메서드/클래스/인터페이스 이름에 달러 기호($) 사용을 피하세요.
AvoidProtectedFieldInFinalClass,codestyle,"final 클래스는 하위 클래스를 만들 수 없으므로 protected 필드를 사용하지 마세요.
private 또는 패키지 접근 제어자를 사용하여 의도를 명확히 하세요."
AvoidProtectedMethodInFinalClassNotExtending,codestyle,"대부분의 final 클래스는 하위 클래스를 만들 수 없으므로 protected 메서드를 사용하지 마세요. 이는
protected 메서드가 있는 다른 클래스를 상속한 final 클래스(가시성을 줄일 수 없는 경우)에서만
허용되어야 합니다. private 또는 패키지 접근 제어자를 사용하여 의도를 명확히 하세요."
CallSuperInConstructor,codestyle,"생성자에서 super()를 호출하는 것이 좋은 습관입니다. super()가 호출되지 않았지만
다른 생성자(예: 오버로드된 생성자)가 호출된 경우, 이 규칙은 보고하지 않습니다."
CommentDefaultAccessModifier,codestyle,"어노테이션, 클래스, Enum, 메서드, 생성자 또는 필드가 기본 접근 제어자를 가지도록 의도한 실수를 방지하려면
선언 시작 부분에 주석을 추가해야 합니다.
기본적으로 주석은 `/* default */` 또는 `/* package */`여야 하며, 다른 형식을 원하면 정규식을 제공해야 합니다.

이 규칙은 기본적으로 `@VisibleForTesting` 어노테이션 또는 JUnit5/TestNG 어노테이션이 있는 모든 경우를 무시합니다.
인식할 어노테이션을 사용자 정의하려면 ""ignoredAnnotations"" 속성을 사용하세요."
ConfusingTernary,codestyle,"""else"" 절이 있는 ""if"" 표현식에서 부정문 사용을 피하세요. 예를 들어, 다음을:
`if (x != y) diff(); else same();`를 다음과 같이 바꾸세요: `if (x == y) same(); else diff();`.

""else""가 없는 대부분의 ""if (x != y)"" 경우는 주로 반환 케이스이므로, 이 규칙을 일관되게
사용하면 코드 가독성이 향상됩니다. 또한 ""오류 케이스가 먼저인가?"" 또는 ""일반적인 케이스가
먼저인가?""와 같은 사소한 순서 문제를 해결합니다.

null 검사는 일반적으로 긍정 조건으로 간주되므로, 기본적으로 이 규칙에서 무시됩니다.
즉, `a == null`과 `a != null` 모두 허용됩니다. 특정 스타일을 강제하고 다른 스타일을
금지하려면 `nullCheckBranch` 속성을 사용하세요."
ControlStatementBraces,codestyle,"제어문에 대한 중괄호 정책을 강제합니다. 'if ... else' 문과 반복문에는 선택 사항이더라도
            중괄호를 사용하는 것이 권장됩니다. 이는 일반적으로 코드를 더 명확하게 하고, 나중에 다른 문을
            추가해야 할 때를 대비합니다. 이 규칙은 속성을 통해 어떤 문에 중괄호가 필요한지 제어할 수
            있습니다.

            6.2.0부터 이 규칙은 WhileLoopMustUseBraces, ForLoopMustUseBraces, IfStmtMustUseBraces,
            IfElseStmtMustUseBraces를 대체합니다."
EmptyControlStatement,codestyle,"본문이 비어 있는 제어문과 빈 초기화 블록을 보고합니다.

            검사되는 코드 구조는 다음과 같습니다:
            - `try` 문의 본문
            - `try` 문의 `finally` 절
            - `switch` 문
            - `synchronized` 문
            - `if` 문
            - 반복문: `while`, `for`, `do .. while`
            - 초기화 블록
            - 문으로 사용된 블록 (스코핑용)

            이 규칙은 EmptyFinallyBlock, EmptyIfStmt, EmptyInitializer, EmptyStatementBlock,
            EmptySwitchStatements, EmptySynchronizedBlock, EmptyTryBlock, EmptyWhileStmt 규칙을 대체합니다.

            {% rule java/errorprone/EmptyCatchBlock %}은 여전히 독립적인 규칙입니다.

            EmptyStatementNotInLoop은 {% rule java/codestyle/UnnecessarySemicolon %}으로 대체되었습니다."
FieldDeclarationsShouldBeAtStartOfClass,codestyle,"필드는 메서드 선언, 생성자, 초기화 블록 또는 내부 클래스보다 앞서 클래스의 최상단에 선언해야 합니다."
ForLoopShouldBeWhileLoop,codestyle,"일부 for 반복문은 while 반복문으로 단순화할 수 있으며, 이렇게 하면 더 간결해집니다."
IdenticalCatchBranches,codestyle,"동일한 `catch` 분기는 세로 공간을 차지하고 기능을 추가하지 않으면서 코드의 복잡성을
            증가시킵니다. 동일한 분기를 단일 멀티캐치 분기로 합치는 것이 더 좋은 스타일입니다."
LambdaCanBeMethodReference,codestyle,"이 규칙은 메서드 참조로 더 간결하게 작성할 수 있는 람다 표현식을 보고합니다. 이는 람다가 하나의 메서드만 호출하고, 전체 람다 매개변수 목록을 순서대로 해당 메서드에 전달하는 표현식 람다인 경우입니다. 예:
            ```java
                x -> Foo.call(x) // Foo::call이 될 수 있음
                x -> call(x)     // this::call이 될 수 있음 (call이 인스턴스 메서드인 경우)
                (x, y, z) -> call(x, y, z) // this::call이 될 수 있음
                () -> foo.get() // foo::get이 될 수 있음
                x -> x.foo()    // XType::foo가 될 수 있음 (XType은 x의 타입)
            ```

            경우에 따라 람다를 메서드 참조로 다시 작성하면 코드의 의미가 변경될 수 있습니다. 예를 들어 `(x) -> someVar.call(x)`에서 람다 호출 시 `someVar`가 null이면 NullPointerException(NPE)이 발생할 수 있습니다. 메서드 참조 `someVar::call`도 `someVar`가 null이면 NPE를 발생시키지만, 메서드 참조가 생성되는 시점에서 발생하는 반면 람다는 오류 없이 생성되고 람다가 호출될 때만 NPE가 발생합니다(절대 호출되지 않을 수도 있음). 코드는 이러한 미묘한 의미론적 차이에 의존해서는 안 되므로, 이러한 잠재적으로 문제가 있는 람다도 기본적으로 보고됩니다. 이 동작은 `ignoreIfMayNPE` 속성을 `true`로 설정하여 비활성화할 수 있습니다.

            `ignoreIfMayNPE` 속성은 기본적으로 true입니다. 기본적으로 수신자가 메서드 호출 자체인 호출은 부작용을 일으킬 수 있으므로 무시됩니다. 이는 `ignoreIfReceiverIsMethod` 속성을 `false`로 설정하여 변경할 수 있습니다.

            범위 제한:
            - 이 규칙은 `x -> new CtorCall().something(x)` 형태의 람다를 보고하지 않습니다. 메서드 참조의 의미론은 단일 새 객체를 생성하는 것이지만 람다는 호출마다 하나의 객체를 생성하기 때문입니다.
            - 이 규칙은 메서드 호출의 한정자가 부작용을 수행하는지 알 수 없습니다. 즉, `(x) -> sideEffectingMethod().foo(x)`가 보고됩니다. 이 경우 경고를 억제하세요."
LinguisticNaming,codestyle,"이 규칙은 언어적 명명 안티패턴을 찾습니다. boolean이어야 할 것처럼 이름이 지어졌지만
            다른 타입인 필드를 검사합니다. 또한 이름에 따르면 boolean을 반환해야 하지만 그렇지 않은
            메서드도 검사합니다. 추가로, getter는 무언가를 반환하고 setter는 반환하지 않는지 검사합니다.
            마지막으로, ""to""로 시작하는 메서드(변환 메서드)가 이름에 따라 하나의 객체를 다른 객체로
            변환해야 하므로 실제로 무언가를 반환하는지 검사합니다. 추가적으로 이름에 ""To""를 포함하는
            메서드(역시 변환 메서드)를 검사하는 옵션이 있습니다. 그러나 이 감지는 오탐이 발생하기 쉬우므로
            기본적으로 비활성화되어 있습니다.

            자세한 내용은 [Linguistic Antipatterns - What They Are and How
Developers Perceive Them](https://doi.org/10.1007/s10664-014-9350-8)을 참조하세요."
LocalVariableCouldBeFinal,codestyle,한 번만 할당된 지역 변수는 final로 선언할 수 있습니다.
LongVariable,codestyle,"필드, 형식 인자 또는 지역 변수 이름이 너무 길면 코드를 따라가기 어려울 수 있습니다."
MethodArgumentCouldBeFinal,codestyle,"메서드 본문 내에서 재할당되지 않아 final로 만들 수 있는 메서드 및 생성자 매개변수를 보고합니다.

            이 규칙은 {% rule java/bestpractices/UnusedFormalParameter %} 규칙과 중복되지 않도록
            사용되지 않는 매개변수를 무시합니다.
            또한 추상 메서드의 매개변수도 무시합니다."
NoPackage,codestyle,"클래스, 인터페이스, enum 또는 어노테이션에 패키지 정의가 없는 경우를 감지합니다."
OnlyOneReturn,codestyle,"메서드에는 하나의 종료 지점만 있어야 하며, 이는 메서드의 마지막 문이어야 합니다."
PackageCase,codestyle,패키지 정의에 대문자가 포함된 경우를 감지합니다.
PrematureDeclaration,codestyle,"사용되기 전에 정의된 변수를 검사합니다. 변수가 선언된 시점과 처음 읽히는 시점 사이에
반환하거나 예외를 던질 수 있는 문이 있는 경우 선언이 조기로 간주됩니다.

일부 변수는 처음 사용되기 전에 발생하는 부작용 때문에 첫 번째 사용 위치 가까이에 선언할 수
없습니다. 대부분의 메서드 및 생성자 호출을 순수하지 않은 것으로 간주하여 이러한 경우의
보고를 피하려고 합니다. 두 번째 예제를 참조하세요.

이 규칙은 코드 가독성을 향상시키기 위한 것이지 최적화가 아닙니다. 스마트한 JIT는 변수가
조기 선언되었는지 여부에 관계없이 코드를 재정렬할 수 있습니다."
ShortMethodName,codestyle,매우 짧은 메서드 이름은 읽는 사람에게 도움이 되지 않습니다.
ShortVariable,codestyle,"필드, 지역 변수, enum 상수 이름 또는 매개변수 이름이 매우 짧으면 읽는 사람에게 도움이 되지 않습니다."
TooManyStaticImports,codestyle,"정적 import 기능을 남용하면 프로그램을 읽거나 유지보수하기 어렵게 만들어 네임스페이스를
import한 모든 정적 멤버로 오염시킬 수 있습니다. 코드를 읽는 사람(몇 달 후의 본인 포함)은
정적 멤버가 어느 클래스에서 왔는지 알 수 없습니다 (Sun 1.5 Language Guide)."
UnnecessaryAnnotationValueElement,codestyle,유일한 요소일 때 어노테이션에서 value 사용을 피하세요.
UnnecessaryBoxing,codestyle,"안전하게 제거할 수 있는 명시적 박싱 및 언박싱 변환을 보고합니다.
            컴파일러가 자동으로 삽입하거나, 의미론적으로 무의미한 경우(예: 값을 언박싱한 후
            즉시 다시 박싱하는 경우)입니다.

            이는 `valueOf` 또는 `intValue`, `byteValue` 등의 메서드 호출을 통해 발생하는
            박싱 및 언박싱 변환만 처리합니다. 변환을 지시하는 캐스트는
            {% rule UnnecessaryCast %}에서 대신 보고합니다."
UnnecessaryCast,codestyle,"캐스트의 피연산자가 이미 컨텍스트 타입에 적합하여 제거할 수 있는 캐스트를 감지합니다.
예를 들어, 다음에서:
```
Object context = (Comparable) ""o"";
```
캐스트는 불필요합니다. `String`이 이미 `Comparable`과 `Object` 모두의 하위 타입이기 때문입니다.

이는 Java 5의 오토박싱 기능으로 인해 피할 수 있는 캐스트도 표시합니다.
```
Integer integer = (Integer) 1;
```
리터럴은 어차피 `Integer`로 오토박싱됩니다."
UnnecessaryConstructor,codestyle,"이 규칙은 생성자가 필요하지 않은 경우를 감지합니다. 즉, 생성자가 하나뿐이고 해당 생성자가
기본 생성자와 동일한 경우입니다. 기본 생성자는 선언하는 클래스와 동일한 접근 제어자를 가져야 합니다.
enum 타입에서 기본 생성자는 암시적으로 private입니다."
UnnecessaryLocalBeforeReturn,codestyle,"불필요한 지역 변수 생성을 피하세요.

이 규칙은 7.17.0부터 더 이상 사용되지 않습니다. throw 문도 추가로 다루는 새 규칙
{%rule VariableCanBeInlined %}을 대신 사용하세요."
UnnecessaryModifier,codestyle,"인터페이스와 어노테이션의 필드는 자동으로 `public static final`이며, 메서드는 `public abstract`입니다.
인터페이스 또는 어노테이션 내에 중첩된 클래스, 인터페이스 또는 어노테이션은 자동으로 `public static`입니다
(모든 중첩된 인터페이스와 어노테이션은 자동으로 static입니다).
중첩된 enum은 자동으로 `static`입니다.
역사적인 이유로 컨텍스트에 의해 암시되는 수정자는 컴파일러에 의해 허용되지만 불필요합니다."
UnnecessaryReturn,codestyle,"불필요한 return 문 사용을 피하세요. 어차피 뒤에 실행할 명령이 없을 때 return은
불필요합니다."
UnnecessarySemicolon,codestyle,"불필요한 세미콜론(""빈 문"" 및 ""빈 선언""이라고도 함)을 보고합니다.
            프로그램을 변경하지 않고 제거할 수 있습니다. Java 문법은 역사적인 이유로
            이를 허용하지만 사용을 피해야 합니다.

            이 규칙은 구문적으로 필요한 빈 문(예: 제어문의 본문인 경우)은
            보고하지 않습니다.

            이 규칙은 EmptyStatementNotInLoop을 대체합니다."
UseDiamondOperator,codestyle,"경우에 따라 제네릭 타입의 생성자 호출에서 명시적 타입 인수를 다이아몬드 타입 인수(`<>`)로
대체하여 컴파일러가 추론하도록 할 수 있습니다. 이 규칙은 타입 인수의 중복을 피하고 코드를
더 간결하고 읽기 쉽게 만들기 위해 가능한 모든 곳에서 다이아몬드 타입 인수를 사용하도록 권장합니다.

이 규칙은 코드베이스를 Java 1.7, Java 1.8 또는 Java 9로 업그레이드할 때 유용합니다.
다이아몬드 구문은 Java 1.7에서 처음 도입되었습니다. Java 8에서는 Java의 타입 추론이
개선되어 더 많은 타입 인수가 불필요해졌습니다. Java 9에서는 익명 클래스 생성자에 대해
타입 인수 추론이 가능해졌습니다."
UseExplicitTypes,codestyle,"Java 10에서 `var` 키워드가 도입되었습니다. 이는 변수 선언의 초기화식에서 타입을 추론할 수 있으므로
작성해야 하는 코드의 양을 줄여줍니다.

이것은 본질적으로 트레이드오프입니다: 한편으로는 중복 정보를 제거하여 코드를 더 읽기 쉽게 만들 수
있습니다. 다른 한편으로는 유용한 정보를 생략하여 코드를 더 읽기 어렵게 만들 수 있습니다.
`var`를 사용해야 할 때와 사용하지 말아야 할 때에 대한 일률적인 규칙은 없습니다.

문을 읽을 때 타입이 본질적으로 명확한 경우(즉, 리터럴 값이나 생성자 호출에 대한 할당)
`var`를 사용하는 것이 합리적일 수 있습니다. 이러한 사용 사례는 속성을 통해 활성화할 수 있습니다.

람다 매개변수는 기본적으로 이미 추론되므로 허용됩니다(`var` 키워드는 완전히 선택 사항입니다).

[Local Variable Type Inference Style Guidelines](https://openjdk.org/projects/amber/guides/lvti-style-guide)도 참조하세요."
UselessQualifiedThis,codestyle,같은 클래스에서의 한정된 this 사용을 보고합니다.
UseShortArrayInitializer,codestyle,"배열 필드 또는 변수를 선언하고 초기화할 때, `new`를 사용하여 명시적으로 새 배열을 생성할 필요가 없습니다.
대신 중괄호로 배열의 초기 내용을 표현식으로 간단히 정의할 수 있습니다.

예: `int[] x = new int[] { 1, 2, 3 };`은 `int[] x = { 1, 2, 3 };`으로 작성할 수 있습니다."
UseUnderscoresInNumericLiterals,codestyle,"Java 1.7부터 숫자 리터럴은 밑줄을 사용하여 자릿수를 구분할 수 있습니다. 이 규칙은
            특정 길이 이상의 숫자 리터럴에 가독성을 높이기 위해 밑줄을 사용하도록 강제합니다.

            이 규칙은 현재 10진수(base 10) 리터럴만 지원합니다. 밑줄이 필요하지 않은
            허용 가능한 길이는 속성을 통해 설정할 수 있습니다. 해당 길이 미만이더라도
            잘못 배치된(3자리 그룹을 만들지 않는) 밑줄은 보고됩니다."
VariableCanBeInlined,codestyle,"지역 변수를 선언한 후 즉시 반환하거나 던지지 않아야 합니다. 이러한 변수 선언은
            불필요한 복잡성을 추가하고 코드를 읽기 어렵게 만듭니다. 값을 직접 반환하거나
            던지는 것이 더 간결하고 깔끔한 경우가 많습니다.

            이 규칙은 SonarSource 규칙 [S1488](https://sonarsource.github.io/rspec/#/rspec/S1488)을 구현합니다."
BooleanGetMethodName,codestyle,"boolean 또는 Boolean 결과를 반환하는 메서드는 이를 나타내는 술어문 형태로 이름을 지어야 합니다.
            예: 'isReady()', 'hasValues()', 'canCommit()', 'willFail()' 등. 이러한 메서드에 'get' 접두사 사용을 피하세요."
ExtendsObject,codestyle,명시적으로 Object를 상속할 필요가 없습니다.
GenericsNaming,codestyle,"제네릭 값에 대한 참조 이름은 단일 대문자로 제한되어야 합니다.

**더 이상 사용되지 않음:** 이 규칙은 PMD 7.17.0부터 더 이상 사용되지 않으며 PMD 8.0.0에서 제거될 예정입니다. 이 규칙은 타입 매개변수에 대해 더 포괄적이고 설정 가능한 명명 규칙을 제공하는 {% rule TypeParameterNamingConventions %}로 대체되었습니다."
LocalHomeNamingConvention,codestyle,Session EJB의 Local Home 인터페이스는 'LocalHome'으로 끝나야 합니다.
LocalInterfaceSessionNamingConvention,codestyle,Session EJB의 Local 인터페이스는 'Local'로 끝나야 합니다.
MDBAndSessionBeanNamingConvention,codestyle,EJB 명세에 따르면 모든 MessageDrivenBean 또는 SessionBean은 'Bean'으로 끝나야 합니다.
RemoteInterfaceNamingConvention,codestyle,Session EJB의 Remote 인터페이스에는 접미사가 없어야 합니다.
RemoteSessionInterfaceNamingConvention,codestyle,Session EJB의 Remote Home 인터페이스 타입은 'Home'으로 끝나야 합니다.
ShortClassName,codestyle,예를 들어 5자 미만의 짧은 클래스 이름은 권장되지 않습니다.
TypeParameterNamingConventions,codestyle,"제네릭 타입 및 메서드의 타입 매개변수에 대한 설정 가능한 명명 규칙입니다.
            이 규칙은 설정된 정규식과 일치하지 않는 타입 매개변수 선언을 보고합니다.
            타입 매개변수는 클래스, 인터페이스, enum, 레코드 및 메서드에 나타날 수 있습니다.

            기본적으로 이 규칙은 표준 Java 명명 규칙(단일 대문자)을 사용합니다."
UnnecessaryFullyQualifiedName,codestyle,"import 문을 사용하면 완전 한정 이름을 사용하지 않아도 됩니다. import 문으로 처리되는
완전 한정 이름의 사용은 불필요합니다. 완전 한정되지 않은 이름 사용을 고려하세요."
UnnecessaryImport,codestyle,"제거할 수 있는 import 문을 보고합니다. 사용되지 않거나, 중복되었거나,
            import하는 멤버가 java.lang 또는 현재 패키지에 있어 이미 암시적으로 범위에
            있는 경우입니다.

            일부 import가 해결되지 않는 경우(예: 불완전한 보조 클래스패스로 PMD를
            실행하는 경우), 오탐을 방지하기 위해 실제로 사용되지 않더라도 일부 import가
            보수적으로 사용된 것으로 표시될 수 있습니다."
UselessParentheses,codestyle,"괄호 표현식은 기본 연산자 우선순위 규칙을 재정의하는 데 사용됩니다. 제거해도
            연산자의 상대적 중첩이 변경되지 않는 괄호는 불필요합니다. 둘러싸는 표현식의
            의미를 변경하지 않기 때문입니다.

            엄밀히 말해 불필요하지만 가독성을 위해 유용하다고 여겨질 수 있는 괄호도 있습니다.
            이 규칙은 두 가지 종류의 불필요한 괄호에 대한 위반을 무시할 수 있습니다:
            - 다른 우선순위의 연산자를 구분하는 ""명확화"" 괄호. 불필요하지만 우선순위 규칙을
            명시적으로 만들어 잘 사용되지 않는 연산자에 유용할 수 있습니다. 예:
            ```java
                (a + b) &amp; c // `a + b &amp; c`와 동일하지만 아마 더 명확함
            ```
            보고하려면 `ignoreClarifying` 속성을 해제하세요.

            - 등호 연산자 주위의 다른 괄호 쌍과 시각적으로 균형을 맞추는 불필요한 ""균형"" 괄호.
            예를 들어, 이 두 표현식은 동일합니다:
            ```java
                (a == null) != (b == null)
                a == null != (b == null)
            ```
            오른쪽 괄호는 필수이고 왼쪽 괄호는 단지 시각적으로 더 보기 좋습니다.
            보고하려면 `ignoreBalancing` 속성을 해제하세요."
AbstractClassWithoutAnyMethod,design,"추상 클래스가 어떤 메서드도 제공하지 않는 경우, 인스턴스화를 의도하지 않은 단순한 데이터 컨테이너
역할을 할 수 있습니다. 이 경우 클래스를 오해의 소지가 있는 abstract로 만드는 것보다
인스턴스화를 방지하기 위해 private 또는 protected 생성자를 사용하는 것이 더 좋습니다."
AvoidThrowingNullPointerException,design,"NullPointerException을 수동으로 던지는 것을 피하세요. 대부분의 사람들은 가상 머신이 이 예외를 던진
것으로 생각하기 때문에 혼란을 줍니다. 메서드가 null 매개변수로 호출되는 것을 방지하려면
IllegalArgumentException을 대신 사용하여 프로그래머가 의도적으로 발생시킨 예외임을 명확히
할 수 있습니다. 그러나 이를 처리하는 더 좋은 방법이 있습니다:

>*Effective Java, 3판, 항목 72: 표준 예외를 사용하라*
>
>모든 잘못된 메서드 호출은 결국 잘못된 인수나 상태로 귀결되지만,
특정 종류의 잘못된 인수와 상태에 대해 표준적으로 사용되는 다른 예외가 있습니다.
null 값이 금지된 매개변수에 호출자가 null을 전달하는 경우, 관례상
IllegalArgumentException이 아닌 NullPointerException을 던져야 합니다.

이를 구현하려면 `java.util.Objects.requireNonNull()`을 사용하는 것이 좋습니다
(Java 1.7에서 도입). 이 메서드는 주로 여러 매개변수가 있는 메서드와 생성자에서
매개변수 유효성 검사를 수행하기 위해 설계되었습니다.

매개변수 유효성 검사는 다음과 같이 할 수 있습니다:
```
public class Foo {
    private String exampleValue;

    void setExampleValue(String exampleValue) {
      // check, throw and assignment in a single standard call
      this.exampleValue = Objects.requireNonNull(exampleValue, ""exampleValue must not be null!"");
    }
  }
```"
AvoidThrowingRawExceptionTypes,design,"특정 예외 타입을 던지는 것을 피하세요. 원시 RuntimeException, Throwable,
Exception 또는 Error를 던지는 대신, 하위 클래스 예외나 에러를 사용하세요."
ClassWithOnlyPrivateConstructorsShouldBeFinal,design,"컴파일 단위 외부에서 확장할 수 없는 클래스를 final로 만들 수 있다고 보고합니다.
모든 생성자가 private이므로 하위 클래스에서 상위 생성자를 호출할 수 없기 때문입니다."
AvoidRethrowingException,design,잡은 예외를 단순히 다시 던지기만 하는 catch 블록은 코드 크기와 런타임 복잡성만 증가시킵니다.
AvoidThrowingNewInstanceOfSameException,design,"잡은 예외를 같은 타입의 새 인스턴스로 감싸서 다시 던지기만 하는 catch 블록은
코드 크기와 런타임 복잡성만 증가시킵니다."
AvoidUncheckedExceptionsInSignatures,design,"메서드 또는 생성자의 `throws` 절에 있는 비검사 예외를 보고합니다.
Java는 호출자에게 비검사 예외를 처리하도록 강제하지 않으므로,
문서화 목적 외에는 불필요합니다. 더 나은 방법은
`@throws` Javadoc 태그로 예외 상황을 문서화하는 것으로, 더 설명적일 수 있습니다."
CognitiveComplexity,design,"매우 복잡한 메서드는 읽기 어렵고 유지보수 비용이 더 높습니다. 단일 메서드에 너무 많은 결정 로직을
            포함하면 동작을 이해하기 어렵고 수정하기 더 어려워집니다.

            인지적 복잡도는 사람이 메서드를 읽고 이해하는 것이 얼마나 어려운지를 측정하는 지표입니다.
            제어 흐름에 중단이 포함된 코드는 더 복잡하며, 언어 축약 표현의 사용은 복잡도 수준을 증가시키지
            않습니다. 중첩된 제어 흐름은 메서드를 이해하기 더 어렵게 만들 수 있으며, 제어 흐름의 추가
            중첩마다 인지적 복잡도가 증가합니다.

            인지적 복잡도에 대한 정보는 다음 원본 논문에서 확인할 수 있습니다:
            <https://www.sonarsource.com/docs/CognitiveComplexity.pdf>

            기본적으로 이 규칙은 복잡도가 15 이상인 메서드를 보고합니다. 보고된 메서드는 덜 복잡한
            구성 요소로 분해해야 합니다."
CollapsibleIfStatements,design,조건을 불리언 `&&` 연산자로 결합하여 병합할 수 있는 중첩된 'if' 문을 보고합니다.
CouplingBetweenObjects,design,"이 규칙은 객체 내의 고유한 속성, 지역 변수 및 반환 타입의 수를 계산합니다.
지정된 임계값보다 높은 수치는 높은 결합도를 나타낼 수 있습니다."
CyclomaticComplexity,design,"메서드의 복잡성은 유지보수 비용과 가독성에 직접적으로 영향을 미칩니다. 단일 메서드에 너무 많은 결정 로직을
집중시키면 동작을 읽고 변경하기 어려워집니다.

순환 복잡도는 메서드의 결정 지점 수에 메서드 진입점 1을 더하여 메서드의 복잡성을 평가합니다.
결정 지점은 제어 흐름이 프로그램의 다른 위치로 이동하는 곳입니다. 따라서 `if`, `while`, `for`,
`case`와 같은 모든 제어 흐름 문을 포함합니다. 계산에 대한 자세한 내용은
{% jdoc java::lang.java.metrics.JavaMetrics#CYCLO %} 문서를 참조하세요.

일반적으로 1-4는 낮은 복잡도, 5-7은 보통 복잡도, 8-10은 높은 복잡도,
11 이상은 매우 높은 복잡도를 나타냅니다. 기본적으로 이 규칙은 복잡도가 10 이상인 메서드를 보고합니다.
또한 보통 복잡도의 메서드가 많은 클래스는 개별 메서드가 직접 보고되지 않더라도
메서드 복잡도의 합이 80에 도달하면 보고됩니다.

보고된 메서드는 여러 개의 작은 메서드로 분해해야 합니다. 보고된 클래스는
하위 구성 요소로 분해하는 것이 좋습니다."
DataClass,design,"데이터 클래스는 대부분의 상태를 노출하면서 복잡한 기능이 없는 단순한 데이터 홀더입니다.
기능의 부재는 해당 동작이 다른 곳에 정의되어 있음을 나타낼 수 있으며, 이는 데이터-동작
근접성이 낮다는 신호입니다. 내부를 직접 노출함으로써 데이터 클래스는 캡슐화를 깨뜨리고,
따라서 시스템의 유지보수성과 이해도를 저하시킵니다. 또한 클래스는 데이터 표현에 강하게
의존하는 경향이 있어 취약한 설계로 이어집니다.

데이터 클래스를 리팩토링할 때는 좋은 데이터-동작 근접성을 회복하는 데 초점을 맞춰야 합니다.
대부분의 경우 데이터에 대해 정의된 연산을 클래스 내부로 이동하는 것을 의미합니다.
일부 다른 경우에는 클래스를 완전히 제거하고 데이터를 이전 클라이언트 클래스로 이동하는 것이
합리적일 수 있습니다.

이 규칙은 메트릭을 사용하여 탐지 전략을 구현합니다. 위반 메시지는
이러한 메트릭의 값에 대한 정보를 제공합니다:
* WMC: 클래스 복잡도 측정, {% jdoc java::lang.java.metrics.JavaMetrics#WEIGHED_METHOD_COUNT %} 참조
* WOC: 클래스의 '비사소성' 측정, {% jdoc java::lang.java.metrics.JavaMetrics#WEIGHT_OF_CLASS %} 참조
* NOPA: 공개 속성 수, {% jdoc java::lang.java.metrics.JavaMetrics#NUMBER_OF_PUBLIC_FIELDS %} 참조
* NOAM: 공개 접근자 메서드 수, {% jdoc java::lang.java.metrics.JavaMetrics#NUMBER_OF_ACCESSORS %} 참조

이 규칙은 다음 속성을 모두 가진 클래스를 찾아 갓 클래스를 식별합니다:
* 높은 NOPA + NOAM
* 낮은 WOC
* 낮은 WMC"
DoNotExtendJavaLangError,design,Error는 시스템 예외입니다. 이를 확장하지 마세요.
ExceptionAsFlowControl,design,"이 규칙은 감싸는 try 문에서 던져지고 잡히는 예외를 보고합니다.
예외를 `goto` 문의 한 형태로 사용하는 것은 권장되지 않습니다. 이는 실제 예외를
숨기고, 특히 디버깅 시 제어 흐름을 불명확하게 만들 수 있습니다.
위반을 수정하려면 필요한 유효성 검사를 추가하거나 대체 제어 구조를 사용하세요."
ExcessiveImports,design,"많은 수의 임포트는 객체 내의 높은 결합도를 나타낼 수 있습니다. 이 규칙은
고유한 임포트의 수를 계산하고 사용자 지정 임계값을 초과하면 위반을 보고합니다."
ExcessiveParameterList,design,"매개변수가 많은 메서드는 유지보수가 어렵습니다. 특히 대부분의 매개변수가 같은 데이터 타입을
공유하는 경우 더욱 그렇습니다. 이러한 상황은 일반적으로 많은 매개변수를 감싸는 새로운 객체가
필요함을 나타냅니다."
ExcessivePublicCount,design,"많은 수의 public 메서드와 속성을 가진 클래스는 조합적 부작용이 빠르게 증가하고 위험이 커지므로
불균형적인 테스트 노력을 필요로 합니다. 이러한 클래스를 더 작은 클래스로 리팩토링하면
테스트 가능성과 신뢰성이 향상될 뿐만 아니라 새로운 변형을 쉽게 개발할 수 있습니다."
FinalFieldCouldBeStatic,design,"final 필드가 컴파일 타임 상수에 할당된 경우, static으로 만들어 런타임에 각 객체에서
오버헤드를 줄일 수 있습니다."
GodClass,design,"갓 클래스 규칙은 메트릭을 사용하여 갓 클래스 설계 결함을 탐지합니다. 갓 클래스는 너무 많은 일을 하고,
매우 크고 지나치게 복잡합니다. 더 객체 지향적이 되도록 분리해야 합니다.
이 규칙은 ""Object-Oriented Metrics in Practice""에 설명된 탐지 전략을 사용합니다.
위반은 전체 클래스에 대해 보고됩니다.

이 규칙은 메트릭을 사용하여 탐지 전략을 구현합니다. 위반 메시지는
이러한 메트릭의 값에 대한 정보를 제공합니다:
* WMC: 클래스 복잡도 측정, {% jdoc java::lang.java.metrics.JavaMetrics#WEIGHED_METHOD_COUNT %} 참조
* ATFD: 클래스가 외부 데이터를 얼마나 사용하는지 측정, {% jdoc java::lang.java.metrics.JavaMetrics#ACCESS_TO_FOREIGN_DATA %} 참조
* TCC: 메서드들이 얼마나 밀접하게 관련되어 있는지 측정, {% jdoc java::lang.java.metrics.JavaMetrics#TIGHT_CLASS_COHESION %} 참조

이 규칙은 다음 속성을 모두 가진 클래스를 찾아 갓 클래스를 식별합니다:
* 높은 WMC
* 높은 ATFD
* 낮은 TCC

참고 문헌:

Michele Lanza and Radu Marinescu. *Object-Oriented Metrics in Practice:
Using Software Metrics to Characterize, Evaluate, and Improve the Design
of Object-Oriented Systems.* Springer, Berlin, 1 edition, October 2006. Page 80."
ImmutableField,design,"객체 초기화가 끝난 후 값이 변경되지 않는 non-final 필드를 보고하며,
따라서 final로 표시할 수 있습니다.

이 규칙은 필드 값 자체가 깊게 불변인지는 강제하지 않습니다.
모든 멤버 필드가 final로 선언되어 있더라도 객체는 여전히 변경 가능한 상태를 가질 수 있습니다.
이를 얕은 불변성이라고 합니다. 변경 가능성에 대한 자세한 내용은
*Effective Java, 3판, 항목 17: 변경 가능성을 최소화하라*를 참조하세요.

제한 사항: 현재는 private 필드만 확인할 수 있습니다."
InvalidJavaBean,design,"[JavaBeans API 명세](https://download.oracle.com/otndocs/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/)를 따르지 않는 빈을 식별합니다.

각 non-static 필드는 getter와 setter 메서드를 모두 가져야 합니다. 필드가 내부적으로만 사용되고
빈 프로퍼티가 아닌 경우, 해당 필드는 `transient`로 표시해야 합니다.

이 규칙은 필드의 타입이 getter의 반환 타입과 동일한지 확인합니다. 그리고 이 타입이
setter에서 사용되는 타입과 일치하는지 확인합니다.

이 규칙은 또한 인자가 없는 생성자 또는 기본 생성자가 사용 가능한지 확인합니다.

선택적으로 이 규칙은 빈이 `java.io.Serializable`을 구현하는지도 확인합니다. 이는 원래
JavaBeans 명세의 요구 사항이지만, 요즘 프레임워크들은 이를 엄격하게 요구하지 않습니다.

빈이 아닌 클래스에서 많은 거짓 양성을 피하기 위해, 이 규칙은 `packages` 프로퍼티를
구성하여 명시적으로 활성화해야 합니다."
LawOfDemeter,design,"디미터 법칙은 ""친구하고만 대화하라""라는 간단한 규칙입니다. 이 법칙은
서로 다른 추상화 수준의 클래스나 객체 간의 결합도를 줄이기 위해
특정 거리 정의에 따라 ""너무 먼 곳""에서 데이터를 가져오는 것을 금지합니다.

이 규칙은 객체가 얼마나 ""먼지""를 정량화하는 ""차수(degree)"" 개념을 사용합니다.
차수가 너무 높은 표현식은 특정 방식으로만 사용할 수 있습니다. 표현식의 차수는
귀납적으로 정의됩니다:
- `this`의 차수는 0
- 메서드 매개변수의 차수는 1
- 메서드에서 새로 생성된 객체의 차수는 1
- 정적 변수의 차수는 1
- `expr.field`와 같은 필드 접근 표현식의 차수는 `expr`의 차수에 1을 더한 값
- `expr.getFoo()`와 같은 ""getter 표현식""의 차수는 `expr`의 차수에 1을 더한 값
- `expr.withFoo("""")`와 같은 ""변환 표현식""의 차수는 `expr`의 차수와 동일
- 변수의 차수는 해당 변수에 도달하는 모든 할당의 최대 차수

직관적으로 getter를 더 많이 호출할수록 차수가 증가합니다. 결국
차수가 보고 임계값(속성 `trustRadius`)에 도달하면 해당 표현식이 보고됩니다.
계산의 세부 사항은 컬렉션 사용(리스트나 배열에 있는 객체는 컨테이너와 같은 차수를 가짐),
빌더 패턴, 추상화 경계를 깨지 않는 것으로 보이는 getter 등의 일반적인 패턴을
허용하도록 더 복잡하게 구성되어 있습니다.

이 규칙은 많은 거짓 양성과 낮은 우선순위 경고가 발생하기 쉽습니다.
`trustRadius` 속성을 증가시키면 이를 크게 줄일 수 있습니다. 기본
`trustRadius` 1은 원래 디미터 법칙에 해당합니다 (신뢰할 수 없는 값에 대해
하나의 getter 호출만 허용됩니다). 주어진 `trustRadius` 값에 대해:
- `trustRadius` 이하의 차수를 가진 표현식은 보고되지 않습니다
- 정확히 `trustRadius + 1` 차수의 표현식은 현재 메서드에서 반환되거나
다른 메서드의 인수로 전달되는 경우를 제외하고 보고됩니다. 이 예외가 없으면
예를 들어 메서드 매개변수에서 어떤 정보도 추출할 수 없습니다.
- `trustRadius + 1`보다 엄격히 큰 차수의 값은 보고되지 않습니다.
직관적으로 차수 `n > 1`의 값을 얻으려면 차수 `n - 1`의 표현식을 사용해야 하므로,
`n > trustRadius + 1`인 경우, 보고될 차수 `trustRadius + 1`의 값을 사용하고 있는 것입니다.

참고 문헌:

*   Andrew Hunt, David Thomas, and Ward Cunningham. The Pragmatic Programmer. From Journeyman to Master. Addison-Wesley Longman, Amsterdam, October 1999.;
*   K.J. Lieberherr and I.M. Holland. Assuring good style for object-oriented programs. Software, IEEE, 6(5):38–48, 1989.;
*   &lt;http://www.ccs.neu.edu/home/lieber/LoD.html>
*   &lt;http://en.wikipedia.org/wiki/Law_of_Demeter>"
LogicInversion,design,논리 보수 연산자로 전체 표현식을 부정하는 대신 반대 연산자를 사용하세요.
LoosePackageCoupling,design,"구성된 허용 클래스 중 하나를 사용하는 경우를 제외하고,
구성된 패키지 계층 외부에서 해당 패키지 계층의 클래스를 사용하는 것을 피하세요."
MutableStaticState,design,"non-private 정적 필드는 final로 선언하여 상수(또는 불변 참조)로 만들어야 합니다.

            non-private non-final 정적 필드는 캡슐화를 깨뜨리고 찾기 어려운
            버그를 유발할 수 있습니다. 이러한 필드는 프로그램 어디서든 수정할 수 있기 때문입니다.
            호출자는 non-private non-final 정적 필드에 쉽게 접근하고 수정할 수 있습니다.
            접근이나 수정을 방어할 수 없으며, 새로 설정된 값을 검증할 수도 없습니다.

            이 규칙을 사용하는 경우,
            {% rule java/errorprone/AssignmentToNonFinalStatic %} 규칙은 필요하지 않습니다."
NcssCount,design,"이 규칙은 NCSS(비주석 소스 문장) 메트릭을 사용하여 클래스, 메서드 또는 생성자의
코드 줄 수를 결정합니다. NCSS는 주석과 빈 줄을 무시하고 실제 문장만 계산합니다.
계산에 대한 자세한 내용은 {% jdoc java::lang.java.metrics.JavaMetrics#NCSS %} 문서를 참조하세요."
NPathComplexity,design,"메서드의 NPath 복잡도는 해당 메서드를 통과하는 비순환 실행 경로의 수입니다.
순환 복잡도가 메서드의 결정 지점 수를 세는 반면, NPath는 메서드 블록의
처음부터 끝까지의 전체 경로 수를 셉니다. 이 메트릭은 같은 블록 내
문장의 복잡도를 곱하기 때문에 기하급수적으로 증가합니다. 계산에 대한 자세한 내용은
{% jdoc java::lang.java.metrics.JavaMetrics#NPATH %} 문서를 참조하세요.

일반적으로 200의 임계값이 복잡도를 줄이고 가독성을 높이기 위한
조치를 취해야 하는 시점으로 간주됩니다."
PublicMemberInNonPublicType,design,"non-public 타입은 자체 멤버를 public으로 선언해서는 안 됩니다. 가시성이 실질적으로
private, package-private 또는 protected로 제한되므로 public 수정자의 사용이 오해를 불러일으킵니다.
non-public 타입 내에서 멤버를 public으로 선언하면 혼란을 야기하고, 나중에 해당 타입을
public으로 변경할 경우 모든 public 멤버가 노출되는 의도치 않은 결과를 초래할 수 있습니다.
그러나 non-public 타입이 상위 클래스로부터 public 멤버를 상속받는 것은 상위 클래스의 설계에
포함된 것이므로 허용됩니다.

이러한 문제를 피하기 위해, 이 멤버들은 적절하게 protected, package-private 또는 private으로
선언해야 합니다. 이러한 멤버의 가시성을 변경하면 public 하위 타입의 API에 의도치 않게
영향을 미칠 수 있습니다. 구체적으로, package-private 상위 타입의 public 하위 타입은
상위 타입의 모든 public 메서드를 상속합니다. 이 메서드들을 private으로 변환하면
하위 타입에서도 제거되어 하위 타입의 public API가 의도치 않게 변경될 수 있습니다."
SignatureDeclareThrowsException,design,"메서드/생성자는 일반적인 java.lang.Exception을 명시적으로 던져서는 안 됩니다. 메서드에서
어떤 예외가 던져질 수 있는지 불분명하기 때문입니다. 이러한 모호한 인터페이스를
문서화하고 이해하기 어려울 수 있습니다. RuntimeException에서 파생된 클래스나
검사 예외를 사용하세요."
SimplifiedTernary,design,"`condition ? literalBoolean : foo` 또는 `condition ? foo : literalBoolean` 형태의
삼항 표현식을 보고합니다.

이러한 표현식은 다음과 같이 단순화할 수 있습니다:
* `condition ? true : expr`은 `condition || expr`로 단순화
* `condition ? false : expr`은 `!condition && expr`로 단순화
* `condition ? expr : true`은 `!condition || expr`로 단순화
* `condition ? expr : false`은 `condition && expr`로 단순화"
SimplifyBooleanExpressions,design,불리언 표현식에서 불필요한 비교를 피하세요. 이는 목적이 없고 가독성에 영향을 미칩니다.
SimplifyBooleanReturns,design,"불리언을 반환할 때 불필요한 if-then-else 문을 피하세요. 조건 테스트의 결과를
대신 반환할 수 있습니다."
SimplifyConditional,design,instanceof 앞에 null을 검사할 필요가 없습니다; instanceof 키워드는 null 인수가 주어지면 false를 반환합니다.
SingularField,design,"지역 변수로 변환할 수 있는 필드를 보고합니다. 이는 필드가 사용되는 모든 메서드에서
처음 읽기 전에 할당되기 때문입니다. 따라서 메서드 호출 전에 필드가 가지고 있던
값은 관찰되지 않을 수 있으므로, 포함 객체에 저장할 필요가 없을 수 있습니다.

제한 사항:
* 현재는 private 필드만 확인할 수 있습니다.
* 이 규칙은 스레딩을 인식하지 않으므로 동시성 코드에서 거짓 양성이 발생할 수 있습니다.
이러한 거짓 양성은 억제로 처리하는 것이 가장 좋습니다 (`ignoredAnnotations` 속성도 참조하세요)."
SwitchDensity,design,"switch 문에서 레이블 대비 문장의 비율이 높다는 것은 switch 문이 과부하되어 있음을
의미합니다. 문장을 새로운 메서드로 이동하거나 switch 변수를 기반으로
하위 클래스를 생성하는 것을 고려하세요."
TooManyFields,design,"필드가 너무 많은 클래스는 다루기 어려울 수 있으며, 관련 필드를 새로운 객체로 그룹화하여
필드 수를 줄이도록 재설계해야 할 수 있습니다. 예를 들어, 개별 city/state/zip 필드를
가진 클래스는 이를 단일 Address 필드로 통합할 수 있습니다."
TooManyMethods,design,"메서드가 너무 많은 클래스는 복잡도를 줄이고 더 세분화된 객체를 만들기 위해
리팩토링하기에 좋은 후보입니다."
UselessOverridingMethod,design,오버라이딩 메서드가 단순히 상위 클래스에 정의된 동일한 메서드를 호출하기만 합니다.
UseObjectForClearerAPI,design,"public 메서드를 작성할 때는 API 관점에서 생각해야 합니다. 메서드가 public이면 다른 클래스가
이를 사용하므로 포괄적이고 발전 가능한 API를 제공해야 합니다. 많은 정보를 단순한
String의 나열로 전달하는 경우, 그 정보를 나타내는 객체를 사용하는 것을 고려하세요.
더 간단한 API(예: doWork(Workload workload)와 같은)를 얻을 수 있고, 더 중요하게는
추가 데이터를 전달해야 할 때 API를 수정하지 않고 Workload를 수정하거나 확장하기만
하면 됩니다."
UseUtilityClass,design,"정적 메서드만 있는 클래스의 경우 유틸리티 클래스로 만드는 것을 고려하세요.
이는 추상 클래스에는 적용되지 않습니다. 하위 클래스에 비정적 메서드가 포함될 수
있기 때문입니다. 또한 이 클래스를 유틸리티 클래스로 만들려면
인스턴스화를 방지하기 위해 private 생성자를 추가하는 것을 잊지 마세요.
(참고: 이 사용법은 PMD 5.1.0 이전에는 UseSingleton으로 알려져 있었습니다)."
CommentContent,documentation,정치적으로 올바른 표현을 위한 규칙입니다... 누구에게도 불쾌감을 주고 싶지 않습니다.
CommentRequired,documentation,특정 언어 요소에 대해 Javadoc(공식) 주석이 필수인지(또는 불필요한지) 여부를 나타냅니다.
CommentSize,documentation,헤더가 아닌 주석의 크기가 지정된 제한 범위 내에 있는지 확인합니다.
DanglingJavadoc,documentation,"클래스, 메서드 또는 필드에 속하지 않는 Javadoc 주석은 JavaDoc 도구에 의해 무시되며
생성된 API 문서에 포함되지 않습니다. 이러한 주석은 잘못된 위치에 있거나
(예: 어노테이션과 메서드 선언 사이) 블록 주석이어야 합니다.

이 위반을 수정하려면 주석을 올바른 위치로 이동하거나,
블록 주석으로 변환하거나, 완전히 제거해야 합니다."
UncommentedEmptyConstructor,documentation,"주석 없는 빈 생성자 규칙은 생성자에 구문이 없으면서 주석도 없는 경우를 찾습니다.
빈 생성자에 명시적으로 주석을 작성하면 의도적인(주석이 있는) 빈 생성자와
의도하지 않은 빈 생성자를 구분하기 쉬워집니다."
UncommentedEmptyMethodBody,documentation,"주석 없는 빈 메서드 본문 규칙은 메서드 본문에 구문이 없으면서 주석도 없는 경우를 찾습니다.
빈 메서드 본문에 명시적으로 주석을 작성하면 의도적인(주석이 있는) 빈 메서드와
의도하지 않은 빈 메서드를 구분하기 쉬워집니다."
ConstructorCallsOverridableMethod,errorprone,"객체 초기화 중에 `this`에서 오버라이드 가능한 메서드 호출을 보고합니다. 이들은 불완전하게 생성된 객체에서 호출되며, 오버라이드된 경우 디버그하기 어려울 수 있습니다.
이는 하위 클래스가 일반적으로 모든 메서드에서 상위 클래스가 완전히 초기화되었다고 가정하기 때문입니다. 그렇지 않은 경우 생성자에서 버그가 나타날 수 있습니다. 예를 들어, 아직 null인 일부 필드가 NullPointerException을 유발하거나 나중에 폭발하도록 다른 곳에 저장될 수 있습니다.

이 문제를 피하려면 생성자에서 static, private 또는 final 메서드만 사용하세요.
이러한 메서드도 안전하려면 전이적으로 오버라이드 가능한 메서드를 호출해서는 안 됩니다."
EqualsNull,errorprone,null 테스트에 equals() 메서드를 사용해서는 안 됩니다. 대신 '==' 연산자를 사용해야 합니다.
ReturnEmptyCollectionRatherThanNull,errorprone,"컬렉션(배열, Collection 또는 Map 등)을 반환하는 모든 메서드에서는 null 참조 대신 빈 컬렉션을 반환하는 것이 좋습니다.
이렇게 하면 모든 결과에 대한 null 검사가 불필요해지고 의도치 않은 NullPointerException을 방지할 수 있습니다.

Effective Java, 3판, 항목 54: null 대신 빈 컬렉션이나 배열을 반환하라 참조"
AvoidAssertAsIdentifier,errorprone,"`assert`라는 용어를 사용하면 예약어이므로 최신 버전의 Java와 충돌합니다.

Java 1.4부터 `assert` 토큰은 예약어가 되었으며, 이를 식별자로 사용하면 Java 1.4 이후 버전에서 컴파일 오류가 발생합니다. 따라서 이 규칙은 Java 1.4 이전의 오래된 Java 코드에만 유용합니다. Java 업데이트 전에 문제가 되는 코드를 식별하는 데 사용할 수 있습니다."
AvoidBranchingStatementAsLastInLoop,errorprone,"루프의 마지막 부분에 분기문을 사용하는 것은 버그일 수 있으며 혼란스럽습니다.
사용법이 버그가 아닌지 확인하거나 다른 접근 방식을 고려하세요."
AvoidEnumAsIdentifier,errorprone,"`enum`이라는 용어를 사용하면 예약어이므로 최신 버전의 Java와 충돌합니다.

Java 1.5부터 `enum` 토큰은 예약어가 되었으며, 이를 식별자로 사용하면 Java 1.5 이후 버전에서 컴파일 오류가 발생합니다. 따라서 이 규칙은 Java 1.5 이전의 오래된 Java 코드에만 유용합니다. Java 업데이트 전에 문제가 되는 코드를 식별하는 데 사용할 수 있습니다."
AvoidLosingExceptionInformation,errorprone,"catch 블록에서 예외의 접근자를 호출하면서 정보를 사용하지 않는 문은 코드 크기만 늘립니다. 호출을 제거하거나 반환 결과를 사용하세요.

**더 이상 사용되지 않음:** 이 규칙은 PMD 7.17.0부터 더 이상 사용되지 않으며 PMD 8.0.0에서 제거될 예정입니다.
이 규칙은 {% rule UselessPureMethodCall %}로 대체되었습니다."
AvoidMultipleUnaryOperators,errorprone,"여러 단항 연산자의 사용은 문제가 될 수 있으며 혼란스럽습니다.
의도된 사용이 버그가 아닌지 확인하거나 표현식을 단순화하는 것을 고려하세요."
BrokenNullCheck,errorprone,"null 검사가 깨져 있어 자체적으로 NullPointerException을 던질 것입니다.
|| 대신 &amp;&amp;를 사용하거나 그 반대일 가능성이 높습니다."
DoNotCallGarbageCollectionExplicitly,errorprone,"`System.gc()`, `Runtime.getRuntime().gc()`, `System.runFinalization()` 호출은 권장되지 않습니다.
코드는 `-Xdisableexplicitgc` 옵션을 사용하여 가비지 컬렉션을 비활성화하든 그렇지 않든 동일한 동작을 해야 합니다.

또한 ""현대적인"" JVM은 가비지 컬렉션을 매우 잘 처리합니다. 메모리 누수와 관련 없는 메모리 사용 문제가 애플리케이션 내에서 발생하면, 코드 자체가 아닌 JVM 옵션으로 처리해야 합니다."
MoreThanOneLogger,errorprone,"일반적으로 각 클래스에서 하나의 로거만 사용됩니다. 이 규칙은 slf4j, log4j, Java Util Logging 및 log4j2(6.19.0부터)를 지원합니다."
ProperCloneImplementation,errorprone,Object clone()은 super.clone()으로 구현해야 합니다.
SingleMethodSingleton,errorprone,"일부 클래스에는 오버로드된 getInstance가 포함되어 있습니다. 오버로드된 getInstance 메서드의 문제는
오버로드된 메서드를 사용하여 생성된 인스턴스가 캐시되지 않아
매 호출마다 새 객체가 생성된다는 것입니다."
SingletonClassReturningNewInstance,errorprone,"싱글턴 클래스는 하나의 인스턴스만 가져야 합니다. 인스턴스가 이미 생성되었는지
확인하지 않으면 여러 인스턴스가 생성될 수 있습니다."
SuspiciousEqualsMethodName,errorprone,"메서드 이름과 매개변수 수가 `Object.equals`와 의심스럽게 유사하여 이를 재정의하려는 의도를 나타낼 수 있습니다.
그러나 이 메서드는 `Object.equals`를 재정의하지 않고 오버로드합니다.
`Object.equals` 메서드를 오버로드하는 것은 다른 프로그래머에게 혼란을 주고, 오류가 발생하기 쉬우며 유지보수가 어렵습니다.
특히 상속을 사용할 때 하위 클래스에서 사용되는 `@Override` 어노테이션이 잘못된 안정감을 줄 수 있습니다.
`Object.equals` 메서드에 대한 자세한 내용은 Effective Java, 3판, 항목 10: equals를 재정의할 때는
일반 규약을 따르라를 참조하세요."
AssignmentInOperand,errorprone,피연산자에서의 할당을 피하세요. 이는 코드를 더 복잡하고 읽기 어렵게 만들 수 있습니다.
AssignmentToNonFinalStatic,errorprone,static 필드의 안전하지 않은 사용 가능성을 식별합니다.
AvoidAccessibilityAlteration,errorprone,"`getDeclaredConstructors()`, `getDeclaredMethods()`, `getDeclaredFields()`와 같은 메서드는 private 생성자, 메서드, 필드도 반환합니다. 이들은 `setAccessible(true)`를 호출하여 접근 가능하게 만들 수 있습니다.
이는 캡슐화 원칙을 위반하여 정상적으로 보호되는 데이터에 대한 접근을 허용합니다.

이 규칙은 `setAccessible` 호출을 감지하고 접근성 변경 가능성을 찾습니다.
`setAccessible` 호출이 `PrivilegedAction` 내에 래핑되어 있으면, 접근 변경이 의도적인 것으로 간주되어 보고되지 않습니다.

Java 17에서는 `PrivilegedAction` 실행에 사용되는 보안 관리자가 더 이상 사용되지 않습니다: [JEP 411: Deprecate the Security Manager for Removal](https://openjdk.org/jeps/411).
향후 호환성을 위해, 의도적인 접근 변경은 일반적인 억제 방법(예: `@SuppressWarnings` 어노테이션 사용)으로 억제해야 합니다."
AvoidCallingFinalize,errorprone,"Object.finalize() 메서드는 가비지 컬렉터가 객체에 대한 참조가 더 이상 없다고 판단할 때 호출합니다. 애플리케이션 로직에서 직접 호출해서는 안 됩니다.

Oracle은 JDK 9부터 Object.finalize()를 더 이상 사용되지 않음(deprecated)으로 선언했습니다."
AvoidCatchingGenericException,errorprone,"try-catch 블록에서 일반적인 예외를 캐치하지 마세요. 지나치게 광범위한 예외 타입을 캐치하면 코드에서 실제로 무엇이 잘못될 수 있는지 이해하기 어렵고 실제 문제를 숨길 수 있습니다.

**이러한 예외를 캐치하지 말아야 하는 이유:**

* **Exception**: 모든 체크 예외의 기본 클래스입니다. 이를 캐치하면 모든 가능한 체크 예외를 동일하게 처리하게 되는데, 이는 거의 적절하지 않으며 오류 처리를 덜 정밀하게 만듭니다.

* **RuntimeException**: 프로그래밍 오류(논리 버그 등)를 나타냅니다. 일반적으로 캐치하여 처리하기보다는 코드에서 수정해야 합니다. 이를 캐치하면 개발 중에 해결해야 할 버그를 숨길 수 있습니다.

* **NullPointerException**: 일반적으로 프로그래밍 오류(null 참조 접근)를 나타냅니다. 이를 캐치하기보다는 null 검사나 방어적 프로그래밍을 통해 null 포인터 역참조를 피하도록 코드를 작성해야 합니다.

* **Throwable**: 모든 오류와 예외의 상위 클래스입니다. 이를 캐치하면 복구 가능한 예외와 심각한 오류(OutOfMemoryError 등)를 동일하게 처리하게 되어 위험합니다.

* **Error**: 애플리케이션이 처리를 시도해서는 안 되는 심각한 문제(OutOfMemoryError, StackOverflowError 등)를 나타냅니다. Error를 캐치하면 복구 불가능한 상황에서 JVM이 적절하게 종료되는 것을 방해할 수 있습니다.

**더 나은 접근 방식:**
- 의미 있게 처리할 수 있는 특정 예외 타입을 캐치하세요
- 다른 처리가 필요한 예외 타입에 대해 여러 catch 블록을 사용하세요
- 예외를 캐치하기보다는 방어적 프로그래밍 기법을 사용하여 예외를 방지하는 것을 고려하세요"
AvoidCatchingNPE,errorprone,"코드는 정상적인 상황에서 NullPointerException을 던져서는 안 됩니다. catch 블록이 원래 오류를 숨겨 나중에 더 미묘한 문제를 일으킬 수 있습니다.

**더 이상 사용되지 않음:** 이 규칙은 PMD 7.18.0부터 더 이상 사용되지 않으며 PMD 8.0.0에서 제거될 예정입니다.
이 규칙은 {% rule AvoidCatchingGenericException %}에 통합되었으며, 이제 어떤 예외가 위반을 유발하는지 설정할 수 있습니다."
AvoidCatchingThrowable,errorprone,"Throwable 오류를 캐치하는 것은 범위가 매우 넓기 때문에 권장되지 않습니다. OutOfMemoryError와 같은 런타임 문제를 포함하며, 이는 별도로 노출되고 관리되어야 합니다.

**더 이상 사용되지 않음:** 이 규칙은 PMD 7.18.0부터 더 이상 사용되지 않으며 PMD 8.0.0에서 제거될 예정입니다.
이 규칙은 {% rule AvoidCatchingGenericException %}에 통합되었으며, 이제 어떤 예외가 위반을 유발하는지 설정할 수 있습니다."
AvoidDecimalLiteralsInBigDecimalConstructor,errorprone,"""new BigDecimal(0.1)""의 결과가 정확히 0.1이라고 생각할 수 있지만, 실제로는 .1000000000000000055511151231257827021181583404541015625와 같습니다.
이는 0.1이 double(또는 유한한 길이의 이진 분수)로 정확하게 표현될 수 없기 때문입니다. 따라서 생성자에 전달되는 long 값은 외관과 달리 정확히 0.1이 아닙니다.

반면에 (String) 생성자는 완벽하게 예측 가능합니다: 'new BigDecimal(""0.1"")'은 예상대로 정확히 0.1과 같습니다. 따라서 일반적으로 이 생성자보다 (String) 생성자를 사용하는 것이 권장됩니다."
AvoidDuplicateLiterals,errorprone,중복된 문자열 리터럴을 포함하는 코드는 일반적으로 문자열을 상수 필드로 선언하여 개선할 수 있습니다.
AvoidFieldNameMatchingMethodName,errorprone,"필드 이름이 메서드와 동일한 이름을 가지면 혼란스러울 수 있습니다. 이는 허용되지만, 정보(필드)와 동작(메서드)을 구분하는 명확한 네이밍이 아닙니다. Smalltalk에 익숙한 개발자들은 메서드가 접근자 메서드를 나타내므로 이 접근 방식을 선호하기도 합니다."
AvoidFieldNameMatchingTypeName,errorprone,"필드 이름이 선언 타입 이름과 일치하면 다소 혼란스럽습니다.
이는 타입 및/또는 필드 이름을 더 신중하게 선택해야 한다는 것을 의미할 수 있습니다."
AvoidInstanceofChecksInCatchClause,errorprone,캐치된 각 예외 타입은 자체 catch 절에서 처리되어야 합니다.
AvoidLiteralsInIfCondition,errorprone,"조건문에서 하드코딩된 리터럴 사용을 피하세요. 설명적인 이름을 가진 static 변수나 private 멤버로 선언하면 유지보수성이 향상됩니다. 기본적으로 리터럴 ""-1""과 ""0""은 무시됩니다.
""ignoreMagicNumbers"" 속성으로 더 많은 예외를 정의할 수 있습니다.

이 규칙은 기본적으로 깊은 표현식을 고려하지 않지만, `ignoreExpressions` 속성을 통해 활성화할 수 있습니다.
이 속성을 false로 설정하면 `i == 1 + 5`와 같은 if 조건도 보고됩니다. 이 경우 표현식에 여러 리터럴이 포함되어 있으면 ignoreMagicNumbers 속성은 고려되지 않습니다."
AvoidUsingOctalValues,errorprone,"Java에서 0으로 시작하는 정수 리터럴은 8진수(기수 8) 값으로 해석되어 예기치 않은 동작과 버그를 유발할 수 있습니다. 대부분의 개발자는 10진수(기수 10) 해석을 기대하므로 8진수 리터럴은 일반적인 혼란과 오류의 원인이 됩니다. 예를 들어, 012는 예상되는 12가 아닌 10진수로 10과 같습니다.
이 규칙은 10진수 값으로 오해될 수 있는 정수 리터럴을 플래그하여 이러한 실수를 방지하는 데 도움을 줍니다.
앞에 0이 없는 10진수 리터럴을 사용하거나, 의도한 기수를 명확히 하기 위해 16진수의 경우 0x, 2진수의 경우 0b와 같은 명시적 접두사를 사용하세요."
CallSuperFirst,errorprone,Super는 메서드의 시작 부분에서 호출되어야 합니다
CallSuperLast,errorprone,Super는 메서드의 끝 부분에서 호출되어야 합니다
CheckSkipResult,errorprone,skip() 메서드는 요청한 것보다 적은 수의 바이트를 건너뛸 수 있습니다. 반환된 값을 확인하여 그러한 경우인지 아닌지 확인하세요.
ClassCastExceptionWithToArray,errorprone,"Collection에서 특정 클래스의 배열을 파생할 때, `toArray()` 메서드의 매개변수로 동일한 클래스의 배열을 제공해야 합니다. 그렇지 않으면 `ClassCastException`이 발생합니다."
CloneMethodMustBePublic,errorprone,"Java 매뉴얼에 따르면 ""관례상, 이 인터페이스를 구현하는 클래스는 Object.clone()(protected)을 public 메서드로 오버라이드해야 합니다."""
CloneMethodMustImplementCloneable,errorprone,"clone() 메서드는 클래스가 Cloneable 인터페이스를 구현하는 경우에만 구현해야 합니다. 단, CloneNotSupportedException만 던지는 final 메서드는 예외입니다.

이 규칙은 클래스가 Cloneable 클래스를 구현하거나 확장하는지도 감지할 수 있습니다."
CloneMethodReturnTypeMustMatchClassName,errorprone,"클래스가 `Cloneable`을 구현하면 `clone()` 메서드의 반환 타입은 클래스 이름이어야 합니다. 이렇게 하면 clone 메서드의 호출자가 반환된 clone을 올바른 타입으로 캐스트할 필요가 없습니다.

참고: 이러한 공변 반환 타입은 Java 1.5 이상에서만 가능합니다."
CloseResource,errorprone,"리소스(`java.sql.Connection`, `java.sql.Statement`, `java.sql.ResultSet` 객체 및 `java.lang.AutoCloseable`의 모든 하위 타입)가 사용 후 항상 닫히는지 확인하세요.
그렇지 않으면 리소스 누수가 발생할 수 있습니다.

참고: 상위 타입(예: `java.lang.AutoCloseable`)을 설정하면 이 규칙이 모든 하위 타입(예: `java.io.FileInputStream`)에 대해 자동으로 트리거됩니다. 추가로 `java.sql.Connection`을 지정하면 타입 해석/auxclasspath가 올바르게 설정되지 않은 경우 타입 감지에 도움이 됩니다.

참고: PMD 6.16.0부터 `types` 속성의 기본값에 `java.lang.AutoCloseable`이 포함되어 표준 `java.io.*Stream` 클래스가 관련된 경우도 감지합니다. 이전 동작을 복원하려면 types에서 ""AutoCloseable""을 제거하세요."
CollectionTypeMismatch,errorprone,"타입 불일치로 인해 전달된 객체가 컬렉션에 있을 수 없는 컬렉션 메서드 호출을 감지합니다. 이는 호환되지 않는 타입이 컬렉션 메서드(contains(), remove(), indexOf() 등)와 함께 사용되는 잠재적인 프로그래밍 오류를 잡는 데 도움이 됩니다.

검사되는 메서드:
- Collection: contains(), remove(), removeAll(), retainAll(), containsAll()
- List: indexOf(), lastIndexOf()
- Map: containsKey(), containsValue(), get(), getOrDefault(), remove()
- Deque: removeFirstOccurrence(), removeLastOccurrence()
- Hashtable: contains() (값을 검사하는 레거시 메서드)
- ConcurrentHashMap: contains() (값을 검사하는 레거시 메서드)"
CompareObjectsWithEquals,errorprone,"객체 참조를 비교하려면 `equals()`를 사용하세요. `==`으로 비교하는 것을 피하세요.

명명된 상수와 객체를 비교하는 것이 유용한 경우가 있으므로(예: 센티널 값에 대한 상수를 정의할 때), 이 규칙은 모든 대문자 이름을 가진 필드와의 비교(예: `this == SENTINEL`)를 무시합니다. 이는 상수 필드에 대한 일반적인 네이밍 규칙입니다.

`typesThatCompareByReference` 속성에 예외를 나열하여 일부 타입의 참조 비교를 허용할 수 있습니다."
ComparisonWithNaN,errorprone,"double 및 float `NaN`(Not-a-Number) 값과의 비교를 보고합니다.
            이들은 직관적이지 않은 동작을 하도록 [지정](https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.21.1)되어 있습니다: NaN은 자기 자신과 같지 않은 것으로 간주됩니다.
            이는 `someDouble == Double.NaN`과 같은 검사가 `someDouble`이 실제로 NaN 값이더라도 항상 false를 반환한다는 것을 의미합니다. 값이 NaN 값인지 테스트하려면 대신 `Double.isNaN(someDouble)`(또는 `Float.isNaN`)을 사용해야 합니다. `!=` 연산자도 마찬가지로 처리해야 합니다.
            마지막으로, `someDouble <= Double.NaN`과 같은 비교는 무의미하며 항상 false로 평가됩니다.

            이 규칙은 PMD 6.36.0에서 ""BadComparison""에서 이름이 변경되었습니다."
ConfusingArgumentToVarargsMethod,errorprone,"가변인자 메서드에 전달된 혼란스러운 인수를 보고합니다.

            이는 배열이 단일 가변인자 인수로 전달될 때, 배열 타입이 가변인자 메서드가 기대하는 배열 타입과 정확히 일치하지 않을 때 발생할 수 있습니다. 해당 배열이 기대하는 배열 타입의 컴포넌트 타입의 하위 타입이면, 호출된 가변인자 메서드가 어떤 값을 받을지 명확하지 않을 수 있습니다.
            예를 들어 다음과 같은 경우:
            ```java
            void varargs(Object... parm);
            ```
            다음과 같이 호출하면:
            ```java
            varargs(new String[]{""a""});
            ```
            메서드가 `new Object[]{ new String[] {""a""} }` 값을 받을지 아니면 `new String[] {""a""}`만 받을지(후자가 발생) 명확하지 않습니다. 이 혼란은 `String[]`이 `Object[]`의 하위 타입이면서 동시에 `Object`의 하위 타입이기 때문에 발생합니다. 이 경우 의도를 명확히 하려면 캐스트를 사용하거나 개별 요소를 다음과 같이 전달하세요:
            ```java
            // varargs call
            // parm will be `new Object[] { ""a"" }`
            varargs(""a"");

            // non-varargs call
            // parm will be `new String[] { ""a"" }`
            varargs((Object[]) new String[]{""a""});

            // varargs call
            // parm will be `new Object[] { new String[] { ""a"" } }`
            varargs((Object) new String[]{""a""});
            ```

            또 다른 혼란스러운 경우는 가변인자 인수로 `null`을 전달하는 것입니다. 여기서 단일 null 요소를 가진 배열을 전달하려는 것인지, null 배열을 전달하려는 것인지(후자가 발생) 명확하지 않습니다. 이것도 마찬가지로 캐스트로 명확히 할 수 있습니다."
DetachedTestCase,errorprone,"이 메서드는 public 또는 default 가시성, 비정적 접근, 인수 없음, 반환 값 없음, 어노테이션 없음이지만, 하나 이상의 JUnit 테스트 케이스를 가진 클래스의 멤버이므로 테스트 케이스로 보입니다. 유틸리티 메서드라면 private 가시성을 가져야 합니다. 무시된 테스트라면 @Test와 @Ignore로 어노테이션되어야 합니다."
DoNotExtendJavaLangThrowable,errorprone,Throwable 대신 Exception 또는 RuntimeException을 확장하세요.
DoNotHardCodeSDCard,errorprone,"""/sdcard"" 대신 Environment.getExternalStorageDirectory()를 사용하세요"
DoNotTerminateVM,errorprone,"웹 애플리케이션은 `System.exit()`를 호출해서는 안 됩니다. 웹 컨테이너나 애플리케이션 서버만이 JVM을 중지해야 합니다. 그렇지 않으면 웹 애플리케이션이 동일한 애플리케이션 서버에서 실행 중인 모든 다른 애플리케이션을 종료시킵니다.

이 규칙은 동등한 호출인 `Runtime.getRuntime().exit()`와 `Runtime.getRuntime().halt()`도 검사합니다.

이 규칙은 PMD 6.29.0에서 ""DoNotCallSystemExit""에서 이름이 변경되었습니다."
DontUseFloatTypeForLoopIndices,errorprone,"루프 인덱스에 부동 소수점을 사용하지 마세요. 부동 소수점을 사용해야 한다면, float가 충분한 정밀도를 제공한다고 확신하고 성능 요구(공간 또는 시간)가 있는 경우가 아니라면 double을 사용하세요."
EmptyCatchBlock,errorprone,"빈 Catch 블록은 예외가 캐치되었지만 아무 작업도 수행되지 않는 인스턴스를 찾습니다.
대부분의 경우 이는 처리되거나 보고되어야 하는 예외를 삼키는 것입니다."
EmptyFinalizer,errorprone,빈 finalize 메서드는 아무 목적이 없으며 제거해야 합니다. Oracle은 JDK 9부터 Object.finalize()를 더 이상 사용되지 않음(deprecated)으로 선언했습니다.
FinalizeDoesNotCallSuperFinalize,errorprone,"finalize()가 구현된 경우, 마지막 동작은 super.finalize를 호출하는 것이어야 합니다. Oracle은 JDK 9부터 Object.finalize()를 더 이상 사용되지 않음(deprecated)으로 선언했습니다."
FinalizeOnlyCallsSuperFinalize,errorprone,"finalize()가 구현된 경우, super.finalize()를 호출하는 것 외에 다른 작업도 수행해야 합니다. Oracle은 JDK 9부터 Object.finalize()를 더 이상 사용되지 않음(deprecated)으로 선언했습니다."
FinalizeOverloaded,errorprone,"finalize()라는 이름의 메서드는 매개변수를 가져서는 안 됩니다. 이는 혼란스러우며 Object.finalize()를 오버로드하려는 시도일 가능성이 높습니다. VM에 의해 호출되지 않습니다.

Oracle은 JDK 9부터 Object.finalize()를 더 이상 사용되지 않음(deprecated)으로 선언했습니다."
FinalizeShouldBeProtected,errorprone,"finalize()를 오버라이드할 때, 새 메서드는 protected로 설정해야 합니다. public으로 만들면 다른 클래스가 부적절한 시점에 호출할 수 있습니다.

Oracle은 JDK 9부터 Object.finalize()를 더 이상 사용되지 않음(deprecated)으로 선언했습니다."
IdempotentOperations,errorprone,멱등 연산을 피하세요 - 아무 효과가 없습니다.
IdenticalConditionalBranches,errorprone,조건이 true일 때와 false일 때 동일한 작업을 수행하는 조건문은 잘못되었거나(분기 중 하나를 변경해야 함) 중복됩니다(분기 중 하나로 대체할 수 있음).
ImplicitSwitchFallThrough,errorprone,"각 case 옵션에 break 또는 return 문이 없는 switch 문은 문제가 있는 동작을 나타낼 수 있습니다. 빈 case는 의도적인 fall-through를 나타내므로 무시됩니다.

fall-through로 도달하는 case 레이블 앞에 `// fallthrough` 주석을 달거나, `@SuppressWarnings(""fallthrough"")`를 사용하여 위반을 무시할 수 있습니다.

이 규칙은 PMD 6.37.0에서 ""MissingBreakInSwitch""에서 이름이 변경되었습니다."
JumbledIncrementer,errorprone,"뒤섞인 루프 증분자를 피하세요 - 이는 보통 실수이며, 의도적이더라도 혼란스럽습니다."
JUnitSpelling,errorprone,"JUnit 3에서 setUp 메서드는 테스트 실행에 필요한 모든 데이터 엔티티를 설정하는 데 사용됩니다.
            tearDown 메서드는 테스트 실행에 필요한 모든 데이터 엔티티를 정리하는 데 사용됩니다.
            테스트가 모든 것을 올바르게 설정하고 정리하려면 메서드 이름의 철자를 틀려서는 안 됩니다."
JUnitStaticSuite,errorprone,JUnit 테스트의 suite() 메서드는 public이면서 static이어야 합니다.
MethodWithSameNameAsEnclosingClass,errorprone,"메서드는 포함 클래스와 동일한 이름을 가져서는 안 됩니다.
생성자처럼 보여 혼란스러울 수 있습니다."
MisplacedNullCheck,errorprone,"여기서 null 검사가 잘못 배치되었습니다. 변수가 null이면 `NullPointerException`이 발생합니다.
검사가 쓸모없거나(변수가 절대 `null`이 아님) 잘못된 것입니다."
MissingSerialVersionUID,errorprone,"Serializable 클래스는 serialVersionUID 필드를 제공해야 합니다.
serialVersionUID 필드는 추상 기본 클래스에도 필요합니다. 상속 체인의 각 개별 클래스는 자체 serialVersionUID 필드가 필요합니다. [Should an abstract class have a serialVersionUID](https://stackoverflow.com/questions/893259/should-an-abstract-class-have-a-serialversionuid)도 참조하세요."
MissingStaticMethodInNonInstantiatableClass,errorprone,"private 생성자를 가지고 static 메서드나 필드가 없는 클래스는 사용할 수 없습니다.

private 생성자 중 하나가 어노테이션으로 표시된 경우, 클래스는 더 이상 인스턴스화 불가능한 것으로 간주되지 않으며 위반이 보고되지 않습니다.
`annotations` 속성을 참조하세요."
NonSerializableClass,errorprone,"클래스가 `Serializable`로 표시된 경우 모든 필드도 직렬화 가능해야 합니다. 필드를 제외하려면 transient로 표시할 수 있습니다. Static 필드는 고려되지 않습니다.

이 규칙은 직렬화 불가능한 모든 필드를 보고합니다.

클래스가 수동 직렬화를 수행하는 메서드(`writeObject`, `readObject`)를 구현하거나 대체 객체(`writeReplace`, `readResolve`)를 사용하면 이 클래스는 무시됩니다.

참고: 이 규칙은 PMD 6.52.0에서 개편되었습니다. 이전에는 ""BeanMembersShouldSerialize""라고 불렸습니다.
`prefix` 속성은 더 이상 사용되지 않습니다. 직렬화 가능한 클래스에서는 이름에 관계없이 모든 필드가 직렬화 가능해야 하기 때문입니다."
NonStaticInitializer,errorprone,비정적 초기화 블록은 생성자가 호출될 때마다(생성자 호출 직전에) 호출됩니다. 이는 유효한 언어 구조이지만 거의 사용되지 않으며 혼란스럽습니다.
NullAssignment,errorprone,"변수에(선언 외부에서) ""null""을 할당하는 것은 일반적으로 좋지 않은 관행입니다. 때때로 이러한 유형의 할당은 프로그래머가 코드에서 무슨 일이 일어나고 있는지 완전히 이해하지 못하고 있다는 표시입니다.

참고: 이 종류의 할당은 객체를 역참조하고 가비지 컬렉션을 유도하기 위해 일부 경우에 사용될 수 있습니다."
OverrideBothEqualsAndHashcode,errorprone,"`public boolean Object.equals(Object other)`와 `public int Object.hashCode()`를 모두 오버라이드하거나 둘 다 오버라이드하지 마세요.
부모 클래스에서 `hashCode()`를 상속받더라도 `hashCode()`를 구현하고 명시적으로 상위 클래스에 위임하는 것을 고려하세요.

두 메서드를 모두 오버라이드하지 않으면 `equals()`와 `hashCode()` 사이의 계약을 위반할 수 있습니다. 가장 중요한 것은 두 인스턴스가 동일하면 동일한 해시 코드를 가져야 한다는 것입니다. `HashSet`이나 `HashMap`과 같은 해시 기반 컬렉션에서 이러한 유효하지 않은 인스턴스를 사용하면 중복되거나 누락된 항목이 발생할 수 있습니다.

이 규칙은 `Comparable`을 구현하는 타입을 고려하지 않습니다. 이에 대한 별도의 규칙 {% rule OverrideBothEqualsAndHashCodeOnComparable %}이 있습니다."
OverrideBothEqualsAndHashCodeOnComparable,errorprone,"`Comparable`을 구현하는 클래스는 인스턴스가 컬렉션에서 사용되는 경우 `equals()`와 `hashCode()`를 모두 오버라이드해야 합니다. 이는 클래스의 자연 순서가 `equals()`와 일관되도록 하기 위함입니다.
            그렇지 않으면 `Set` 인터페이스를 준수하지 않는 집합에서 예기치 않은 동작이 발생할 수 있습니다. `Set` 인터페이스는 객체 동등성을 결정하기 위해 `equals()`에 의존하지만, `TreeSet`과 같은 정렬된 집합은 대신 `compareTo()`를 사용합니다. 이러한 객체가 정렬된 맵의 키로 사용될 때도 동일한 문제가 발생할 수 있습니다.

            참고 1: 이 규칙은 {% rule OverrideBothEqualsAndHashcode %}와 관련이 있습니다. `Comparable`을 구현하는 클래스에 대해서만 누락된 `equals()` 및/또는 `hashCode()` 메서드를 보고합니다.

            참고 2: 이 규칙은 `equals()` 또는 `hashCode()` 중 하나만 오버라이드되고 둘 다 오버라이드되지 않은 경우에만 레코드를 보고합니다. 레코드가 생성된 equals/hashCode 메서드를 사용하는 경우, `compareTo()` 구현은 모든 레코드 컴포넌트가 고려되는 경우에만 `equals()`와 일관됩니다."
ProperLogger,errorprone,"로거는 일반적으로 private static final로 정의되어야 하며 올바른 클래스와 연결되어야 합니다.
`private final Log log;`은 로거를 전달해야 하는 드문 경우에도 허용되며, 로거가 생성자에 전달되어야 한다는 제한이 있습니다."
ReplaceJavaUtilCalendar,errorprone,"레거시 `java.util.Calendar` API는 오류가 발생하기 쉽고, 가변적이며, 스레드 안전하지 않습니다. 혼란스러운 월 인덱싱(1월 = 0),
일관성 없는 필드 의미론, 그리고 장황한 사용 패턴을 가지고 있습니다. 현대적인 `java.time API`(Java 8에서 도입)는
불변이고 스레드 안전한 대안을 명확하고 직관적인 메서드로 제공합니다.

`java.time` 패키지의 `LocalDate`(날짜 전용 연산), `LocalDateTime`(날짜와 시간),
또는 `ZonedDateTime`(시간대가 중요한 경우)을 대신 사용하세요.

참고: JPA 3.2(Jakarta Persistence) 이후로 `java.util.Date`와 `java.util.Calendar` 및 기타의 사용은
`java.time` API를 선호하여 더 이상 권장되지 않습니다."
ReplaceJavaUtilDate,errorprone,"레거시 `java.util.Date` 클래스는 가변적이고, 스레드 안전하지 않으며, 혼란스러운 API를 가지고 있습니다. 많은 메서드가
더 이상 사용되지 않으며, 시간대를 제대로 처리하지 못하고, 하나만 필요할 때도 날짜와 시간을 모두 나타냅니다.
생성자 매개변수는 특히 오류가 발생하기 쉽습니다: 연도는 ""1900 이후의 연도""이고 월은 0부터 시작합니다(1월 = 0).
현대적인 java.time API(Java 8에서 도입)는 더 나은 타입 안전성, 불변성, 그리고 명확한 의미론을 제공합니다.

`java.time` 패키지의 `LocalDate`(날짜만), `LocalTime`(시간만), `LocalDateTime`(날짜와 시간),
`Instant`(타임스탬프), 또는 `ZonedDateTime`(시간대가 있는 날짜-시간)을 대신 사용하세요.

참고: 이것은 `java.sql.Date`, `java.sql.Time` 및 `java.sql.Timestamp`와 같은 하위 타입도 포함합니다.
JPA 3.2(Jakarta Persistence) 이후로 `java.util.Date`와 `java.util.Calendar` 및 기타의 사용은
`java.time` API를 선호하여 더 이상 권장되지 않습니다."
ReturnFromFinallyBlock,errorprone,finally 블록에서 반환하는 것을 피하세요. 이는 예외를 무시할 수 있습니다.
SimpleDateFormatNeedsLocale,errorprone,SimpleDateFormat 인스턴스를 생성할 때 로캘에 적합한 형식이 사용되도록 Locale을 지정하세요.
StaticEJBFieldShouldBeFinal,errorprone,"J2EE 사양에 따르면, EJB는 쓰기 접근이 가능한 static 필드를 가져서는 안 됩니다.
그러나 static 읽기 전용 필드는 허용됩니다. 이는 컨테이너가 여러 JRE에
인스턴스를 분산할 때 올바른 동작을 보장합니다."
SuspiciousHashcodeMethodName,errorprone,메서드 이름과 반환 타입이 hashCode()와 의심스럽게 유사하여 hashCode() 메서드를 재정의하려는 의도를 나타낼 수 있습니다.
SuspiciousOctalEscape,errorprone,"문자열 리터럴 내에서 의심스러운 8진수 이스케이프 시퀀스가 발견되었습니다.
Java 언어 사양(섹션 3.10.6)에 따르면 리터럴 문자열 내의 8진수
이스케이프 시퀀스는 백슬래시 뒤에 다음이 와야 합니다:

    OctalDigit | OctalDigit OctalDigit | ZeroToThree OctalDigit OctalDigit

8진수 이스케이프 시퀀스 뒤에 8진수가 아닌 숫자가 오면 혼란을 줄 수 있습니다.
예를 들어 ""\038""은 8진수 이스케이프 시퀀스 ""\03"" 뒤에 리터럴 문자 ""8""이
오는 것으로 해석됩니다."
TestClassWithoutTestCases,errorprone,"테스트 클래스는 일반적으로 ""Test"", ""Tests"" 또는 ""TestCase"" 접두사나 접미사로 시작하거나 끝납니다. 해당 이름을 가진 비테스트 클래스는
좋은 관행이 아닙니다. 대부분의 사람들이 테스트 케이스라고 가정하기 때문입니다. 테스트 클래스에는
""testXXX""(JUnit3)라는 이름의 테스트 메서드가 있거나 어노테이션(예: `@Test`)을 사용합니다.

매칭할 정규식은 testClassPattern 속성을 사용하여 구성할 수 있습니다. 이름에 의한
테스트 클래스 감지를 비활성화하려면 이 속성을 빈 문자열로 설정하세요."
UnconditionalIfStatement,errorprone,"조건이 항상 true이거나 항상 false인 ""if"" 문을 사용하지 마세요."
UnnecessaryBooleanAssertion,errorprone,"boolean 리터럴을 사용한 JUnit 테스트 단언은 항상 같은 값으로 평가되므로 불필요합니다.
흐름 제어를 사용하거나(`assertTrue(false)` 또는 유사한 경우) `assertTrue(true)` 및 `assertFalse(false)` 같은
문을 단순히 제거하는 것을 고려하세요. 오류를 발견한 후 테스트를 중단하려면 `fail()` 메서드를
사용하고 왜 중단되었는지에 대한 표시 메시지를 제공하세요."
UnnecessaryCaseChange,errorprone,toUpperCase/toLowerCase().equals()를 사용하는 것보다 equalsIgnoreCase()를 사용하는 것이 더 빠릅니다.
UnnecessaryConversionTemporary,errorprone,기본 타입을 문자열로 변환할 때 임시 객체를 사용하지 마세요. 대신 래퍼 클래스의 정적 변환 메서드를 사용하세요.
UnsupportedJdkApiUsage,errorprone,"`sun.*` 또는 `jdk.internal.*` 패키지의 클래스를 임포트하거나 API를 사용하는 것을 피하세요.
`sun.misc.Unsafe` 또는 `jdk.internal.misc.Unsafe`를 포함합니다. 이 패키지들은 이식성이 없고 안정적이지 않으며
향후 JDK 버전에서 변경되거나 제거될 수 있습니다. 이름에서 알 수 있듯이, `Unsafe` 클래스의 메서드는 특히 위험하며
VarHandle API(JDK 9에서 도입)와 Foreign Function &amp; Memory API(JDK 22에서 도입) 같은
더 안전한 대안으로 대체되었습니다. 예제가 포함된 더 안전한 대안은 [JEP 471](https://openjdk.org/jeps/471)을 참조하세요.

Sun API에 의존해야 하는 경우, 안정적인 래퍼 클래스 내부와 같이 최소한의 격리된 범위에 사용을 제한하세요.
이러한 래퍼의 구현에서 이 규칙을 억제할 수 있지만, 가능한 한 공식 API로 마이그레이션하는 것이
강력히 권장됩니다.

이러한 지원되지 않는 API의 사용은 내부 용도로만 의도되었으므로 Java 컴파일러에 의해서도
경고됩니다. 이 PMD 규칙은 독립적인 코드 검토를 용이하게 하고 컴파일러 경고가
간과되었을 수 있는 인스턴스를 포착하기 위해 추가되었습니다."
UnusedNullCheckInEquals,errorprone,"객체 참조가 null인지 확인한 후에는, 그 객체를 다른 객체의 equals() 메서드에 전달하는 것이 아니라
해당 객체에서 equals()를 호출해야 합니다."
UseCorrectExceptionLogging,errorprone,"전체 스택 트레이스가 출력되도록 하려면 String과 Throwable 두 개의 인수를 가진 로깅 문을 사용하세요.

이 규칙은 [Apache Commons Logging](https://commons.apache.org/proper/commons-logging/)에만 적용됩니다."
UseEqualsToCompareStrings,errorprone,"'==' 또는 '!='를 사용하여 문자열을 비교하는 것은 양쪽 모두에 인턴된 문자열(`String#intern()`)을
사용하는 경우에만 신뢰할 수 있습니다.

대신 `equals()` 메서드를 사용하세요."
UselessOperationOnImmutable,errorprone,"불변 객체에 대한 연산은 연산 결과가 새로운 객체이므로 객체 자체를 변경하지 않습니다.
따라서 이러한 연산의 결과를 무시하는 것은 아마도 실수입니다. 해당 연산을 제거할 수 있을 것입니다.

이 규칙은 `String`, `BigDecimal`, `BigInteger` 또는 `java.time.*`의 모든 타입을 불변으로 인식합니다.

**더 이상 사용되지 않음:** 이 규칙은 PMD 7.17.0부터 더 이상 사용되지 않으며 PMD 8.0.0에서 제거됩니다.
이 규칙은 {% rule UselessPureMethodCall %}로 대체되었습니다."
UselessPureMethodCall,errorprone,"이 규칙은 결과가 사용되지 않는 순수 메서드 호출을 감지합니다. 순수 메서드는 부작용이 없는 메서드입니다.
따라서 이러한 메서드 호출의 결과를 무시하는 것은 아마도 실수입니다.

메서드 호출을 제거하거나 결과를 사용해야 합니다."
UseLocaleWithCaseConversions,errorprone,"`String::toLowerCase()/toUpperCase()` 변환을 수행할 때 대소문자 변환 규칙을 지정하기 위해
명시적 locale 인수를 사용하세요.

인수 없이 `String::toLowerCase()`를 사용하면 암시적으로 `Locale::getDefault()`를 사용합니다.
문제는 기본 로캘이 현재 JVM 설정(보통 실행 중인 시스템)에 따라 달라진다는 것입니다.
시스템 기본값을 사용하는 것이 정확히 원하는 것일 수 있지만(예: 표준 입력을 통해 받은 문자열을 조작하는 경우),
그렇지 않을 수도 있습니다(예: 네트워크나 파일을 통해 문자열을 받고 인코딩이 환경과 무관하게
잘 정의된 경우). 후자의 경우, 기본 로캘을 사용하면 다른 대소문자 변환 규칙을 가진
로캘의 시스템에서 예상치 못한 결과를 낼 수 있어 대소문자 변환이 불안정해집니다.
예를 들어 터키어에서 `i`의 대문자 형태는 영어에서의 `I`(U+0049)가 아닌 `\u0130`(U+0130, 비ASCII)입니다.

이 규칙은 문자열을 다룰 때 개발자가 로캘에 대해 생각하도록 *강제*하기 위한 것입니다.
작성 시점에 로캘 선택에 대한 의식적인 결정을 내림으로써, 나중에 놀라운 동작의 위험을 줄이고
미래의 독자에게 의도를 전달할 수 있습니다."
UseProperClassLoader,errorprone,"J2EE에서 getClassLoader() 메서드가 예상대로 동작하지 않을 수 있습니다.
대신 Thread.currentThread().getContextClassLoader()를 사용하세요."
DoNotThrowExceptionInFinally,errorprone,"'finally' 블록 내에서 예외를 던지는 것은 다른 예외나 코드 결함을 마스킹할 수 있으므로 혼란스럽습니다.
참고: 이것은 Lint4j 규칙 ""A throw in a finally block""의 PMD 구현입니다"
DontImportSun,errorprone,"'sun.*' 패키지에서 임포트하는 것을 피하세요. 이 패키지들은 이식성이 없으며 변경될 수 있습니다.

Sun API에 의존해야 하는 경우, 이 의존성을 가능한 한 작은 범위로 제한하세요. 예를 들어, 불안정한 API 주변에 안정적인 래퍼 클래스를 작성합니다. 그런 다음 래퍼의 구현에서 이 규칙을 억제할 수 있습니다.

**더 이상 사용되지 않음:** 이 규칙은 PMD 7.21.0부터 더 이상 사용되지 않으며 PMD 8.0.0에서 제거될 예정입니다.
이 규칙은 {% rule UnsupportedJdkApiUsage %}로 대체되었습니다."
InstantiationToGetClass,errorprone,getClass()를 호출하기 위해 객체를 인스턴스화하지 마세요. 대신 .class public 멤버를 사용하세요.
StringBufferInstantiationWithChar,errorprone,"초기화 인수로 제공된 개별 문자 값은 정수로 변환됩니다.
이로 인해 예상보다 큰 내부 버퍼 크기가 발생할 수 있습니다. 예시:

```
new StringBuffer()      //  16
new StringBuffer(6)     //  6
new StringBuffer(""hello world"")  // 11 + 16 = 27
new StringBuffer('A')   //  chr(A) = 65
new StringBuffer(""A"")   //  1 + 16 = 17

new StringBuilder()     //  16
new StringBuilder(6)    //  6
new StringBuilder(""hello world"")  // 11 + 16 = 27
new StringBuilder('C')   //  chr(C) = 67
new StringBuilder(""A"")   //  1 + 16 = 17
```"
InvalidLogMessageFormat,errorprone,"slf4j 및 log4j2(6.19.0부터) 로거에서 인수와 플레이스홀더의 수가 일치하지 않는 메시지를 검사합니다.

6.32.0부터 매개변수화된 메시지 플레이스홀더(`{}`) 외에도 문자열 형식 메시지의 형식 지정자(`%s`)도 지원됩니다.

이 규칙은 PMD 6.19.0에서 ""InvalidSlf4jMessageFormat""에서 이름이 변경되었습니다."
DoubleCheckedLocking,multithreading,"Java에서 이중 검사 잠금(Double Checked Locking) 패턴을 사용하면 부분적으로 생성된 객체가 반환될 수 있습니다.
최적화된 JRE는 참조가 가리키는 객체의 생성자를 호출하기 전에 baz 변수에 참조를 할당할 수 있습니다.

참고: Java 5부터는 변수를 `volatile`로 선언하면 이중 검사 잠금이 동작하도록 할 수 있습니다.

자세한 내용은 다음을 참조하세요: &lt;http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html>
또는 &lt;http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html>"
AvoidUsingVolatile,multithreading,"'volatile' 키워드의 사용은 일반적으로 Java 애플리케이션을 세밀하게 조정하는 데 사용되며, 따라서 Java 메모리 모델에 대한
높은 전문 지식이 필요합니다. 더욱이 그 작동 범위는 다소 잘못 알려져 있습니다. 그러므로 volatile 키워드는
유지보수 목적 및 이식성을 위해 사용해서는 안 됩니다."
AvoidSynchronizedAtMethodLevel,multithreading,"메서드 수준의 동기화는 가상 스레드를 고정(pin)시키며 성능 문제를 일으킬 수 있습니다. 또한 메서드에 새로운 코드가 추가될 때
문제를 일으킬 수 있습니다. 블록 수준의 ReentrantLock은 상호 배제가 필요한 코드만 잠금되도록 보장하는 데 도움이 됩니다."
AvoidSynchronizedStatement,multithreading,동기화는 가상 스레드를 고정(pin)시키며 성능 문제를 일으킬 수 있습니다.
AvoidThreadGroup,multithreading,"java.lang.ThreadGroup 사용을 피하세요; 스레드 환경에서 사용하도록 설계되었지만
스레드 안전하지 않은 메서드를 포함하고 있습니다."
DoNotUseThreads,multithreading,"J2EE 사양은 스레드 사용을 명시적으로 금지합니다. 스레드는 J2EE 서버에 의해 관리되고 모니터링되어야 하는 자원입니다.
애플리케이션이 자체적으로 스레드를 생성하거나 자체 커스텀 스레드 풀을 사용하면 해당 스레드는 관리되지 않으며, 이는 자원 고갈로 이어질 수 있습니다.
또한 EJB는 클러스터 내의 머신 간에 이동될 수 있으며, 관리되는 자원만 함께 이동할 수 있습니다."
NonThreadSafeSingleton,multithreading,"스레드 안전하지 않은 싱글톤은 잘못된 상태 변경을 초래할 수 있습니다. 가능하면 객체를 직접 인스턴스화하여
정적 싱글톤을 제거하세요. 정적 싱글톤은 어차피 단일 인스턴스만 존재하므로 일반적으로 필요하지 않습니다.
다른 가능한 해결책으로는 전체 메서드를 동기화하거나
[요청 시 초기화 홀더 클래스(initialize-on-demand holder class)](https://en.wikipedia.org/wiki/Initialization-on-demand_holder_idiom)를 사용하는 것입니다.

이중 검사 잠금(double-checked locking) 패턴의 사용을 자제하세요. Java 메모리 모델은
변수가 `volatile`로 선언되지 않는 한 이 패턴의 동작을 보장하지 않으며, 불필요한 성능 저하를 초래합니다.
[참조](http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html)

Effective Java 항목 48을 참조하세요."
UnsynchronizedStaticFormatter,multithreading,"`java.text.Format`의 인스턴스는 일반적으로 동기화되지 않습니다.
Sun은 각 스레드마다 별도의 포맷 인스턴스를 사용할 것을 권장합니다.
여러 스레드가 정적 포매터에 접근해야 하는 경우, 포매터는 블록 수준에서
동기화되어야 합니다."
UseConcurrentHashMap,multithreading,"Java 5에서 멀티스레드 접근을 위해 설계된 새로운 Map 구현이 도입되었으므로, 다른 스레드를 차단하지 않고
효율적인 맵 읽기를 수행할 수 있습니다."
UseNotifyAllInsteadOfNotify,multithreading,"Thread.notify()는 객체를 모니터링하는 스레드 하나를 깨웁니다. 둘 이상의 스레드가 모니터링하고 있는 경우
하나만 선택됩니다. 선택되는 스레드는 임의적이므로, 일반적으로 notifyAll()을 호출하는 것이 더 안전합니다."
DontCallThreadRun,multithreading,Thread.run() 메서드를 명시적으로 호출하면 호출자의 제어 스레드에서 실행됩니다. 의도한 동작을 위해서는 Thread.start()를 호출하세요.
AvoidFileStream,performance,"FileInputStream과 FileOutputStream 클래스에는 가비지 컬렉션 일시 중지를 유발하는
finalizer 메서드가 포함되어 있습니다.
자세한 내용은 [JDK-8080225](https://bugs.openjdk.org/browse/JDK-8080225)를 참조하십시오.

FileReader와 FileWriter 생성자는 FileInputStream과 FileOutputStream을 인스턴스화하므로,
finalizer 메서드가 호출되면서 가비지 컬렉션 문제가 다시 발생합니다.

* `new FileInputStream(fileName)` 대신 `Files.newInputStream(Paths.get(fileName))`을 사용하십시오.
* `new FileOutputStream(fileName)` 대신 `Files.newOutputStream(Paths.get(fileName))`을 사용하십시오.
* `new FileReader(fileName)` 대신 `Files.newBufferedReader(Paths.get(fileName))`을 사용하십시오.
* `new FileWriter(fileName)` 대신 `Files.newBufferedWriter(Paths.get(fileName))`을 사용하십시오.

참고로, `java.nio` API는 더 이상 `FileNotFoundException`을 던지지 않으며, 대신
`NoSuchFileException`을 던집니다. 코드에서 `FileNotFoundException`을 명시적으로 처리했다면
이를 조정해야 합니다. 두 예외 모두 `IOException`의 하위 클래스이므로,
이를 catch하면 둘 다 처리됩니다."
StringInstantiation,performance,String 객체의 인스턴스화를 피하십시오; 문자열은 불변이며 안전하게 공유할 수 있으므로 이는 일반적으로 불필요합니다.
AddEmptyString,performance,"빈 문자열과 연결하여 리터럴을 문자열로 변환하는 것은 비효율적입니다.
대신 타입별 `toString()` 메서드나 `String.valueOf()`를 사용하는 것이 훨씬 좋습니다."
AppendCharacterWithChar,performance,StringBuffer/StringBuilder.append 메서드에서 문자를 문자열로 연결하는 것을 피하십시오.
AvoidArrayLoops,performance,"두 배열 간에 데이터를 수동으로 복사하는 대신, 더 효율적인 `Arrays.copyOf` 또는
`System.arraycopy` 메서드를 사용하십시오.

배열의 일부만 복사하려면 `Arrays.copyOfRange` 또는 `System.arraycopy`를 사용하십시오.

_같은_ 배열 내에서 요소를 복사/이동하려면 (예: 요소 이동), `System.arraycopy`를 사용하십시오."
AvoidCalendarDateCreation,performance,"문제: `java.util.Calendar`는 무거운 객체이며 생성 비용이 높습니다. 캘린더 계산이 필요한 경우에만
사용해야 합니다.

해결책: `new Date()`, Java 8 이상의 `java.time.LocalDateTime.now()` 또는 `ZonedDateTime.now()`를 사용하십시오."
AvoidInstantiatingObjectsInLoops,performance,루프 내에서 생성된 새 객체는 루프 외부에서 생성하여 재사용할 수 있는지 확인해야 합니다.
BigIntegerInstantiation,performance,"이미 존재하는 BigInteger(`BigInteger.ZERO`, `BigInteger.ONE`)의 인스턴스를 생성하지 마십시오.
Java 1.5 이상에서는 BigInteger.TEN과 BigDecimal(`BigDecimal.ZERO`, `BigDecimal.ONE`, `BigDecimal.TEN`)을,
Java 9 이상에서는 `BigInteger.TWO`를 사용하십시오."
ConsecutiveAppendsShouldReuse,performance,"StringBuffer/StringBuilder .append의 연속 호출은 대상 객체를 재사용하여 체이닝해야 합니다. 이렇게 하면 더 작은 바이트코드를 생성하고,
오버헤드를 줄이며, 인라이닝을 개선하여 성능을 향상시킬 수 있습니다. 전체 분석은 [여기](https://github.com/pmd/pmd/issues/202#issuecomment-274349067)에서 확인할 수 있습니다."
ConsecutiveLiteralAppends,performance,"StringBuffer/StringBuilder.append(...)를 리터럴로 연속 호출하는 것은 피해야 합니다.
리터럴은 상수이므로 이미 하나의 문자열 리터럴로 결합할 수 있으며, 이 문자열을
단일 메서드 호출로 추가할 수 있습니다."
InefficientEmptyStringCheck,performance,"`string.trim()` 또는 `string.strip()`의 길이를 확인하는 것은 문자열이 실제로 공백인지
결정하는 비효율적인 방법입니다. 크기를 확인하기 위해 새로운 `String` 객체를 생성하기 때문입니다.
Java 11부터는 `string.isBlank()`를 사용하여 문자열이 공백으로만 구성되어 있는지 결정할 수 있으며,
이 검사는 `string.strip().isEmpty()`와 동일합니다. `string.trim().isEmpty()`의 의미를 얻으려면
문자를 반복하면서 0x20과 비교할 수 있습니다:

```java
private boolean checkTrimEmpty(String str) {
    return str.chars().allMatch(c -> c <= 0x20);
}
```

null 검사를 포함하는 라이브러리 함수를 사용하는 것도 고려할 수 있습니다
(예: commons-lang의 Apache `StringUtils#isBlank`,
Spring 프레임워크의 `StringUtils#hasText`) 또는 다른 공백 정의를 사용할 수 있습니다
(예: Guava의 Google `CharMatcher#whitespace`).

`string.strip().isBlank()` 호출도 중복이며 `string.isBlank()`로 단순화해야 합니다."
InefficientStringBuffering,performance,"StringBuffer 생성자 또는 append()에서 비리터럴을 연결하는 것을 피하십시오. 중간 버퍼가
JVM에 의해 생성되고 파괴되어야 하기 때문입니다."
InsufficientStringBufferDeclaration,performance,"StringBuffer 또는 StringBuilder의 크기를 적절히 미리 설정하지 않으면 런타임 중에 여러 번
크기를 재조정해야 할 수 있습니다. 이 규칙은 실제로 StringBuffer.append()에 전달되는
총 문자 수를 결정하려고 시도하지만, ""최악의 경우"" 시나리오에 대한 최선의 추정을 나타냅니다.
빈 StringBuffer/StringBuilder 생성자는 객체를 16자로 초기화합니다. 생성자의 길이를
결정할 수 없는 경우 이 기본값이 사용됩니다."
OptimizableToArrayCall,performance,"컬렉션의 `toArray(E[])` 메서드 호출은 크기가 0인 대상 배열을 지정해야 합니다. 이렇게 하면 JVM이
메모리 할당과 복사를 최대한 최적화할 수 있습니다.

이 규칙의 이전 버전(PMD 6.0.0 이전)은 반대를 제안했지만, 현재 JVM 구현은
대상 배열에 대한 완전한 제어권을 가질 때 항상 더 나은 성능을 보입니다. 또한 리플렉션을 통한
배열 할당은 현재 직접 할당만큼 빠릅니다.

[Arrays of Wisdom of the Ancients](https://shipilev.net/blog/2016/arrays-wisdom-ancients/)도 참조하십시오.

참고: 올바른 타입의 배열이 필요하지 않은 경우, 배열 없이 사용하는 단순한 `toArray()` 메서드가
더 빠르지만, `Object[]` 타입의 배열만 반환합니다."
RedundantFieldInitializer,performance,"Java는 알려진 기본값으로 필드를 초기화하므로, 동일한 기본값의 명시적 초기화는
중복이며 더 큰 클래스 파일을 생성합니다(필드당 약 3개의 추가 바이트코드 명령어)."
StringToString,performance,이미 문자열 인스턴스로 알려진 객체에서 toString()을 호출하는 것을 피하십시오; 이는 불필요합니다.
UseArrayListInsteadOfVector,performance,스레드 안전 연산이 필요하지 않은 경우 ArrayList는 Vector보다 훨씬 더 나은 Collection 구현입니다.
UseArraysAsList,performance,"`java.util.Arrays` 클래스에는 객체 배열에서 새 List를 생성할 때 사용해야 하는 `asList()` 메서드가 있습니다.
배열의 모든 요소를 하나씩 복사하는 루프를 실행하는 것보다 더 빠릅니다.

`Arrays.asList()`의 결과는 지정된 배열에 의해 지원되며,
반환된 리스트의 변경 사항은 배열이 수정되는 결과를 초래합니다.
이러한 이유로 `Arrays.asList()`의 반환 리스트에 새 요소를 추가하는 것은 불가능합니다
(UnsupportedOperationException).
이것이 불편한 경우(예: 동시 접근 때문) `new ArrayList<>(Arrays.asList(...))`를 사용해야 합니다."
UseIndexOfChar,performance,단일 문자의 인덱스를 확인할 때는 String.indexOf(char)를 사용하십시오; 더 빠르게 실행됩니다.
UseIOStreamsWithApacheCommonsFileItem,performance,"문제: [FileItem.get()](https://javadoc.io/static/commons-fileupload/commons-fileupload/1.5/org/apache/commons/fileupload/FileItem.html#get--)
및 [FileItem.getString()](https://javadoc.io/static/commons-fileupload/commons-fileupload/1.5/org/apache/commons/fileupload/FileItem.html#getString--)의 사용은
전체 파일을 메모리에 로드하므로 메모리를 고갈시킬 수 있습니다.

해결책: [FileItem.getInputStream()](https://javadoc.io/static/commons-fileupload/commons-fileupload/1.5/org/apache/commons/fileupload/FileItem.html#getInputStream--)
및 버퍼링을 사용하십시오."
UselessStringValueOf,performance,문자열에 추가하기 위해 String.valueOf를 호출할 필요가 없습니다; valueOf()의 인자를 직접 사용하면 됩니다.
UseStringBufferForStringAppends,performance,"문자열 추가를 위한 '+=' 연산자의 사용은 JVM이 내부 StringBuffer를 생성하고 사용하게 만듭니다.
이러한 연결이 상당수 사용되는 경우 StringBuilder 또는 스레드 안전한 StringBuffer를 명시적으로
사용하는 것이 이를 피하기 위해 권장됩니다."
UseStringBufferLength,performance,"StringBuffer.toString().equals("""") 또는 StringBuffer.toString().length() == ... 대신
StringBuffer.length()를 사용하여 StringBuffer의 길이를 확인하십시오."
HardCodedCryptoKey,security,암호화 작업에 하드코딩된 값을 사용하지 마세요. 키는 소스 코드 외부에 저장해야 합니다.
InsecureCryptoIv,security,암호화 작업에 하드코딩된 초기화 벡터(IV)를 사용하지 마세요. 무작위로 생성된 IV를 사용하세요.
